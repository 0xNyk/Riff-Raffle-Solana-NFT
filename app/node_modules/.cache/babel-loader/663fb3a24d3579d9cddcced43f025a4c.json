{"ast":null,"code":"import { METADATA_PROGRAM_ID } from './programIds';\nimport { deserializeUnchecked } from 'borsh';\nimport { PublicKey } from '@solana/web3.js';\nimport { extendBorsh } from './borsh';\nextendBorsh();\nexport const METADATA_PREFIX = 'metadata';\nexport const EDITION = 'edition';\nexport const RESERVATION = 'reservation';\nexport const MAX_NAME_LENGTH = 32;\nexport const MAX_SYMBOL_LENGTH = 10;\nexport const MAX_URI_LENGTH = 200;\nexport const MAX_CREATOR_LIMIT = 5;\nexport const MAX_CREATOR_LEN = 32 + 1 + 1;\nexport const MAX_METADATA_LEN = 1 + 32 + 32 + MAX_NAME_LENGTH + MAX_SYMBOL_LENGTH + MAX_URI_LENGTH + MAX_CREATOR_LIMIT * MAX_CREATOR_LEN + 2 + 1 + 1 + 198;\nexport const MAX_EDITION_LEN = 1 + 32 + 8 + 200;\nexport const EDITION_MARKER_BIT_SIZE = 248;\nexport let MetadataKey;\n\n(function (MetadataKey) {\n  MetadataKey[MetadataKey[\"Uninitialized\"] = 0] = \"Uninitialized\";\n  MetadataKey[MetadataKey[\"MetadataV1\"] = 4] = \"MetadataV1\";\n  MetadataKey[MetadataKey[\"EditionV1\"] = 1] = \"EditionV1\";\n  MetadataKey[MetadataKey[\"MasterEditionV1\"] = 2] = \"MasterEditionV1\";\n  MetadataKey[MetadataKey[\"MasterEditionV2\"] = 6] = \"MasterEditionV2\";\n  MetadataKey[MetadataKey[\"EditionMarker\"] = 7] = \"EditionMarker\";\n})(MetadataKey || (MetadataKey = {}));\n\nexport let MetadataCategory;\n\n(function (MetadataCategory) {\n  MetadataCategory[\"Audio\"] = \"audio\";\n  MetadataCategory[\"Video\"] = \"video\";\n  MetadataCategory[\"Image\"] = \"image\";\n  MetadataCategory[\"VR\"] = \"vr\";\n})(MetadataCategory || (MetadataCategory = {}));\n\nexport class MasterEditionV1 {\n  /// Can be used to mint tokens that give one-time permission to mint a single limited edition.\n  /// If you don't know how many printing tokens you are going to need, but you do know\n  /// you are going to need some amount in the future, you can use a token from this mint.\n  /// Coming back to token metadata with one of these tokens allows you to mint (one time)\n  /// any number of printing tokens you want. This is used for instance by Auction Manager\n  /// with participation NFTs, where we dont know how many people will bid and need participation\n  /// printing tokens to redeem, so we give it ONE of these tokens to use after the auction is over,\n  /// because when the auction begins we just dont know how many printing tokens we will need,\n  /// but at the end we will. At the end it then burns this token with token-metadata to\n  /// get the printing tokens it needs to give to bidders. Each bidder then redeems a printing token\n  /// to get their limited editions.\n  constructor(args) {\n    this.key = void 0;\n    this.supply = void 0;\n    this.maxSupply = void 0;\n    this.printingMint = void 0;\n    this.oneTimePrintingAuthorizationMint = void 0;\n    this.key = MetadataKey.MasterEditionV1;\n    this.supply = args.supply;\n    this.maxSupply = args.maxSupply;\n    this.printingMint = args.printingMint;\n    this.oneTimePrintingAuthorizationMint = args.oneTimePrintingAuthorizationMint;\n  }\n\n}\nexport class MasterEditionV2 {\n  constructor(args) {\n    this.key = void 0;\n    this.supply = void 0;\n    this.maxSupply = void 0;\n    this.key = MetadataKey.MasterEditionV2;\n    this.supply = args.supply;\n    this.maxSupply = args.maxSupply;\n  }\n\n}\nexport class EditionMarker {\n  constructor(args) {\n    this.key = void 0;\n    this.ledger = void 0;\n    this.key = MetadataKey.EditionMarker;\n    this.ledger = args.ledger;\n  }\n\n  editionTaken(edition) {\n    const editionOffset = edition % EDITION_MARKER_BIT_SIZE;\n    const indexOffset = Math.floor(editionOffset / 8);\n\n    if (indexOffset > 30) {\n      throw Error('bad index for edition');\n    }\n\n    const positionInBitsetFromRight = 7 - editionOffset % 8;\n    const mask = Math.pow(2, positionInBitsetFromRight);\n    const appliedMask = this.ledger[indexOffset] & mask;\n    return appliedMask !== 0;\n  }\n\n}\nexport class Edition {\n  /// Points at MasterEdition struct\n  /// Starting at 0 for master record, this is incremented for each edition minted.\n  constructor(args) {\n    this.key = void 0;\n    this.parent = void 0;\n    this.edition = void 0;\n    this.key = MetadataKey.EditionV1;\n    this.parent = args.parent;\n    this.edition = args.edition;\n  }\n\n}\nexport class Creator {\n  constructor(args) {\n    this.address = void 0;\n    this.verified = void 0;\n    this.share = void 0;\n    this.address = args.address;\n    this.verified = args.verified;\n    this.share = args.share;\n  }\n\n}\nexport class Data {\n  constructor(args) {\n    this.name = void 0;\n    this.symbol = void 0;\n    this.uri = void 0;\n    this.sellerFeeBasisPoints = void 0;\n    this.creators = void 0;\n    this.name = args.name;\n    this.symbol = args.symbol;\n    this.uri = args.uri;\n    this.sellerFeeBasisPoints = args.sellerFeeBasisPoints;\n    this.creators = args.creators;\n  }\n\n}\nexport class Metadata {\n  // set lazy\n  constructor(args) {\n    this.key = void 0;\n    this.updateAuthority = void 0;\n    this.mint = void 0;\n    this.data = void 0;\n    this.primarySaleHappened = void 0;\n    this.isMutable = void 0;\n    this.editionNonce = void 0;\n    this.masterEdition = void 0;\n    this.edition = void 0;\n    this.key = MetadataKey.MetadataV1;\n    this.updateAuthority = args.updateAuthority;\n    this.mint = args.mint;\n    this.data = args.data;\n    this.primarySaleHappened = args.primarySaleHappened;\n    this.isMutable = args.isMutable;\n    this.editionNonce = args.editionNonce;\n  }\n\n  async init() {\n    const edition = await getEdition(this.mint);\n    this.edition = edition;\n    this.masterEdition = edition;\n  }\n\n}\n\nclass CreateMetadataArgs {\n  constructor(args) {\n    this.instruction = 0;\n    this.data = void 0;\n    this.isMutable = void 0;\n    this.data = args.data;\n    this.isMutable = args.isMutable;\n  }\n\n}\n\nclass UpdateMetadataArgs {\n  // Not used by this app, just required for instruction\n  constructor(args) {\n    this.instruction = 1;\n    this.data = void 0;\n    this.updateAuthority = void 0;\n    this.primarySaleHappened = void 0;\n    this.data = args.data ? args.data : null;\n    this.updateAuthority = args.updateAuthority ? args.updateAuthority : null;\n    this.primarySaleHappened = args.primarySaleHappened;\n  }\n\n}\n\nclass CreateMasterEditionArgs {\n  constructor(args) {\n    this.instruction = 10;\n    this.maxSupply = void 0;\n    this.maxSupply = args.maxSupply;\n  }\n\n}\n\nclass MintPrintingTokensArgs {\n  constructor(args) {\n    this.instruction = 9;\n    this.supply = void 0;\n    this.supply = args.supply;\n  }\n\n}\n\nexport const METADATA_SCHEMA = new Map([[CreateMetadataArgs, {\n  kind: 'struct',\n  fields: [['instruction', 'u8'], ['data', Data], ['isMutable', 'u8'] // bool\n  ]\n}], [UpdateMetadataArgs, {\n  kind: 'struct',\n  fields: [['instruction', 'u8'], ['data', {\n    kind: 'option',\n    type: Data\n  }], ['updateAuthority', {\n    kind: 'option',\n    type: 'pubkeyAsString'\n  }], ['primarySaleHappened', {\n    kind: 'option',\n    type: 'u8'\n  }]]\n}], [CreateMasterEditionArgs, {\n  kind: 'struct',\n  fields: [['instruction', 'u8'], ['maxSupply', {\n    kind: 'option',\n    type: 'u64'\n  }]]\n}], [MintPrintingTokensArgs, {\n  kind: 'struct',\n  fields: [['instruction', 'u8'], ['supply', 'u64']]\n}], [MasterEditionV1, {\n  kind: 'struct',\n  fields: [['key', 'u8'], ['supply', 'u64'], ['maxSupply', {\n    kind: 'option',\n    type: 'u64'\n  }], ['printingMint', 'pubkeyAsString'], ['oneTimePrintingAuthorizationMint', 'pubkeyAsString']]\n}], [MasterEditionV2, {\n  kind: 'struct',\n  fields: [['key', 'u8'], ['supply', 'u64'], ['maxSupply', {\n    kind: 'option',\n    type: 'u64'\n  }]]\n}], [Edition, {\n  kind: 'struct',\n  fields: [['key', 'u8'], ['parent', 'pubkeyAsString'], ['edition', 'u64']]\n}], [Data, {\n  kind: 'struct',\n  fields: [['name', 'string'], ['symbol', 'string'], ['uri', 'string'], ['sellerFeeBasisPoints', 'u16'], ['creators', {\n    kind: 'option',\n    type: [Creator]\n  }]]\n}], [Creator, {\n  kind: 'struct',\n  fields: [['address', 'pubkeyAsString'], ['verified', 'u8'], ['share', 'u8']]\n}], [Metadata, {\n  kind: 'struct',\n  fields: [['key', 'u8'], ['updateAuthority', 'pubkeyAsString'], ['mint', 'pubkeyAsString'], ['data', Data], ['primarySaleHappened', 'u8'], // bool\n  ['isMutable', 'u8'] // bool\n  ]\n}], [EditionMarker, {\n  kind: 'struct',\n  fields: [['key', 'u8'], ['ledger', [31]]]\n}]]); // eslint-disable-next-line no-control-regex\n\nconst METADATA_REPLACE = new RegExp('\\u0000', 'g');\nexport const decodeMetadata = buffer => {\n  const metadata = deserializeUnchecked(METADATA_SCHEMA, Metadata, buffer);\n  metadata.data.name = metadata.data.name.replace(METADATA_REPLACE, '');\n  metadata.data.uri = metadata.data.uri.replace(METADATA_REPLACE, '');\n  metadata.data.symbol = metadata.data.symbol.replace(METADATA_REPLACE, '');\n  return metadata;\n};\nexport async function getEdition(tokenMint) {\n  return (await PublicKey.findProgramAddress([Buffer.from(METADATA_PREFIX), METADATA_PROGRAM_ID.toBuffer(), new PublicKey(tokenMint).toBuffer(), Buffer.from(EDITION)], METADATA_PROGRAM_ID))[0].toBase58();\n}\nexport async function getMetadata(tokenMint) {\n  return (await PublicKey.findProgramAddress([Buffer.from(METADATA_PREFIX), METADATA_PROGRAM_ID.toBuffer(), tokenMint.toBuffer()], METADATA_PROGRAM_ID))[0];\n}\nexport async function getNFTMetadata(metadataAccountInfo) {\n  const metadata = decodeMetadata(metadataAccountInfo.data);\n\n  try {\n    const result = await fetch(metadata.data.uri); // We might need some more care here in case the data isn't valid\n\n    const metadataExtension = await result.json();\n    return metadataExtension;\n  } catch (e) {\n    console.log(e);\n    return;\n  }\n}","map":{"version":3,"sources":["C:/Riff-Raffle-Solana-NFT build 1-1/app/src/lib/metadata/index.ts"],"names":["METADATA_PROGRAM_ID","deserializeUnchecked","PublicKey","extendBorsh","METADATA_PREFIX","EDITION","RESERVATION","MAX_NAME_LENGTH","MAX_SYMBOL_LENGTH","MAX_URI_LENGTH","MAX_CREATOR_LIMIT","MAX_CREATOR_LEN","MAX_METADATA_LEN","MAX_EDITION_LEN","EDITION_MARKER_BIT_SIZE","MetadataKey","MetadataCategory","MasterEditionV1","constructor","args","key","supply","maxSupply","printingMint","oneTimePrintingAuthorizationMint","MasterEditionV2","EditionMarker","ledger","editionTaken","edition","editionOffset","indexOffset","Math","floor","Error","positionInBitsetFromRight","mask","pow","appliedMask","Edition","parent","EditionV1","Creator","address","verified","share","Data","name","symbol","uri","sellerFeeBasisPoints","creators","Metadata","updateAuthority","mint","data","primarySaleHappened","isMutable","editionNonce","masterEdition","MetadataV1","init","getEdition","CreateMetadataArgs","instruction","UpdateMetadataArgs","CreateMasterEditionArgs","MintPrintingTokensArgs","METADATA_SCHEMA","Map","kind","fields","type","METADATA_REPLACE","RegExp","decodeMetadata","buffer","metadata","replace","tokenMint","findProgramAddress","Buffer","from","toBuffer","toBase58","getMetadata","getNFTMetadata","metadataAccountInfo","result","fetch","metadataExtension","json","e","console","log"],"mappings":"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","sourcesContent":["import { METADATA_PROGRAM_ID } from './programIds';\r\nimport { deserializeUnchecked } from 'borsh';\r\nimport BN from 'bn.js';\r\nimport { AccountInfo, Connection, PublicKey } from '@solana/web3.js';\r\nimport { StringPublicKey } from './utils';\r\nimport { extendBorsh } from './borsh';\r\nextendBorsh();\r\nexport const METADATA_PREFIX = 'metadata';\r\nexport const EDITION = 'edition';\r\nexport const RESERVATION = 'reservation';\r\n\r\nexport const MAX_NAME_LENGTH = 32;\r\n\r\nexport const MAX_SYMBOL_LENGTH = 10;\r\n\r\nexport const MAX_URI_LENGTH = 200;\r\n\r\nexport const MAX_CREATOR_LIMIT = 5;\r\n\r\nexport const MAX_CREATOR_LEN = 32 + 1 + 1;\r\nexport const MAX_METADATA_LEN =\r\n  1 +\r\n  32 +\r\n  32 +\r\n  MAX_NAME_LENGTH +\r\n  MAX_SYMBOL_LENGTH +\r\n  MAX_URI_LENGTH +\r\n  MAX_CREATOR_LIMIT * MAX_CREATOR_LEN +\r\n  2 +\r\n  1 +\r\n  1 +\r\n  198;\r\n\r\nexport const MAX_EDITION_LEN = 1 + 32 + 8 + 200;\r\n\r\nexport const EDITION_MARKER_BIT_SIZE = 248;\r\n\r\nexport enum MetadataKey {\r\n  Uninitialized = 0,\r\n  MetadataV1 = 4,\r\n  EditionV1 = 1,\r\n  MasterEditionV1 = 2,\r\n  MasterEditionV2 = 6,\r\n  EditionMarker = 7,\r\n}\r\n\r\nexport enum MetadataCategory {\r\n  Audio = 'audio',\r\n  Video = 'video',\r\n  Image = 'image',\r\n  VR = 'vr',\r\n}\r\n\r\nexport type MetadataFile = {\r\n  uri: string;\r\n  type: string;\r\n};\r\n\r\nexport type FileOrString = MetadataFile | string;\r\n\r\nexport type Attribute = {\r\n  trait_type?: string;\r\n  display_type?: string;\r\n  value: string | number;\r\n};\r\n\r\nexport interface IMetadataExtension {\r\n  name: string;\r\n  symbol: string;\r\n\r\n  creators: Creator[] | null;\r\n  description: string;\r\n  // preview image absolute URI\r\n  image: string;\r\n  animation_url?: string;\r\n\r\n  attributes?: Attribute[];\r\n\r\n  // stores link to item on meta\r\n  external_url: string;\r\n\r\n  seller_fee_basis_points: number;\r\n\r\n  properties: {\r\n    files?: FileOrString[];\r\n    category: MetadataCategory;\r\n    maxSupply?: number;\r\n    creators?: {\r\n      address: string;\r\n      shares: number;\r\n    }[];\r\n  };\r\n}\r\n\r\nexport class MasterEditionV1 {\r\n  key: MetadataKey;\r\n  supply: BN;\r\n  maxSupply?: BN;\r\n  /// Can be used to mint tokens that give one-time permission to mint a single limited edition.\r\n  printingMint: StringPublicKey;\r\n  /// If you don't know how many printing tokens you are going to need, but you do know\r\n  /// you are going to need some amount in the future, you can use a token from this mint.\r\n  /// Coming back to token metadata with one of these tokens allows you to mint (one time)\r\n  /// any number of printing tokens you want. This is used for instance by Auction Manager\r\n  /// with participation NFTs, where we dont know how many people will bid and need participation\r\n  /// printing tokens to redeem, so we give it ONE of these tokens to use after the auction is over,\r\n  /// because when the auction begins we just dont know how many printing tokens we will need,\r\n  /// but at the end we will. At the end it then burns this token with token-metadata to\r\n  /// get the printing tokens it needs to give to bidders. Each bidder then redeems a printing token\r\n  /// to get their limited editions.\r\n  oneTimePrintingAuthorizationMint: StringPublicKey;\r\n\r\n  constructor(args: {\r\n    key: MetadataKey;\r\n    supply: BN;\r\n    maxSupply?: BN;\r\n    printingMint: StringPublicKey;\r\n    oneTimePrintingAuthorizationMint: StringPublicKey;\r\n  }) {\r\n    this.key = MetadataKey.MasterEditionV1;\r\n    this.supply = args.supply;\r\n    this.maxSupply = args.maxSupply;\r\n    this.printingMint = args.printingMint;\r\n    this.oneTimePrintingAuthorizationMint =\r\n      args.oneTimePrintingAuthorizationMint;\r\n  }\r\n}\r\n\r\nexport class MasterEditionV2 {\r\n  key: MetadataKey;\r\n  supply: BN;\r\n  maxSupply?: BN;\r\n\r\n  constructor(args: { key: MetadataKey; supply: BN; maxSupply?: BN }) {\r\n    this.key = MetadataKey.MasterEditionV2;\r\n    this.supply = args.supply;\r\n    this.maxSupply = args.maxSupply;\r\n  }\r\n}\r\n\r\nexport class EditionMarker {\r\n  key: MetadataKey;\r\n  ledger: number[];\r\n\r\n  constructor(args: { key: MetadataKey; ledger: number[] }) {\r\n    this.key = MetadataKey.EditionMarker;\r\n    this.ledger = args.ledger;\r\n  }\r\n\r\n  editionTaken(edition: number) {\r\n    const editionOffset = edition % EDITION_MARKER_BIT_SIZE;\r\n    const indexOffset = Math.floor(editionOffset / 8);\r\n\r\n    if (indexOffset > 30) {\r\n      throw Error('bad index for edition');\r\n    }\r\n\r\n    const positionInBitsetFromRight = 7 - (editionOffset % 8);\r\n\r\n    const mask = Math.pow(2, positionInBitsetFromRight);\r\n\r\n    const appliedMask = this.ledger[indexOffset] & mask;\r\n\r\n    return appliedMask !== 0;\r\n  }\r\n}\r\n\r\nexport class Edition {\r\n  key: MetadataKey;\r\n  /// Points at MasterEdition struct\r\n  parent: StringPublicKey;\r\n  /// Starting at 0 for master record, this is incremented for each edition minted.\r\n  edition: BN;\r\n\r\n  constructor(args: {\r\n    key: MetadataKey;\r\n    parent: StringPublicKey;\r\n    edition: BN;\r\n  }) {\r\n    this.key = MetadataKey.EditionV1;\r\n    this.parent = args.parent;\r\n    this.edition = args.edition;\r\n  }\r\n}\r\nexport class Creator {\r\n  address: StringPublicKey;\r\n  verified: boolean;\r\n  share: number;\r\n\r\n  constructor(args: {\r\n    address: StringPublicKey;\r\n    verified: boolean;\r\n    share: number;\r\n  }) {\r\n    this.address = args.address;\r\n    this.verified = args.verified;\r\n    this.share = args.share;\r\n  }\r\n}\r\n\r\nexport class Data {\r\n  name: string;\r\n  symbol: string;\r\n  uri: string;\r\n  sellerFeeBasisPoints: number;\r\n  creators: Creator[] | null;\r\n  constructor(args: {\r\n    name: string;\r\n    symbol: string;\r\n    uri: string;\r\n    sellerFeeBasisPoints: number;\r\n    creators: Creator[] | null;\r\n  }) {\r\n    this.name = args.name;\r\n    this.symbol = args.symbol;\r\n    this.uri = args.uri;\r\n    this.sellerFeeBasisPoints = args.sellerFeeBasisPoints;\r\n    this.creators = args.creators;\r\n  }\r\n}\r\n\r\nexport class Metadata {\r\n  key: MetadataKey;\r\n  updateAuthority: StringPublicKey;\r\n  mint: StringPublicKey;\r\n  data: Data;\r\n  primarySaleHappened: boolean;\r\n  isMutable: boolean;\r\n  editionNonce: number | null;\r\n\r\n  // set lazy\r\n  masterEdition?: StringPublicKey;\r\n  edition?: StringPublicKey;\r\n\r\n  constructor(args: {\r\n    updateAuthority: StringPublicKey;\r\n    mint: StringPublicKey;\r\n    data: Data;\r\n    primarySaleHappened: boolean;\r\n    isMutable: boolean;\r\n    editionNonce: number | null;\r\n  }) {\r\n    this.key = MetadataKey.MetadataV1;\r\n    this.updateAuthority = args.updateAuthority;\r\n    this.mint = args.mint;\r\n    this.data = args.data;\r\n    this.primarySaleHappened = args.primarySaleHappened;\r\n    this.isMutable = args.isMutable;\r\n    this.editionNonce = args.editionNonce;\r\n  }\r\n\r\n  public async init() {\r\n    const edition = await getEdition(this.mint);\r\n    this.edition = edition;\r\n    this.masterEdition = edition;\r\n  }\r\n}\r\n\r\nclass CreateMetadataArgs {\r\n  instruction: number = 0;\r\n  data: Data;\r\n  isMutable: boolean;\r\n\r\n  constructor(args: { data: Data; isMutable: boolean }) {\r\n    this.data = args.data;\r\n    this.isMutable = args.isMutable;\r\n  }\r\n}\r\nclass UpdateMetadataArgs {\r\n  instruction: number = 1;\r\n  data: Data | null;\r\n  // Not used by this app, just required for instruction\r\n  updateAuthority: StringPublicKey | null;\r\n  primarySaleHappened: boolean | null;\r\n  constructor(args: {\r\n    data?: Data;\r\n    updateAuthority?: string;\r\n    primarySaleHappened: boolean | null;\r\n  }) {\r\n    this.data = args.data ? args.data : null;\r\n    this.updateAuthority = args.updateAuthority ? args.updateAuthority : null;\r\n    this.primarySaleHappened = args.primarySaleHappened;\r\n  }\r\n}\r\n\r\nclass CreateMasterEditionArgs {\r\n  instruction: number = 10;\r\n  maxSupply: BN | null;\r\n  constructor(args: { maxSupply: BN | null }) {\r\n    this.maxSupply = args.maxSupply;\r\n  }\r\n}\r\n\r\nclass MintPrintingTokensArgs {\r\n  instruction: number = 9;\r\n  supply: BN;\r\n\r\n  constructor(args: { supply: BN }) {\r\n    this.supply = args.supply;\r\n  }\r\n}\r\n\r\nexport const METADATA_SCHEMA = new Map<any, any>([\r\n  [\r\n    CreateMetadataArgs,\r\n    {\r\n      kind: 'struct',\r\n      fields: [\r\n        ['instruction', 'u8'],\r\n        ['data', Data],\r\n        ['isMutable', 'u8'], // bool\r\n      ],\r\n    },\r\n  ],\r\n  [\r\n    UpdateMetadataArgs,\r\n    {\r\n      kind: 'struct',\r\n      fields: [\r\n        ['instruction', 'u8'],\r\n        ['data', { kind: 'option', type: Data }],\r\n        ['updateAuthority', { kind: 'option', type: 'pubkeyAsString' }],\r\n        ['primarySaleHappened', { kind: 'option', type: 'u8' }],\r\n      ],\r\n    },\r\n  ],\r\n\r\n  [\r\n    CreateMasterEditionArgs,\r\n    {\r\n      kind: 'struct',\r\n      fields: [\r\n        ['instruction', 'u8'],\r\n        ['maxSupply', { kind: 'option', type: 'u64' }],\r\n      ],\r\n    },\r\n  ],\r\n  [\r\n    MintPrintingTokensArgs,\r\n    {\r\n      kind: 'struct',\r\n      fields: [\r\n        ['instruction', 'u8'],\r\n        ['supply', 'u64'],\r\n      ],\r\n    },\r\n  ],\r\n  [\r\n    MasterEditionV1,\r\n    {\r\n      kind: 'struct',\r\n      fields: [\r\n        ['key', 'u8'],\r\n        ['supply', 'u64'],\r\n        ['maxSupply', { kind: 'option', type: 'u64' }],\r\n        ['printingMint', 'pubkeyAsString'],\r\n        ['oneTimePrintingAuthorizationMint', 'pubkeyAsString'],\r\n      ],\r\n    },\r\n  ],\r\n  [\r\n    MasterEditionV2,\r\n    {\r\n      kind: 'struct',\r\n      fields: [\r\n        ['key', 'u8'],\r\n        ['supply', 'u64'],\r\n        ['maxSupply', { kind: 'option', type: 'u64' }],\r\n      ],\r\n    },\r\n  ],\r\n  [\r\n    Edition,\r\n    {\r\n      kind: 'struct',\r\n      fields: [\r\n        ['key', 'u8'],\r\n        ['parent', 'pubkeyAsString'],\r\n        ['edition', 'u64'],\r\n      ],\r\n    },\r\n  ],\r\n  [\r\n    Data,\r\n    {\r\n      kind: 'struct',\r\n      fields: [\r\n        ['name', 'string'],\r\n        ['symbol', 'string'],\r\n        ['uri', 'string'],\r\n        ['sellerFeeBasisPoints', 'u16'],\r\n        ['creators', { kind: 'option', type: [Creator] }],\r\n      ],\r\n    },\r\n  ],\r\n  [\r\n    Creator,\r\n    {\r\n      kind: 'struct',\r\n      fields: [\r\n        ['address', 'pubkeyAsString'],\r\n        ['verified', 'u8'],\r\n        ['share', 'u8'],\r\n      ],\r\n    },\r\n  ],\r\n  [\r\n    Metadata,\r\n    {\r\n      kind: 'struct',\r\n      fields: [\r\n        ['key', 'u8'],\r\n        ['updateAuthority', 'pubkeyAsString'],\r\n        ['mint', 'pubkeyAsString'],\r\n        ['data', Data],\r\n        ['primarySaleHappened', 'u8'], // bool\r\n        ['isMutable', 'u8'], // bool\r\n      ],\r\n    },\r\n  ],\r\n  [\r\n    EditionMarker,\r\n    {\r\n      kind: 'struct',\r\n      fields: [\r\n        ['key', 'u8'],\r\n        ['ledger', [31]],\r\n      ],\r\n    },\r\n  ],\r\n]);\r\n\r\n// eslint-disable-next-line no-control-regex\r\nconst METADATA_REPLACE = new RegExp('\\u0000', 'g');\r\n\r\nexport const decodeMetadata = (buffer: Buffer): Metadata => {\r\n  const metadata = deserializeUnchecked(\r\n    METADATA_SCHEMA,\r\n    Metadata,\r\n    buffer\r\n  ) as Metadata;\r\n  metadata.data.name = metadata.data.name.replace(METADATA_REPLACE, '');\r\n  metadata.data.uri = metadata.data.uri.replace(METADATA_REPLACE, '');\r\n  metadata.data.symbol = metadata.data.symbol.replace(METADATA_REPLACE, '');\r\n  return metadata;\r\n};\r\n\r\nexport async function getEdition(\r\n  tokenMint: StringPublicKey\r\n): Promise<StringPublicKey> {\r\n  return (\r\n    await PublicKey.findProgramAddress(\r\n      [\r\n        Buffer.from(METADATA_PREFIX),\r\n        METADATA_PROGRAM_ID.toBuffer(),\r\n        new PublicKey(tokenMint).toBuffer(),\r\n        Buffer.from(EDITION),\r\n      ],\r\n      METADATA_PROGRAM_ID\r\n    )\r\n  )[0].toBase58();\r\n}\r\n\r\nexport async function getMetadata(tokenMint: PublicKey): Promise<PublicKey> {\r\n  return (\r\n    await PublicKey.findProgramAddress(\r\n      [\r\n        Buffer.from(METADATA_PREFIX),\r\n        METADATA_PROGRAM_ID.toBuffer(),\r\n        tokenMint.toBuffer(),\r\n      ],\r\n      METADATA_PROGRAM_ID\r\n    )\r\n  )[0];\r\n}\r\n\r\nexport async function getNFTMetadata(\r\n  metadataAccountInfo: AccountInfo<Buffer>,\r\n): Promise<IMetadataExtension | undefined> {\r\n  const metadata = decodeMetadata(metadataAccountInfo.data);\r\n\r\n  try {\r\n    const result = await fetch(metadata.data.uri);\r\n    // We might need some more care here in case the data isn't valid\r\n    const metadataExtension = (await result.json()) as IMetadataExtension;\r\n    return metadataExtension;\r\n  } catch (e) {\r\n    console.log(e);\r\n    return;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}