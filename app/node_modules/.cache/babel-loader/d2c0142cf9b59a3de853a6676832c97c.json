{"ast":null,"code":"import { Provider } from '@project-serum/anchor';\nimport toast from 'react-hot-toast';\nimport { sleep } from './utils';\nexport class StubWallet {\n  constructor() {\n    this.publicKey = undefined;\n  }\n\n  async signTransaction(tx) {\n    return tx;\n  }\n\n  async signAllTransactions(txs) {\n    return txs;\n  } // Hack so that the stub is not recognised as a connected user down the track\n\n\n}\nexport const customProviderFactory = (connection, anchorWallet) => {\n  const provider = new Provider(connection, anchorWallet || new StubWallet(), {}); // No websocket sender with tx confirmation awaiting\n\n  provider.send = async (tx, signers, opts) => {\n    if (signers === undefined) {\n      signers = [];\n    }\n\n    tx.feePayer = anchorWallet === null || anchorWallet === void 0 ? void 0 : anchorWallet.publicKey;\n    tx.recentBlockhash = (await connection.getRecentBlockhash()).blockhash;\n    await (anchorWallet === null || anchorWallet === void 0 ? void 0 : anchorWallet.signTransaction(tx));\n    signers.filter(s => s !== undefined).forEach(kp => {\n      tx.partialSign(kp);\n    });\n    const rawTx = tx.serialize();\n    const signature = await connection.sendRawTransaction(rawTx); // Await for 30 seconds\n\n    for (let i = 0; i < 30; i++) {\n      const signatureStatus = (await connection.getSignatureStatus(signature)).value;\n\n      if ((signatureStatus === null || signatureStatus === void 0 ? void 0 : signatureStatus.confirmationStatus) === 'confirmed') {\n        break;\n      }\n\n      await sleep(1000);\n    }\n\n    return signature;\n  };\n\n  return provider;\n}; // Allows generic wrapping of rpc calls to elevate success and errors to the user\n\nexport const txHandler = async (rpcFc, successMessage) => {\n  try {\n    const signature = await rpcFc();\n    console.log('Success:', signature);\n    toast.success(successMessage);\n    return true;\n  } catch (error) {\n    console.log(error);\n\n    if (error.msg) {\n      toast.error(`Transaction failed: ${error.msg}`);\n    } else {\n      toast.error('Unexpected error');\n    }\n\n    return false;\n  }\n};","map":{"version":3,"sources":["C:/Users/kroni/Desktop/RIFF RAFFLE SITE PNSC/Riff-Raffle-Solana-NFT/app/src/lib/anchorUtils.ts"],"names":["Provider","toast","sleep","StubWallet","publicKey","undefined","signTransaction","tx","signAllTransactions","txs","customProviderFactory","connection","anchorWallet","provider","send","signers","opts","feePayer","recentBlockhash","getRecentBlockhash","blockhash","filter","s","forEach","kp","partialSign","rawTx","serialize","signature","sendRawTransaction","i","signatureStatus","getSignatureStatus","value","confirmationStatus","txHandler","rpcFc","successMessage","console","log","success","error","msg"],"mappings":"AAAA,SAASA,QAAT,QAAyB,uBAAzB;AAUA,OAAOC,KAAP,MAAkB,iBAAlB;AACA,SAASC,KAAT,QAAsB,SAAtB;AAEA,OAAO,MAAMC,UAAN,CAAiB;AAAA;AAAA,SAOtBC,SAPsB,GAOCC,SAPD;AAAA;;AACD,QAAfC,eAAe,CAACC,EAAD,EAAwC;AAC3D,WAAOA,EAAP;AACD;;AACwB,QAAnBC,mBAAmB,CAACC,GAAD,EAA6C;AACpE,WAAOA,GAAP;AACD,GANqB,CAOoC;;;AAPpC;AAUxB,OAAO,MAAMC,qBAAqB,GAAG,CACnCC,UADmC,EAEnCC,YAFmC,KAGtB;AACb,QAAMC,QAAQ,GAAG,IAAIb,QAAJ,CACfW,UADe,EAEfC,YAAY,IAAI,IAAIT,UAAJ,EAFD,EAGf,EAHe,CAAjB,CADa,CAOb;;AACAU,EAAAA,QAAQ,CAACC,IAAT,GAAgB,OACdP,EADc,EAEdQ,OAFc,EAGdC,IAHc,KAIoB;AAClC,QAAID,OAAO,KAAKV,SAAhB,EAA2B;AACzBU,MAAAA,OAAO,GAAG,EAAV;AACD;;AAEDR,IAAAA,EAAE,CAACU,QAAH,GAAcL,YAAd,aAAcA,YAAd,uBAAcA,YAAY,CAAER,SAA5B;AACAG,IAAAA,EAAE,CAACW,eAAH,GAAqB,CAAC,MAAMP,UAAU,CAACQ,kBAAX,EAAP,EAAwCC,SAA7D;AAEA,WAAMR,YAAN,aAAMA,YAAN,uBAAMA,YAAY,CAAEN,eAAd,CAA8BC,EAA9B,CAAN;AACAQ,IAAAA,OAAO,CACJM,MADH,CACWC,CAAD,IAAoBA,CAAC,KAAKjB,SADpC,EAEGkB,OAFH,CAEYC,EAAD,IAAQ;AACfjB,MAAAA,EAAE,CAACkB,WAAH,CAAeD,EAAf;AACD,KAJH;AAMA,UAAME,KAAK,GAAGnB,EAAE,CAACoB,SAAH,EAAd;AACA,UAAMC,SAAS,GAAG,MAAMjB,UAAU,CAACkB,kBAAX,CAA8BH,KAA9B,CAAxB,CAhBkC,CAkBlC;;AACA,SAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,EAApB,EAAwBA,CAAC,EAAzB,EAA6B;AAC3B,YAAMC,eAAe,GAAG,CAAC,MAAMpB,UAAU,CAACqB,kBAAX,CAA8BJ,SAA9B,CAAP,EACrBK,KADH;;AAEA,UAAI,CAAAF,eAAe,SAAf,IAAAA,eAAe,WAAf,YAAAA,eAAe,CAAEG,kBAAjB,MAAwC,WAA5C,EAAyD;AACvD;AACD;;AACD,YAAMhC,KAAK,CAAC,IAAD,CAAX;AACD;;AACD,WAAO0B,SAAP;AACD,GAhCD;;AAkCA,SAAOf,QAAP;AACD,CA9CM,C,CAgDP;;AACA,OAAO,MAAMsB,SAAS,GAAG,OACvBC,KADuB,EAEvBC,cAFuB,KAGpB;AACH,MAAI;AACF,UAAMT,SAAS,GAAG,MAAMQ,KAAK,EAA7B;AACAE,IAAAA,OAAO,CAACC,GAAR,CAAY,UAAZ,EAAwBX,SAAxB;AACA3B,IAAAA,KAAK,CAACuC,OAAN,CAAcH,cAAd;AACA,WAAO,IAAP;AACD,GALD,CAKE,OAAOI,KAAP,EAAmB;AACnBH,IAAAA,OAAO,CAACC,GAAR,CAAYE,KAAZ;;AACA,QAAIA,KAAK,CAACC,GAAV,EAAe;AACbzC,MAAAA,KAAK,CAACwC,KAAN,CAAa,uBAAsBA,KAAK,CAACC,GAAI,EAA7C;AACD,KAFD,MAEO;AACLzC,MAAAA,KAAK,CAACwC,KAAN,CAAY,kBAAZ;AACD;;AACD,WAAO,KAAP;AACD;AACF,CAlBM","sourcesContent":["import { Provider } from '@project-serum/anchor';\r\nimport { AnchorWallet } from '@solana/wallet-adapter-react';\r\nimport {\r\n  ConfirmOptions,\r\n  Connection,\r\n  PublicKey,\r\n  Signer,\r\n  Transaction,\r\n  TransactionSignature,\r\n} from '@solana/web3.js';\r\nimport toast from 'react-hot-toast';\r\nimport { sleep } from './utils';\r\n\r\nexport class StubWallet {\r\n  async signTransaction(tx: Transaction): Promise<Transaction> {\r\n    return tx;\r\n  }\r\n  async signAllTransactions(txs: Transaction[]): Promise<Transaction[]> {\r\n    return txs;\r\n  }\r\n  publicKey: PublicKey = undefined as unknown as PublicKey; // Hack so that the stub is not recognised as a connected user down the track\r\n}\r\n\r\nexport const customProviderFactory = (\r\n  connection: Connection,\r\n  anchorWallet: AnchorWallet | undefined\r\n): Provider => {\r\n  const provider = new Provider(\r\n    connection,\r\n    anchorWallet || new StubWallet(),\r\n    {}\r\n  );\r\n\r\n  // No websocket sender with tx confirmation awaiting\r\n  provider.send = async (\r\n    tx: Transaction,\r\n    signers?: Array<Signer | undefined>,\r\n    opts?: ConfirmOptions\r\n  ): Promise<TransactionSignature> => {\r\n    if (signers === undefined) {\r\n      signers = [];\r\n    }\r\n\r\n    tx.feePayer = anchorWallet?.publicKey;\r\n    tx.recentBlockhash = (await connection.getRecentBlockhash()).blockhash;\r\n\r\n    await anchorWallet?.signTransaction(tx);\r\n    signers\r\n      .filter((s): s is Signer => s !== undefined)\r\n      .forEach((kp) => {\r\n        tx.partialSign(kp);\r\n      });\r\n\r\n    const rawTx = tx.serialize();\r\n    const signature = await connection.sendRawTransaction(rawTx);\r\n\r\n    // Await for 30 seconds\r\n    for (let i = 0; i < 30; i++) {\r\n      const signatureStatus = (await connection.getSignatureStatus(signature))\r\n        .value;\r\n      if (signatureStatus?.confirmationStatus === 'confirmed') {\r\n        break;\r\n      }\r\n      await sleep(1000);\r\n    }\r\n    return signature;\r\n  };\r\n\r\n  return provider;\r\n};\r\n\r\n// Allows generic wrapping of rpc calls to elevate success and errors to the user\r\nexport const txHandler = async (\r\n  rpcFc: () => Promise<TransactionSignature>,\r\n  successMessage: string\r\n) => {\r\n  try {\r\n    const signature = await rpcFc();\r\n    console.log('Success:', signature);\r\n    toast.success(successMessage);\r\n    return true;\r\n  } catch (error: any) {\r\n    console.log(error);\r\n    if (error.msg) {\r\n      toast.error(`Transaction failed: ${error.msg}`);\r\n    } else {\r\n      toast.error('Unexpected error');\r\n    }\r\n    return false;\r\n  }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}