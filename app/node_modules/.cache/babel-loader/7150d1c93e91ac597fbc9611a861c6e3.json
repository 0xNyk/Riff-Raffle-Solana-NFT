{"ast":null,"code":"import _regeneratorRuntime from\"C:/Users/kroni/Desktop/RIFF RAFFLE SITE PNSC/Riff-Raffle-Solana-NFT/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"C:/Users/kroni/Desktop/RIFF RAFFLE SITE PNSC/Riff-Raffle-Solana-NFT/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{ASSOCIATED_TOKEN_PROGRAM_ID,Token,TOKEN_PROGRAM_ID}from'@solana/spl-token';import{PublicKey,SystemProgram,Transaction}from'@solana/web3.js';import{VAULT_TOKEN_IN,VAULT_TOKEN_OUT}from'../../config/accounts';import{DISPENSER_REGISTRY_ADDRESS}from'../../config/programIds';import{wrappedSOL}from'../../config/tokenRegistry';import{createOwnAssociatedTokenAccountInstruction}from'../accounts';export var BUY_TICKETS_TX_FEE_LAMPORTS=5;var FEE_WALLET=new PublicKey('pERajv8kgvHcPC6Wah6AoawqBMk6sWYc3BEQovMJAwV');export var calculateBasketPrice=function calculateBasketPrice(ticketPrice,ticketAmount,paymentOption){return ticketPrice.muln(ticketAmount).mul(paymentOption.dispenserPriceIn).div(paymentOption.dispenserPriceOut);};export var buyTickets=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(draffleClient,dispenserClient,raffle,ticketAmount,paymentOption,buyerATAExists){var _Transaction;var buyerTokenAccount,finalBuyerAccount,instructions,basketPrice,buyerIntermediaryTokenAccount;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID,TOKEN_PROGRAM_ID,paymentOption.mint.publicKey,draffleClient.provider.wallet.publicKey);case 2:buyerTokenAccount=_context.sent;finalBuyerAccount=buyerTokenAccount;instructions=[];// Required for wSOL payment only because the associated amount is read from native lamports\n// In other cases user cannot click \"BUY\" if no ATA (= not enough to buy), and won't hit `buyTicket`\nif(paymentOption.mint.publicKey.toBase58()===wrappedSOL){if(!buyerATAExists){instructions.push(createOwnAssociatedTokenAccountInstruction(new PublicKey(wrappedSOL),buyerTokenAccount,draffleClient.provider.wallet.publicKey));}instructions.push(SystemProgram.transfer({fromPubkey:draffleClient.provider.wallet.publicKey,toPubkey:buyerTokenAccount,lamports:calculateBasketPrice(raffle.proceeds.ticketPrice,ticketAmount,paymentOption).toNumber()}));instructions.push(// @ts-ignore\nToken.createSyncNativeInstruction(TOKEN_PROGRAM_ID,buyerTokenAccount));}// Get raffle proceeds token from dispenser if needed\nif(!(paymentOption.mint.publicKey.toString()!==raffle.proceeds.mint.publicKey.toString())){_context.next=14;break;}basketPrice=calculateBasketPrice(raffle.proceeds.ticketPrice,ticketAmount,paymentOption);console.log(\"Swapping \".concat(basketPrice.toString(),\" \").concat(paymentOption.mint.symbol,\" for \").concat(raffle.proceeds.ticketPrice.muln(ticketAmount).toString(),\" \").concat(raffle.proceeds.mint.symbol));_context.next=11;return Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID,TOKEN_PROGRAM_ID,raffle.proceeds.mint.publicKey,draffleClient.provider.wallet.publicKey);case 11:buyerIntermediaryTokenAccount=_context.sent;// Safe amount requested, because only multiplied.\n// Together with program-side logic, only consequence of potentially non-integer\n// associated tokenIn amount is under-charging the user by remainder amount\ninstructions.push(dispenserClient.instruction.swap(raffle.proceeds.ticketPrice.muln(ticketAmount),{accounts:{registry:DISPENSER_REGISTRY_ADDRESS,swapper:dispenserClient.provider.wallet.publicKey,vaultTokenIn:VAULT_TOKEN_IN,vaultTokenOut:VAULT_TOKEN_OUT,buyerTokenInAccount:buyerTokenAccount,buyerTokenOutAccount:buyerIntermediaryTokenAccount,tokenProgram:TOKEN_PROGRAM_ID}}));finalBuyerAccount=buyerIntermediaryTokenAccount;case 14:// LOOK HERE\ninstructions.push(draffleClient.instruction.buyTickets(ticketAmount,{accounts:{raffle:raffle.publicKey,entrants:raffle.entrantsAccountAddress,proceeds:raffle.proceeds.address,buyerTokenAccount:finalBuyerAccount,buyerTransferAuthority:draffleClient.provider.wallet.publicKey,tokenProgram:TOKEN_PROGRAM_ID,systemProgram:SystemProgram.programId,feeAcc:FEE_WALLET}}));_context.next=17;return draffleClient.provider.send((_Transaction=new Transaction()).add.apply(_Transaction,instructions));case 17:return _context.abrupt(\"return\",_context.sent);case 18:case\"end\":return _context.stop();}}},_callee);}));return function buyTickets(_x,_x2,_x3,_x4,_x5,_x6){return _ref.apply(this,arguments);};}();","map":null,"metadata":{},"sourceType":"module"}