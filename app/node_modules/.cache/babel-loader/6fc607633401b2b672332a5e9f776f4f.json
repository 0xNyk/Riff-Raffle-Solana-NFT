{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId]) {\n      /******/\n      return installedModules[moduleId].exports;\n      /******/\n    }\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n\n    var module = installedModules[moduleId] = {\n      /******/\n      i: moduleId,\n\n      /******/\n      l: false,\n\n      /******/\n      exports: {}\n      /******/\n\n    };\n    /******/\n\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.l = true;\n    /******/\n\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n\n  /******/\n\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n\n  /******/\n  // define getter function for harmony exports\n\n  /******/\n\n  __webpack_require__.d = function (exports, name, getter) {\n    /******/\n    if (!__webpack_require__.o(exports, name)) {\n      /******/\n      Object.defineProperty(exports, name, {\n        enumerable: true,\n        get: getter\n      });\n      /******/\n    }\n    /******/\n\n  };\n  /******/\n\n  /******/\n  // define __esModule on exports\n\n  /******/\n\n\n  __webpack_require__.r = function (exports) {\n    /******/\n    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n      /******/\n      Object.defineProperty(exports, Symbol.toStringTag, {\n        value: 'Module'\n      });\n      /******/\n    }\n    /******/\n\n\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n    /******/\n  };\n  /******/\n\n  /******/\n  // create a fake namespace object\n\n  /******/\n  // mode & 1: value is a module id, require it\n\n  /******/\n  // mode & 2: merge all properties of value into the ns\n\n  /******/\n  // mode & 4: return value when already ns object\n\n  /******/\n  // mode & 8|1: behave like require\n\n  /******/\n\n\n  __webpack_require__.t = function (value, mode) {\n    /******/\n    if (mode & 1) value = __webpack_require__(value);\n    /******/\n\n    if (mode & 8) return value;\n    /******/\n\n    if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;\n    /******/\n\n    var ns = Object.create(null);\n    /******/\n\n    __webpack_require__.r(ns);\n    /******/\n\n\n    Object.defineProperty(ns, 'default', {\n      enumerable: true,\n      value: value\n    });\n    /******/\n\n    if (mode & 2 && typeof value != 'string') for (var key in value) {\n      __webpack_require__.d(ns, key, function (key) {\n        return value[key];\n      }.bind(null, key));\n    }\n    /******/\n\n    return ns;\n    /******/\n  };\n  /******/\n\n  /******/\n  // getDefaultExport function for compatibility with non-harmony modules\n\n  /******/\n\n\n  __webpack_require__.n = function (module) {\n    /******/\n    var getter = module && module.__esModule ?\n    /******/\n    function getDefault() {\n      return module['default'];\n    } :\n    /******/\n    function getModuleExports() {\n      return module;\n    };\n    /******/\n\n    __webpack_require__.d(getter, 'a', getter);\n    /******/\n\n\n    return getter;\n    /******/\n  };\n  /******/\n\n  /******/\n  // Object.prototype.hasOwnProperty.call\n\n  /******/\n\n\n  __webpack_require__.o = function (object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n  };\n  /******/\n\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n\n  __webpack_require__.p = \"\";\n  /******/\n\n  /******/\n\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(__webpack_require__.s = 43);\n  /******/\n}(\n/************************************************************************/\n\n/******/\n[\n/* 0 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime/helpers/defineProperty\");\n  /***/\n},\n/* 1 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime/regenerator\");\n  /***/\n},\n/* 2 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime/helpers/assertThisInitialized\");\n  /***/\n},\n/* 3 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime/helpers/getPrototypeOf\");\n  /***/\n},\n/* 4 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime/helpers/classCallCheck\");\n  /***/\n},\n/* 5 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime/helpers/createClass\");\n  /***/\n},\n/* 6 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime/helpers/inherits\");\n  /***/\n},\n/* 7 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\n  /***/\n},\n/* 8 */\n\n/***/\nfunction (module, __webpack_exports__, __webpack_require__) {\n  \"use strict\";\n  /* harmony export (binding) */\n\n  __webpack_require__.d(__webpack_exports__, \"a\", function () {\n    return SerializableError;\n  });\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(39);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_6__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(0);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__);\n  /* harmony import */\n\n\n  var fast_safe_stringify__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(40);\n  /* harmony import */\n\n\n  var fast_safe_stringify__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(fast_safe_stringify__WEBPACK_IMPORTED_MODULE_8__);\n\n  function _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n    return function _createSuperInternal() {\n      var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(Derived),\n          result;\n\n      if (hasNativeReflectConstruct) {\n        var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(this).constructor;\n\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n\n      return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default()(this, result);\n    };\n  }\n\n  function _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  var SerializableError = /*#__PURE__*/function (_Error) {\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default()(SerializableError, _Error);\n\n    var _super = _createSuper(SerializableError);\n\n    function SerializableError(_ref) {\n      var _this;\n\n      var code = _ref.code,\n          message = _ref.message,\n          data = _ref.data;\n\n      _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, SerializableError);\n\n      if (!Number.isInteger(code)) {\n        throw new Error(\"code must be an integer\");\n      }\n\n      if (!message || typeof message !== \"string\") {\n        throw new Error(\"message must be string\");\n      }\n\n      _this = _super.call(this, message);\n\n      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2___default()(_this), \"code\", void 0);\n\n      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2___default()(_this), \"data\", void 0);\n\n      _this.code = code;\n\n      if (data !== undefined) {\n        _this.data = data;\n      }\n\n      return _this;\n    }\n\n    _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(SerializableError, [{\n      key: \"toString\",\n      value: function toString() {\n        return fast_safe_stringify__WEBPACK_IMPORTED_MODULE_8___default()({\n          code: this.code,\n          message: this.message,\n          data: this.data,\n          stack: this.stack\n        });\n      }\n    }]);\n\n    return SerializableError;\n  }( /*#__PURE__*/_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_6___default()(Error));\n  /***/\n\n},\n/* 9 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime/helpers/asyncToGenerator\");\n  /***/\n},\n/* 10 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  // Copyright Joyent, Inc. and other Node contributors.\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a\n  // copy of this software and associated documentation files (the\n  // \"Software\"), to deal in the Software without restriction, including\n  // without limitation the rights to use, copy, modify, merge, publish,\n  // distribute, sublicense, and/or sell copies of the Software, and to permit\n  // persons to whom the Software is furnished to do so, subject to the\n  // following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included\n  // in all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n  // USE OR OTHER DEALINGS IN THE SOFTWARE.\n  module.exports = Stream;\n\n  var EE = __webpack_require__(17).EventEmitter;\n\n  var inherits = __webpack_require__(12);\n\n  inherits(Stream, EE);\n  Stream.Readable = __webpack_require__(23);\n  Stream.Writable = __webpack_require__(54);\n  Stream.Duplex = __webpack_require__(55);\n  Stream.Transform = __webpack_require__(56);\n  Stream.PassThrough = __webpack_require__(57); // Backwards-compat with node 0.4.x\n\n  Stream.Stream = Stream; // old-style streams.  Note that the pipe method (the only relevant\n  // part of this class) is overridden in the Readable class.\n\n  function Stream() {\n    EE.call(this);\n  }\n\n  Stream.prototype.pipe = function (dest, options) {\n    var source = this;\n\n    function ondata(chunk) {\n      if (dest.writable) {\n        if (false === dest.write(chunk) && source.pause) {\n          source.pause();\n        }\n      }\n    }\n\n    source.on('data', ondata);\n\n    function ondrain() {\n      if (source.readable && source.resume) {\n        source.resume();\n      }\n    }\n\n    dest.on('drain', ondrain); // If the 'end' option is not supplied, dest.end() will be called when\n    // source gets the 'end' or 'close' events.  Only dest.end() once.\n\n    if (!dest._isStdio && (!options || options.end !== false)) {\n      source.on('end', onend);\n      source.on('close', onclose);\n    }\n\n    var didOnEnd = false;\n\n    function onend() {\n      if (didOnEnd) return;\n      didOnEnd = true;\n      dest.end();\n    }\n\n    function onclose() {\n      if (didOnEnd) return;\n      didOnEnd = true;\n      if (typeof dest.destroy === 'function') dest.destroy();\n    } // don't leave dangling pipes when there are errors.\n\n\n    function onerror(er) {\n      cleanup();\n\n      if (EE.listenerCount(this, 'error') === 0) {\n        throw er; // Unhandled stream error in pipe.\n      }\n    }\n\n    source.on('error', onerror);\n    dest.on('error', onerror); // remove all the event listeners that were added.\n\n    function cleanup() {\n      source.removeListener('data', ondata);\n      dest.removeListener('drain', ondrain);\n      source.removeListener('end', onend);\n      source.removeListener('close', onclose);\n      source.removeListener('error', onerror);\n      dest.removeListener('error', onerror);\n      source.removeListener('end', cleanup);\n      source.removeListener('close', cleanup);\n      dest.removeListener('close', cleanup);\n    }\n\n    source.on('end', cleanup);\n    source.on('close', cleanup);\n    dest.on('close', cleanup);\n    dest.emit('pipe', source); // Allow for unix-like usage: A.pipe(B).pipe(C)\n\n    return dest;\n  };\n  /***/\n\n},\n/* 11 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\"; // Copyright Joyent, Inc. and other Node contributors.\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a\n  // copy of this software and associated documentation files (the\n  // \"Software\"), to deal in the Software without restriction, including\n  // without limitation the rights to use, copy, modify, merge, publish,\n  // distribute, sublicense, and/or sell copies of the Software, and to permit\n  // persons to whom the Software is furnished to do so, subject to the\n  // following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included\n  // in all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n  // USE OR OTHER DEALINGS IN THE SOFTWARE.\n  // a duplex stream is just a stream that is both readable and writable.\n  // Since JS doesn't have multiple prototypal inheritance, this class\n  // prototypally inherits from Readable, and then parasitically from\n  // Writable.\n\n  /*<replacement>*/\n\n  var pna = __webpack_require__(20);\n  /*</replacement>*/\n\n  /*<replacement>*/\n\n\n  var objectKeys = Object.keys || function (obj) {\n    var keys = [];\n\n    for (var key in obj) {\n      keys.push(key);\n    }\n\n    return keys;\n  };\n  /*</replacement>*/\n\n\n  module.exports = Duplex;\n  /*<replacement>*/\n\n  var util = Object.create(__webpack_require__(16));\n  util.inherits = __webpack_require__(12);\n  /*</replacement>*/\n\n  var Readable = __webpack_require__(27);\n\n  var Writable = __webpack_require__(25);\n\n  util.inherits(Duplex, Readable);\n  {\n    // avoid scope creep, the keys array can then be collected\n    var keys = objectKeys(Writable.prototype);\n\n    for (var v = 0; v < keys.length; v++) {\n      var method = keys[v];\n      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n    }\n  }\n\n  function Duplex(options) {\n    if (!(this instanceof Duplex)) return new Duplex(options);\n    Readable.call(this, options);\n    Writable.call(this, options);\n    if (options && options.readable === false) this.readable = false;\n    if (options && options.writable === false) this.writable = false;\n    this.allowHalfOpen = true;\n    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n    this.once('end', onend);\n  }\n\n  Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n    // making it explicit this property is not enumerable\n    // because otherwise some prototype manipulation in\n    // userland will fail\n    enumerable: false,\n    get: function get() {\n      return this._writableState.highWaterMark;\n    }\n  }); // the no-half-open enforcer\n\n  function onend() {\n    // if we allow half-open state, or if the writable side ended,\n    // then we're ok.\n    if (this.allowHalfOpen || this._writableState.ended) return; // no more data can be written.\n    // But allow more writes to happen in this tick.\n\n    pna.nextTick(onEndNT, this);\n  }\n\n  function onEndNT(self) {\n    self.end();\n  }\n\n  Object.defineProperty(Duplex.prototype, 'destroyed', {\n    get: function get() {\n      if (this._readableState === undefined || this._writableState === undefined) {\n        return false;\n      }\n\n      return this._readableState.destroyed && this._writableState.destroyed;\n    },\n    set: function set(value) {\n      // we ignore the value if the stream\n      // has not been initialized yet\n      if (this._readableState === undefined || this._writableState === undefined) {\n        return;\n      } // backward compatibility, the user is explicitly\n      // managing destroyed\n\n\n      this._readableState.destroyed = value;\n      this._writableState.destroyed = value;\n    }\n  });\n\n  Duplex.prototype._destroy = function (err, cb) {\n    this.push(null);\n    this.end();\n    pna.nextTick(cb, err);\n  };\n  /***/\n\n},\n/* 12 */\n\n/***/\nfunction (module, exports) {\n  if (typeof Object.create === 'function') {\n    // implementation from standard node.js 'util' module\n    module.exports = function inherits(ctor, superCtor) {\n      if (superCtor) {\n        ctor.super_ = superCtor;\n        ctor.prototype = Object.create(superCtor.prototype, {\n          constructor: {\n            value: ctor,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n      }\n    };\n  } else {\n    // old school shim for old browsers\n    module.exports = function inherits(ctor, superCtor) {\n      if (superCtor) {\n        ctor.super_ = superCtor;\n\n        var TempCtor = function TempCtor() {};\n\n        TempCtor.prototype = superCtor.prototype;\n        ctor.prototype = new TempCtor();\n        ctor.prototype.constructor = ctor;\n      }\n    };\n  }\n  /***/\n\n},\n/* 13 */\n\n/***/\nfunction (module, exports) {\n  var g; // This works in non-strict mode\n\n  g = function () {\n    return this;\n  }();\n\n  try {\n    // This works if eval is allowed (see CSP)\n    g = g || new Function(\"return this\")();\n  } catch (e) {\n    // This works if the window reference is available\n    if (typeof window === \"object\") g = window;\n  } // g can still be undefined, but nothing to do about it...\n  // We return undefined, instead of nothing here, so it's\n  // easier to handle this case. if(!global) { ...}\n\n\n  module.exports = g;\n  /***/\n},\n/* 14 */\n\n/***/\nfunction (module, __webpack_exports__, __webpack_require__) {\n  \"use strict\";\n  /* harmony export (binding) */\n\n  __webpack_require__.d(__webpack_exports__, \"a\", function () {\n    return SafeEventEmitter;\n  });\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__);\n  /* harmony import */\n\n\n  var events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(17);\n  /* harmony import */\n\n\n  var events__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_5__);\n\n  function _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n    return function _createSuperInternal() {\n      var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(Derived),\n          result;\n\n      if (hasNativeReflectConstruct) {\n        var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(this).constructor;\n\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n\n      return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default()(this, result);\n    };\n  }\n\n  function _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function safeApply(handler, context, args) {\n    try {\n      Reflect.apply(handler, context, args);\n    } catch (err) {\n      // Throw error after timeout so as not to interrupt the stack\n      setTimeout(function () {\n        throw err;\n      });\n    }\n  }\n\n  function arrayClone(arr) {\n    var n = arr.length;\n    var copy = new Array(n);\n\n    for (var i = 0; i < n; i += 1) {\n      copy[i] = arr[i];\n    }\n\n    return copy;\n  }\n\n  var SafeEventEmitter = /*#__PURE__*/function (_EventEmitter) {\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default()(SafeEventEmitter, _EventEmitter);\n\n    var _super = _createSuper(SafeEventEmitter);\n\n    function SafeEventEmitter() {\n      _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, SafeEventEmitter);\n\n      return _super.apply(this, arguments);\n    }\n\n    _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(SafeEventEmitter, [{\n      key: \"emit\",\n      value: function emit(type) {\n        var doError = type === \"error\";\n        var events = this._events;\n\n        if (events !== undefined) {\n          doError = doError && events.error === undefined;\n        } else if (!doError) {\n          return false;\n        } // If there is no 'error' event listener then throw.\n\n\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        if (doError) {\n          var er;\n\n          if (args.length > 0) {\n            er = args[0];\n          }\n\n          if (er instanceof Error) {\n            // Note: The comments on the `throw` lines are intentional, they show\n            // up in Node's output if this results in an unhandled exception.\n            throw er; // Unhandled 'error' event\n          } // At least give some kind of context to the user\n\n\n          var err = new Error(\"Unhandled error.\".concat(er ? \" (\".concat(er.message, \")\") : \"\"));\n          err.context = er;\n          throw err; // Unhandled 'error' event\n        }\n\n        var handler = events[type];\n\n        if (handler === undefined) {\n          return false;\n        }\n\n        if (typeof handler === \"function\") {\n          safeApply(handler, this, args);\n        } else {\n          var len = handler.length;\n          var listeners = arrayClone(handler);\n\n          for (var i = 0; i < len; i += 1) {\n            safeApply(listeners[i], this, args);\n          }\n        }\n\n        return true;\n      }\n    }]);\n\n    return SafeEventEmitter;\n  }(events__WEBPACK_IMPORTED_MODULE_5__[\"EventEmitter\"]);\n  /***/\n\n},\n/* 15 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime/helpers/typeof\");\n  /***/\n},\n/* 16 */\n\n/***/\nfunction (module, exports) {\n  // Copyright Joyent, Inc. and other Node contributors.\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a\n  // copy of this software and associated documentation files (the\n  // \"Software\"), to deal in the Software without restriction, including\n  // without limitation the rights to use, copy, modify, merge, publish,\n  // distribute, sublicense, and/or sell copies of the Software, and to permit\n  // persons to whom the Software is furnished to do so, subject to the\n  // following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included\n  // in all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n  // USE OR OTHER DEALINGS IN THE SOFTWARE.\n  // NOTE: These type checking functions intentionally don't use `instanceof`\n  // because it is fragile and can be easily faked with `Object.create()`.\n  function isArray(arg) {\n    if (Array.isArray) {\n      return Array.isArray(arg);\n    }\n\n    return objectToString(arg) === '[object Array]';\n  }\n\n  exports.isArray = isArray;\n\n  function isBoolean(arg) {\n    return typeof arg === 'boolean';\n  }\n\n  exports.isBoolean = isBoolean;\n\n  function isNull(arg) {\n    return arg === null;\n  }\n\n  exports.isNull = isNull;\n\n  function isNullOrUndefined(arg) {\n    return arg == null;\n  }\n\n  exports.isNullOrUndefined = isNullOrUndefined;\n\n  function isNumber(arg) {\n    return typeof arg === 'number';\n  }\n\n  exports.isNumber = isNumber;\n\n  function isString(arg) {\n    return typeof arg === 'string';\n  }\n\n  exports.isString = isString;\n\n  function isSymbol(arg) {\n    return typeof arg === 'symbol';\n  }\n\n  exports.isSymbol = isSymbol;\n\n  function isUndefined(arg) {\n    return arg === void 0;\n  }\n\n  exports.isUndefined = isUndefined;\n\n  function isRegExp(re) {\n    return objectToString(re) === '[object RegExp]';\n  }\n\n  exports.isRegExp = isRegExp;\n\n  function isObject(arg) {\n    return typeof arg === 'object' && arg !== null;\n  }\n\n  exports.isObject = isObject;\n\n  function isDate(d) {\n    return objectToString(d) === '[object Date]';\n  }\n\n  exports.isDate = isDate;\n\n  function isError(e) {\n    return objectToString(e) === '[object Error]' || e instanceof Error;\n  }\n\n  exports.isError = isError;\n\n  function isFunction(arg) {\n    return typeof arg === 'function';\n  }\n\n  exports.isFunction = isFunction;\n\n  function isPrimitive(arg) {\n    return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol\n    typeof arg === 'undefined';\n  }\n\n  exports.isPrimitive = isPrimitive;\n  exports.isBuffer = Buffer.isBuffer;\n\n  function objectToString(o) {\n    return Object.prototype.toString.call(o);\n  }\n  /***/\n\n},\n/* 17 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\"; // Copyright Joyent, Inc. and other Node contributors.\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a\n  // copy of this software and associated documentation files (the\n  // \"Software\"), to deal in the Software without restriction, including\n  // without limitation the rights to use, copy, modify, merge, publish,\n  // distribute, sublicense, and/or sell copies of the Software, and to permit\n  // persons to whom the Software is furnished to do so, subject to the\n  // following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included\n  // in all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n  // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n  var R = typeof Reflect === 'object' ? Reflect : null;\n  var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  };\n  var ReflectOwnKeys;\n\n  if (R && typeof R.ownKeys === 'function') {\n    ReflectOwnKeys = R.ownKeys;\n  } else if (Object.getOwnPropertySymbols) {\n    ReflectOwnKeys = function ReflectOwnKeys(target) {\n      return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n    };\n  } else {\n    ReflectOwnKeys = function ReflectOwnKeys(target) {\n      return Object.getOwnPropertyNames(target);\n    };\n  }\n\n  function ProcessEmitWarning(warning) {\n    if (console && console.warn) console.warn(warning);\n  }\n\n  var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n    return value !== value;\n  };\n\n  function EventEmitter() {\n    EventEmitter.init.call(this);\n  }\n\n  module.exports = EventEmitter;\n  module.exports.once = once; // Backwards-compat with node 0.10.x\n\n  EventEmitter.EventEmitter = EventEmitter;\n  EventEmitter.prototype._events = undefined;\n  EventEmitter.prototype._eventsCount = 0;\n  EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are\n  // added to it. This is a useful default which helps finding memory leaks.\n\n  var defaultMaxListeners = 10;\n\n  function checkListener(listener) {\n    if (typeof listener !== 'function') {\n      throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n    }\n  }\n\n  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {\n    enumerable: true,\n    get: function get() {\n      return defaultMaxListeners;\n    },\n    set: function set(arg) {\n      if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n        throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n      }\n\n      defaultMaxListeners = arg;\n    }\n  });\n\n  EventEmitter.init = function () {\n    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n      this._events = Object.create(null);\n      this._eventsCount = 0;\n    }\n\n    this._maxListeners = this._maxListeners || undefined;\n  }; // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n\n\n  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n      throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n    }\n\n    this._maxListeners = n;\n    return this;\n  };\n\n  function _getMaxListeners(that) {\n    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n    return that._maxListeners;\n  }\n\n  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n    return _getMaxListeners(this);\n  };\n\n  EventEmitter.prototype.emit = function emit(type) {\n    var args = [];\n\n    for (var i = 1; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var doError = type === 'error';\n    var events = this._events;\n    if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.\n\n    if (doError) {\n      var er;\n      if (args.length > 0) er = args[0];\n\n      if (er instanceof Error) {\n        // Note: The comments on the `throw` lines are intentional, they show\n        // up in Node's output if this results in an unhandled exception.\n        throw er; // Unhandled 'error' event\n      } // At least give some kind of context to the user\n\n\n      var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n      err.context = er;\n      throw err; // Unhandled 'error' event\n    }\n\n    var handler = events[type];\n    if (handler === undefined) return false;\n\n    if (typeof handler === 'function') {\n      ReflectApply(handler, this, args);\n    } else {\n      var len = handler.length;\n      var listeners = arrayClone(handler, len);\n\n      for (var i = 0; i < len; ++i) {\n        ReflectApply(listeners[i], this, args);\n      }\n    }\n\n    return true;\n  };\n\n  function _addListener(target, type, listener, prepend) {\n    var m;\n    var events;\n    var existing;\n    checkListener(listener);\n    events = target._events;\n\n    if (events === undefined) {\n      events = target._events = Object.create(null);\n      target._eventsCount = 0;\n    } else {\n      // To avoid recursion in the case that type === \"newListener\"! Before\n      // adding it to the listeners, first emit \"newListener\".\n      if (events.newListener !== undefined) {\n        target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the\n        // this._events to be assigned to a new object\n\n        events = target._events;\n      }\n\n      existing = events[type];\n    }\n\n    if (existing === undefined) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      existing = events[type] = listener;\n      ++target._eventsCount;\n    } else {\n      if (typeof existing === 'function') {\n        // Adding the second element, need to change to array.\n        existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.\n      } else if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      } // Check for listener leak\n\n\n      m = _getMaxListeners(target);\n\n      if (m > 0 && existing.length > m && !existing.warned) {\n        existing.warned = true; // No error code for this since it is a Warning\n        // eslint-disable-next-line no-restricted-syntax\n\n        var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        ProcessEmitWarning(w);\n      }\n    }\n\n    return target;\n  }\n\n  EventEmitter.prototype.addListener = function addListener(type, listener) {\n    return _addListener(this, type, listener, false);\n  };\n\n  EventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n  EventEmitter.prototype.prependListener = function prependListener(type, listener) {\n    return _addListener(this, type, listener, true);\n  };\n\n  function onceWrapper() {\n    if (!this.fired) {\n      this.target.removeListener(this.type, this.wrapFn);\n      this.fired = true;\n      if (arguments.length === 0) return this.listener.call(this.target);\n      return this.listener.apply(this.target, arguments);\n    }\n  }\n\n  function _onceWrap(target, type, listener) {\n    var state = {\n      fired: false,\n      wrapFn: undefined,\n      target: target,\n      type: type,\n      listener: listener\n    };\n    var wrapped = onceWrapper.bind(state);\n    wrapped.listener = listener;\n    state.wrapFn = wrapped;\n    return wrapped;\n  }\n\n  EventEmitter.prototype.once = function once(type, listener) {\n    checkListener(listener);\n    this.on(type, _onceWrap(this, type, listener));\n    return this;\n  };\n\n  EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n    checkListener(listener);\n    this.prependListener(type, _onceWrap(this, type, listener));\n    return this;\n  }; // Emits a 'removeListener' event if and only if the listener was removed.\n\n\n  EventEmitter.prototype.removeListener = function removeListener(type, listener) {\n    var list, events, position, i, originalListener;\n    checkListener(listener);\n    events = this._events;\n    if (events === undefined) return this;\n    list = events[type];\n    if (list === undefined) return this;\n\n    if (list === listener || list.listener === listener) {\n      if (--this._eventsCount === 0) this._events = Object.create(null);else {\n        delete events[type];\n        if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n      }\n    } else if (typeof list !== 'function') {\n      position = -1;\n\n      for (i = list.length - 1; i >= 0; i--) {\n        if (list[i] === listener || list[i].listener === listener) {\n          originalListener = list[i].listener;\n          position = i;\n          break;\n        }\n      }\n\n      if (position < 0) return this;\n      if (position === 0) list.shift();else {\n        spliceOne(list, position);\n      }\n      if (list.length === 1) events[type] = list[0];\n      if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\n  EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n    var listeners, events, i;\n    events = this._events;\n    if (events === undefined) return this; // not listening for removeListener, no need to emit\n\n    if (events.removeListener === undefined) {\n      if (arguments.length === 0) {\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n      } else if (events[type] !== undefined) {\n        if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];\n      }\n\n      return this;\n    } // emit removeListener for all listeners on all events\n\n\n    if (arguments.length === 0) {\n      var keys = Object.keys(events);\n      var key;\n\n      for (i = 0; i < keys.length; ++i) {\n        key = keys[i];\n        if (key === 'removeListener') continue;\n        this.removeAllListeners(key);\n      }\n\n      this.removeAllListeners('removeListener');\n      this._events = Object.create(null);\n      this._eventsCount = 0;\n      return this;\n    }\n\n    listeners = events[type];\n\n    if (typeof listeners === 'function') {\n      this.removeListener(type, listeners);\n    } else if (listeners !== undefined) {\n      // LIFO order\n      for (i = listeners.length - 1; i >= 0; i--) {\n        this.removeListener(type, listeners[i]);\n      }\n    }\n\n    return this;\n  };\n\n  function _listeners(target, type, unwrap) {\n    var events = target._events;\n    if (events === undefined) return [];\n    var evlistener = events[type];\n    if (evlistener === undefined) return [];\n    if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n  }\n\n  EventEmitter.prototype.listeners = function listeners(type) {\n    return _listeners(this, type, true);\n  };\n\n  EventEmitter.prototype.rawListeners = function rawListeners(type) {\n    return _listeners(this, type, false);\n  };\n\n  EventEmitter.listenerCount = function (emitter, type) {\n    if (typeof emitter.listenerCount === 'function') {\n      return emitter.listenerCount(type);\n    } else {\n      return listenerCount.call(emitter, type);\n    }\n  };\n\n  EventEmitter.prototype.listenerCount = listenerCount;\n\n  function listenerCount(type) {\n    var events = this._events;\n\n    if (events !== undefined) {\n      var evlistener = events[type];\n\n      if (typeof evlistener === 'function') {\n        return 1;\n      } else if (evlistener !== undefined) {\n        return evlistener.length;\n      }\n    }\n\n    return 0;\n  }\n\n  EventEmitter.prototype.eventNames = function eventNames() {\n    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n  };\n\n  function arrayClone(arr, n) {\n    var copy = new Array(n);\n\n    for (var i = 0; i < n; ++i) {\n      copy[i] = arr[i];\n    }\n\n    return copy;\n  }\n\n  function spliceOne(list, index) {\n    for (; index + 1 < list.length; index++) {\n      list[index] = list[index + 1];\n    }\n\n    list.pop();\n  }\n\n  function unwrapListeners(arr) {\n    var ret = new Array(arr.length);\n\n    for (var i = 0; i < ret.length; ++i) {\n      ret[i] = arr[i].listener || arr[i];\n    }\n\n    return ret;\n  }\n\n  function once(emitter, name) {\n    return new Promise(function (resolve, reject) {\n      function errorListener(err) {\n        emitter.removeListener(name, resolver);\n        reject(err);\n      }\n\n      function resolver() {\n        if (typeof emitter.removeListener === 'function') {\n          emitter.removeListener('error', errorListener);\n        }\n\n        resolve([].slice.call(arguments));\n      }\n\n      ;\n      eventTargetAgnosticAddListener(emitter, name, resolver, {\n        once: true\n      });\n\n      if (name !== 'error') {\n        addErrorHandlerIfEventEmitter(emitter, errorListener, {\n          once: true\n        });\n      }\n    });\n  }\n\n  function addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n    if (typeof emitter.on === 'function') {\n      eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n    }\n  }\n\n  function eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n    if (typeof emitter.on === 'function') {\n      if (flags.once) {\n        emitter.once(name, listener);\n      } else {\n        emitter.on(name, listener);\n      }\n    } else if (typeof emitter.addEventListener === 'function') {\n      // EventTarget does not have `error` event semantics like Node\n      // EventEmitters, we do not listen for `error` events here.\n      emitter.addEventListener(name, function wrapListener(arg) {\n        // IE does not have builtin `{ once: true }` support so we\n        // have to do it manually.\n        if (flags.once) {\n          emitter.removeEventListener(name, wrapListener);\n        }\n\n        listener(arg);\n      });\n    } else {\n      throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n    }\n  }\n  /***/\n\n},\n/* 18 */\n\n/***/\nfunction (module, __webpack_exports__, __webpack_require__) {\n  \"use strict\";\n  /* harmony export (binding) */\n\n  __webpack_require__.d(__webpack_exports__, \"h\", function () {\n    return serializeError;\n  });\n  /* harmony export (binding) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"g\", function () {\n    return getRpcPromiseCallback;\n  });\n  /* harmony export (binding) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"b\", function () {\n    return createErrorMiddleware;\n  });\n  /* harmony export (binding) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"f\", function () {\n    return createStreamMiddleware;\n  });\n  /* harmony export (binding) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"e\", function () {\n    return createScaffoldMiddleware;\n  });\n  /* harmony export (binding) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"c\", function () {\n    return createIdRemapMiddleware;\n  });\n  /* harmony export (binding) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"d\", function () {\n    return createLoggerMiddleware;\n  });\n  /* harmony export (binding) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"a\", function () {\n    return createAsyncMiddleware;\n  });\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__);\n  /* harmony import */\n\n\n  var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);\n  /* harmony import */\n\n\n  var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__);\n  /* harmony import */\n\n\n  var _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38);\n  /* harmony import */\n\n\n  var _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_2__);\n  /* harmony import */\n\n\n  var stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10);\n  /* harmony import */\n\n\n  var stream__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_3__);\n  /* harmony import */\n\n\n  var _safeEventEmitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(14);\n  /* harmony import */\n\n\n  var _serializableError__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8);\n\n  function serializeError(error) {\n    return error.toString();\n  }\n\n  var getRpcPromiseCallback = function getRpcPromiseCallback(resolve, reject) {\n    var unwrapResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return function (error, response) {\n      if (error || response.error) {\n        reject(error || response.error);\n      } else if (!unwrapResult || Array.isArray(response)) {\n        resolve(response);\n      } else {\n        resolve(response.result);\n      }\n    };\n  };\n\n  function createErrorMiddleware(log) {\n    return function (req, res, next, end) {\n      try {\n        // json-rpc-engine will terminate the request when it notices this error\n        if (typeof req.method !== \"string\" || !req.method) {\n          res.error = new _serializableError__WEBPACK_IMPORTED_MODULE_5__[\n          /* default */\n          \"a\"]({\n            code: -32603,\n            message: \"invalid method\"\n          });\n          end();\n          return;\n        }\n\n        next(function (done) {\n          var error = res.error;\n\n          if (!error) {\n            return done();\n          }\n\n          log.error(\"OpenLogin - RPC Error: \".concat(error.message), error);\n          return done();\n        });\n      } catch (error) {\n        log.error(\"OpenLogin - RPC Error thrown: \".concat(error.message), error);\n        res.error = new _serializableError__WEBPACK_IMPORTED_MODULE_5__[\n        /* default */\n        \"a\"]({\n          code: -32603,\n          message: error.message\n        });\n        end();\n      }\n    };\n  }\n\n  function createStreamMiddleware() {\n    var idMap = {};\n\n    function readNoop() {\n      return false;\n    }\n\n    var events = new _safeEventEmitter__WEBPACK_IMPORTED_MODULE_4__[\n    /* default */\n    \"a\"]();\n\n    function processResponse(res) {\n      var context = idMap[res.id];\n\n      if (!context) {\n        throw new Error(\"StreamMiddleware - Unknown response id \\\"\".concat(res.id, \"\\\"\"));\n      }\n\n      delete idMap[res.id]; // copy whole res onto original res\n\n      Object.assign(context.res, res); // run callback on empty stack,\n      // prevent internal stream-handler from catching errors\n\n      setTimeout(context.end);\n    }\n\n    function processNotification(res) {\n      events.emit(\"notification\", res);\n    }\n\n    function processMessage(res, _encoding, cb) {\n      var err;\n\n      try {\n        var isNotification = !res.id;\n\n        if (isNotification) {\n          processNotification(res);\n        } else {\n          processResponse(res);\n        }\n      } catch (_err) {\n        err = _err;\n      } // continue processing stream\n\n\n      cb(err);\n    }\n\n    var stream = new stream__WEBPACK_IMPORTED_MODULE_3__[\"Duplex\"]({\n      objectMode: true,\n      read: readNoop,\n      write: processMessage\n    });\n\n    var middleware = function middleware(req, res, next, end) {\n      // write req to stream\n      stream.push(req); // register request on id map\n\n      idMap[req.id] = {\n        req: req,\n        res: res,\n        next: next,\n        end: end\n      };\n    };\n\n    return {\n      events: events,\n      middleware: middleware,\n      stream: stream\n    };\n  }\n\n  function createScaffoldMiddleware(handlers) {\n    return function (req, res, next, end) {\n      var handler = handlers[req.method]; // if no handler, return\n\n      if (handler === undefined) {\n        return next();\n      } // if handler is fn, call as middleware\n\n\n      if (typeof handler === \"function\") {\n        return handler(req, res, next, end);\n      } // if handler is some other value, use as result\n\n\n      res.result = handler;\n      return end();\n    };\n  }\n\n  function createIdRemapMiddleware() {\n    return function (req, res, next, _end) {\n      var originalId = req.id;\n      var newId = Object(_toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_2__[\"randomId\"])();\n      req.id = newId;\n      res.id = newId;\n      next(function (done) {\n        req.id = originalId;\n        res.id = originalId;\n        done();\n      });\n    };\n  }\n\n  function createLoggerMiddleware(logger) {\n    return function (req, res, next, _) {\n      logger.debug(\"REQ\", req, \"RES\", res);\n      next();\n    };\n  }\n\n  function createAsyncMiddleware(asyncMiddleware) {\n    return /*#__PURE__*/function () {\n      var _ref = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee2(req, res, next, end) {\n        var resolveNextPromise, nextPromise, returnHandlerCallback, nextWasCalled, asyncNext;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // nextPromise is the key to the implementation\n                // it is resolved by the return handler passed to the\n                // \"next\" function\n                nextPromise = new Promise(function (resolve) {\n                  resolveNextPromise = resolve;\n                });\n                returnHandlerCallback = null;\n                nextWasCalled = false; // This will be called by the consumer's async middleware.\n\n                asyncNext = /*#__PURE__*/function () {\n                  var _ref2 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee() {\n                    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            nextWasCalled = true; // We pass a return handler to next(). When it is called by the engine,\n                            // the consumer's async middleware will resume executing.\n                            // eslint-disable-next-line node/callback-return\n\n                            next(function (runReturnHandlersCallback) {\n                              // This callback comes from JRPCEngine._runReturnHandlers\n                              returnHandlerCallback = runReturnHandlersCallback;\n                              resolveNextPromise();\n                            });\n                            _context.next = 4;\n                            return nextPromise;\n\n                          case 4:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }));\n\n                  return function asyncNext() {\n                    return _ref2.apply(this, arguments);\n                  };\n                }();\n\n                _context2.prev = 4;\n                _context2.next = 7;\n                return asyncMiddleware(req, res, asyncNext);\n\n              case 7:\n                if (!nextWasCalled) {\n                  _context2.next = 13;\n                  break;\n                }\n\n                _context2.next = 10;\n                return nextPromise;\n\n              case 10:\n                // we must wait until the return handler is called\n                returnHandlerCallback(null);\n                _context2.next = 14;\n                break;\n\n              case 13:\n                end(null);\n\n              case 14:\n                _context2.next = 19;\n                break;\n\n              case 16:\n                _context2.prev = 16;\n                _context2.t0 = _context2[\"catch\"](4);\n\n                if (returnHandlerCallback) {\n                  returnHandlerCallback(_context2.t0);\n                } else {\n                  end(_context2.t0);\n                }\n\n              case 19:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[4, 16]]);\n      }));\n\n      return function (_x, _x2, _x3, _x4) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n  }\n  /***/\n\n},\n/* 19 */\n\n/***/\nfunction (module, exports) {\n  // shim for using process in browser\n  var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n  // don't break things.  But we need to wrap it in a try catch in case it is\n  // wrapped in strict mode code which doesn't define any globals.  It's inside a\n  // function because try/catches deoptimize in certain engines.\n\n  var cachedSetTimeout;\n  var cachedClearTimeout;\n\n  function defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n  }\n\n  function defaultClearTimeout() {\n    throw new Error('clearTimeout has not been defined');\n  }\n\n  (function () {\n    try {\n      if (typeof setTimeout === 'function') {\n        cachedSetTimeout = setTimeout;\n      } else {\n        cachedSetTimeout = defaultSetTimout;\n      }\n    } catch (e) {\n      cachedSetTimeout = defaultSetTimout;\n    }\n\n    try {\n      if (typeof clearTimeout === 'function') {\n        cachedClearTimeout = clearTimeout;\n      } else {\n        cachedClearTimeout = defaultClearTimeout;\n      }\n    } catch (e) {\n      cachedClearTimeout = defaultClearTimeout;\n    }\n  })();\n\n  function runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n      //normal enviroments in sane situations\n      return setTimeout(fun, 0);\n    } // if setTimeout wasn't available but was latter defined\n\n\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n      cachedSetTimeout = setTimeout;\n      return setTimeout(fun, 0);\n    }\n\n    try {\n      // when when somebody has screwed with setTimeout but no I.E. maddness\n      return cachedSetTimeout(fun, 0);\n    } catch (e) {\n      try {\n        // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n        return cachedSetTimeout.call(null, fun, 0);\n      } catch (e) {\n        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n        return cachedSetTimeout.call(this, fun, 0);\n      }\n    }\n  }\n\n  function runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n      //normal enviroments in sane situations\n      return clearTimeout(marker);\n    } // if clearTimeout wasn't available but was latter defined\n\n\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n      cachedClearTimeout = clearTimeout;\n      return clearTimeout(marker);\n    }\n\n    try {\n      // when when somebody has screwed with setTimeout but no I.E. maddness\n      return cachedClearTimeout(marker);\n    } catch (e) {\n      try {\n        // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n        return cachedClearTimeout.call(null, marker);\n      } catch (e) {\n        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n        // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n        return cachedClearTimeout.call(this, marker);\n      }\n    }\n  }\n\n  var queue = [];\n  var draining = false;\n  var currentQueue;\n  var queueIndex = -1;\n\n  function cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n      return;\n    }\n\n    draining = false;\n\n    if (currentQueue.length) {\n      queue = currentQueue.concat(queue);\n    } else {\n      queueIndex = -1;\n    }\n\n    if (queue.length) {\n      drainQueue();\n    }\n  }\n\n  function drainQueue() {\n    if (draining) {\n      return;\n    }\n\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n    var len = queue.length;\n\n    while (len) {\n      currentQueue = queue;\n      queue = [];\n\n      while (++queueIndex < len) {\n        if (currentQueue) {\n          currentQueue[queueIndex].run();\n        }\n      }\n\n      queueIndex = -1;\n      len = queue.length;\n    }\n\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n  }\n\n  process.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n\n    if (arguments.length > 1) {\n      for (var i = 1; i < arguments.length; i++) {\n        args[i - 1] = arguments[i];\n      }\n    }\n\n    queue.push(new Item(fun, args));\n\n    if (queue.length === 1 && !draining) {\n      runTimeout(drainQueue);\n    }\n  }; // v8 likes predictible objects\n\n\n  function Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n  }\n\n  Item.prototype.run = function () {\n    this.fun.apply(null, this.array);\n  };\n\n  process.title = 'browser';\n  process.browser = true;\n  process.env = {};\n  process.argv = [];\n  process.version = ''; // empty string to avoid regexp issues\n\n  process.versions = {};\n\n  function noop() {}\n\n  process.on = noop;\n  process.addListener = noop;\n  process.once = noop;\n  process.off = noop;\n  process.removeListener = noop;\n  process.removeAllListeners = noop;\n  process.emit = noop;\n  process.prependListener = noop;\n  process.prependOnceListener = noop;\n\n  process.listeners = function (name) {\n    return [];\n  };\n\n  process.binding = function (name) {\n    throw new Error('process.binding is not supported');\n  };\n\n  process.cwd = function () {\n    return '/';\n  };\n\n  process.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n  };\n\n  process.umask = function () {\n    return 0;\n  };\n  /***/\n\n},\n/* 20 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n  /* WEBPACK VAR INJECTION */\n\n  (function (process) {\n    if (typeof process === 'undefined' || !process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n      module.exports = {\n        nextTick: nextTick\n      };\n    } else {\n      module.exports = process;\n    }\n\n    function nextTick(fn, arg1, arg2, arg3) {\n      if (typeof fn !== 'function') {\n        throw new TypeError('\"callback\" argument must be a function');\n      }\n\n      var len = arguments.length;\n      var args, i;\n\n      switch (len) {\n        case 0:\n        case 1:\n          return process.nextTick(fn);\n\n        case 2:\n          return process.nextTick(function afterTickOne() {\n            fn.call(null, arg1);\n          });\n\n        case 3:\n          return process.nextTick(function afterTickTwo() {\n            fn.call(null, arg1, arg2);\n          });\n\n        case 4:\n          return process.nextTick(function afterTickThree() {\n            fn.call(null, arg1, arg2, arg3);\n          });\n\n        default:\n          args = new Array(len - 1);\n          i = 0;\n\n          while (i < args.length) {\n            args[i++] = arguments[i];\n          }\n\n          return process.nextTick(function afterTick() {\n            fn.apply(null, args);\n          });\n      }\n    }\n    /* WEBPACK VAR INJECTION */\n\n  }).call(this, __webpack_require__(19));\n  /***/\n},\n/* 21 */\n\n/***/\nfunction (module, __webpack_exports__, __webpack_require__) {\n  \"use strict\";\n  /* harmony export (binding) */\n\n  __webpack_require__.d(__webpack_exports__, \"a\", function () {\n    return Substream;\n  });\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(0);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__);\n  /* harmony import */\n\n\n  var stream__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(10);\n  /* harmony import */\n\n\n  var stream__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_7__);\n\n  function _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n    return function _createSuperInternal() {\n      var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(Derived),\n          result;\n\n      if (hasNativeReflectConstruct) {\n        var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(this).constructor;\n\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n\n      return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default()(this, result);\n    };\n  }\n\n  function _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  var Substream = /*#__PURE__*/function (_Duplex) {\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default()(Substream, _Duplex);\n\n    var _super = _createSuper(Substream);\n\n    function Substream(_ref) {\n      var _this;\n\n      var parent = _ref.parent,\n          name = _ref.name;\n\n      _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, Substream);\n\n      _this = _super.call(this, {\n        objectMode: true\n      });\n\n      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2___default()(_this), \"_parent\", void 0);\n\n      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2___default()(_this), \"_name\", void 0);\n\n      _this._parent = parent;\n      _this._name = name;\n      return _this;\n    }\n    /**\n     * Explicitly sets read operations to a no-op.\n     */\n    // eslint-disable-next-line class-methods-use-this\n\n\n    _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(Substream, [{\n      key: \"_read\",\n      value: function _read() {\n        return undefined;\n      }\n      /**\n       * Called when data should be written to this writable stream.\n       *\n       * @param chunk - Arbitrary object to write\n       * @param encoding - Encoding to use when writing payload\n       * @param callback - Called when writing is complete or an error occurs\n       */\n\n    }, {\n      key: \"_write\",\n      value: function _write(chunk, _encoding, callback) {\n        this._parent.push({\n          name: this._name,\n          data: chunk\n        });\n\n        callback();\n      }\n    }]);\n\n    return Substream;\n  }(stream__WEBPACK_IMPORTED_MODULE_7__[\"Duplex\"]);\n  /***/\n\n},\n/* 22 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime/helpers/slicedToArray\");\n  /***/\n},\n/* 23 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  exports = module.exports = __webpack_require__(27);\n  exports.Stream = exports;\n  exports.Readable = exports;\n  exports.Writable = __webpack_require__(25);\n  exports.Duplex = __webpack_require__(11);\n  exports.Transform = __webpack_require__(33);\n  exports.PassThrough = __webpack_require__(53);\n  /***/\n},\n/* 24 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  /* eslint-disable node/no-deprecated-api */\n  var buffer = __webpack_require__(30);\n\n  var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers\n\n  function copyProps(src, dst) {\n    for (var key in src) {\n      dst[key] = src[key];\n    }\n  }\n\n  if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n    module.exports = buffer;\n  } else {\n    // Copy properties from require('buffer')\n    copyProps(buffer, exports);\n    exports.Buffer = SafeBuffer;\n  }\n\n  function SafeBuffer(arg, encodingOrOffset, length) {\n    return Buffer(arg, encodingOrOffset, length);\n  } // Copy static methods from Buffer\n\n\n  copyProps(Buffer, SafeBuffer);\n\n  SafeBuffer.from = function (arg, encodingOrOffset, length) {\n    if (typeof arg === 'number') {\n      throw new TypeError('Argument must not be a number');\n    }\n\n    return Buffer(arg, encodingOrOffset, length);\n  };\n\n  SafeBuffer.alloc = function (size, fill, encoding) {\n    if (typeof size !== 'number') {\n      throw new TypeError('Argument must be a number');\n    }\n\n    var buf = Buffer(size);\n\n    if (fill !== undefined) {\n      if (typeof encoding === 'string') {\n        buf.fill(fill, encoding);\n      } else {\n        buf.fill(fill);\n      }\n    } else {\n      buf.fill(0);\n    }\n\n    return buf;\n  };\n\n  SafeBuffer.allocUnsafe = function (size) {\n    if (typeof size !== 'number') {\n      throw new TypeError('Argument must be a number');\n    }\n\n    return Buffer(size);\n  };\n\n  SafeBuffer.allocUnsafeSlow = function (size) {\n    if (typeof size !== 'number') {\n      throw new TypeError('Argument must be a number');\n    }\n\n    return buffer.SlowBuffer(size);\n  };\n  /***/\n\n},\n/* 25 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n  /* WEBPACK VAR INJECTION */\n\n  (function (process, setImmediate, global) {\n    // Copyright Joyent, Inc. and other Node contributors.\n    //\n    // Permission is hereby granted, free of charge, to any person obtaining a\n    // copy of this software and associated documentation files (the\n    // \"Software\"), to deal in the Software without restriction, including\n    // without limitation the rights to use, copy, modify, merge, publish,\n    // distribute, sublicense, and/or sell copies of the Software, and to permit\n    // persons to whom the Software is furnished to do so, subject to the\n    // following conditions:\n    //\n    // The above copyright notice and this permission notice shall be included\n    // in all copies or substantial portions of the Software.\n    //\n    // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n    // USE OR OTHER DEALINGS IN THE SOFTWARE.\n    // A bit simpler than readable streams.\n    // Implement an async ._write(chunk, encoding, cb), and it'll handle all\n    // the drain event emission and buffering.\n\n    /*<replacement>*/\n    var pna = __webpack_require__(20);\n    /*</replacement>*/\n\n\n    module.exports = Writable;\n    /* <replacement> */\n\n    function WriteReq(chunk, encoding, cb) {\n      this.chunk = chunk;\n      this.encoding = encoding;\n      this.callback = cb;\n      this.next = null;\n    } // It seems a linked list but it is not\n    // there will be only 2 of these for each stream\n\n\n    function CorkedRequest(state) {\n      var _this = this;\n\n      this.next = null;\n      this.entry = null;\n\n      this.finish = function () {\n        onCorkedFinish(_this, state);\n      };\n    }\n    /* </replacement> */\n\n    /*<replacement>*/\n\n\n    var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n    /*</replacement>*/\n\n    /*<replacement>*/\n\n    var Duplex;\n    /*</replacement>*/\n\n    Writable.WritableState = WritableState;\n    /*<replacement>*/\n\n    var util = Object.create(__webpack_require__(16));\n    util.inherits = __webpack_require__(12);\n    /*</replacement>*/\n\n    /*<replacement>*/\n\n    var internalUtil = {\n      deprecate: __webpack_require__(51)\n    };\n    /*</replacement>*/\n\n    /*<replacement>*/\n\n    var Stream = __webpack_require__(29);\n    /*</replacement>*/\n\n    /*<replacement>*/\n\n\n    var Buffer = __webpack_require__(24).Buffer;\n\n    var OurUint8Array = global.Uint8Array || function () {};\n\n    function _uint8ArrayToBuffer(chunk) {\n      return Buffer.from(chunk);\n    }\n\n    function _isUint8Array(obj) {\n      return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n    }\n    /*</replacement>*/\n\n\n    var destroyImpl = __webpack_require__(31);\n\n    util.inherits(Writable, Stream);\n\n    function nop() {}\n\n    function WritableState(options, stream) {\n      Duplex = Duplex || __webpack_require__(11);\n      options = options || {}; // Duplex streams are both readable and writable, but share\n      // the same options object.\n      // However, some cases require setting options to different\n      // values for the readable and the writable sides of the duplex stream.\n      // These options can be provided separately as readableXXX and writableXXX.\n\n      var isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n      // contains buffers or objects.\n\n      this.objectMode = !!options.objectMode;\n      if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n      // Note: 0 is a valid value, means that we always return false if\n      // the entire buffer is not flushed immediately on write()\n\n      var hwm = options.highWaterMark;\n      var writableHwm = options.writableHighWaterMark;\n      var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n      if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm; // cast to ints.\n\n      this.highWaterMark = Math.floor(this.highWaterMark); // if _final has been called\n\n      this.finalCalled = false; // drain event flag.\n\n      this.needDrain = false; // at the start of calling end()\n\n      this.ending = false; // when end() has been called, and returned\n\n      this.ended = false; // when 'finish' is emitted\n\n      this.finished = false; // has it been destroyed\n\n      this.destroyed = false; // should we decode strings into buffers before passing to _write?\n      // this is here so that some node-core streams can optimize string\n      // handling at a lower level.\n\n      var noDecode = options.decodeStrings === false;\n      this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n      // encoding is 'binary' so we have to make this configurable.\n      // Everything else in the universe uses 'utf8', though.\n\n      this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n      // of how much we're waiting to get pushed to some underlying\n      // socket or file.\n\n      this.length = 0; // a flag to see when we're in the middle of a write.\n\n      this.writing = false; // when true all writes will be buffered until .uncork() call\n\n      this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n      // or on a later tick.  We set this to true at first, because any\n      // actions that shouldn't happen until \"later\" should generally also\n      // not happen before the first write call.\n\n      this.sync = true; // a flag to know if we're processing previously buffered items, which\n      // may call the _write() callback in the same tick, so that we don't\n      // end up in an overlapped onwrite situation.\n\n      this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n      this.onwrite = function (er) {\n        onwrite(stream, er);\n      }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n      this.writecb = null; // the amount that is being written when _write is called.\n\n      this.writelen = 0;\n      this.bufferedRequest = null;\n      this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n      // this must be 0 before 'finish' can be emitted\n\n      this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n      // This is relevant for synchronous Transform streams\n\n      this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n      this.errorEmitted = false; // count buffered requests\n\n      this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n      // one allocated and free to use, and we maintain at most two\n\n      this.corkedRequestsFree = new CorkedRequest(this);\n    }\n\n    WritableState.prototype.getBuffer = function getBuffer() {\n      var current = this.bufferedRequest;\n      var out = [];\n\n      while (current) {\n        out.push(current);\n        current = current.next;\n      }\n\n      return out;\n    };\n\n    (function () {\n      try {\n        Object.defineProperty(WritableState.prototype, 'buffer', {\n          get: internalUtil.deprecate(function () {\n            return this.getBuffer();\n          }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n        });\n      } catch (_) {}\n    })(); // Test _writableState for inheritance to account for Duplex streams,\n    // whose prototype chain only points to Readable.\n\n\n    var realHasInstance;\n\n    if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n      realHasInstance = Function.prototype[Symbol.hasInstance];\n      Object.defineProperty(Writable, Symbol.hasInstance, {\n        value: function value(object) {\n          if (realHasInstance.call(this, object)) return true;\n          if (this !== Writable) return false;\n          return object && object._writableState instanceof WritableState;\n        }\n      });\n    } else {\n      realHasInstance = function realHasInstance(object) {\n        return object instanceof this;\n      };\n    }\n\n    function Writable(options) {\n      Duplex = Duplex || __webpack_require__(11); // Writable ctor is applied to Duplexes, too.\n      // `realHasInstance` is necessary because using plain `instanceof`\n      // would return false, as no `_writableState` property is attached.\n      // Trying to use the custom `instanceof` for Writable here will also break the\n      // Node.js LazyTransform implementation, which has a non-trivial getter for\n      // `_writableState` that would lead to infinite recursion.\n\n      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n        return new Writable(options);\n      }\n\n      this._writableState = new WritableState(options, this); // legacy.\n\n      this.writable = true;\n\n      if (options) {\n        if (typeof options.write === 'function') this._write = options.write;\n        if (typeof options.writev === 'function') this._writev = options.writev;\n        if (typeof options.destroy === 'function') this._destroy = options.destroy;\n        if (typeof options.final === 'function') this._final = options.final;\n      }\n\n      Stream.call(this);\n    } // Otherwise people can pipe Writable streams, which is just wrong.\n\n\n    Writable.prototype.pipe = function () {\n      this.emit('error', new Error('Cannot pipe, not readable'));\n    };\n\n    function writeAfterEnd(stream, cb) {\n      var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb\n\n      stream.emit('error', er);\n      pna.nextTick(cb, er);\n    } // Checks that a user-supplied chunk is valid, especially for the particular\n    // mode the stream is in. Currently this means that `null` is never accepted\n    // and undefined/non-string values are only allowed in object mode.\n\n\n    function validChunk(stream, state, chunk, cb) {\n      var valid = true;\n      var er = false;\n\n      if (chunk === null) {\n        er = new TypeError('May not write null values to stream');\n      } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n        er = new TypeError('Invalid non-string/buffer chunk');\n      }\n\n      if (er) {\n        stream.emit('error', er);\n        pna.nextTick(cb, er);\n        valid = false;\n      }\n\n      return valid;\n    }\n\n    Writable.prototype.write = function (chunk, encoding, cb) {\n      var state = this._writableState;\n      var ret = false;\n\n      var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n      if (isBuf && !Buffer.isBuffer(chunk)) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (typeof encoding === 'function') {\n        cb = encoding;\n        encoding = null;\n      }\n\n      if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n      if (typeof cb !== 'function') cb = nop;\n      if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n        state.pendingcb++;\n        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n      }\n      return ret;\n    };\n\n    Writable.prototype.cork = function () {\n      var state = this._writableState;\n      state.corked++;\n    };\n\n    Writable.prototype.uncork = function () {\n      var state = this._writableState;\n\n      if (state.corked) {\n        state.corked--;\n        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n      }\n    };\n\n    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n      // node::ParseEncoding() requires lower case.\n      if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n      if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n      this._writableState.defaultEncoding = encoding;\n      return this;\n    };\n\n    function decodeChunk(state, chunk, encoding) {\n      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n        chunk = Buffer.from(chunk, encoding);\n      }\n\n      return chunk;\n    }\n\n    Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n      // making it explicit this property is not enumerable\n      // because otherwise some prototype manipulation in\n      // userland will fail\n      enumerable: false,\n      get: function get() {\n        return this._writableState.highWaterMark;\n      }\n    }); // if we're already writing something, then just put this\n    // in the queue, and wait our turn.  Otherwise, call _write\n    // If we return false, then we need a drain event, so set that flag.\n\n    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n      if (!isBuf) {\n        var newChunk = decodeChunk(state, chunk, encoding);\n\n        if (chunk !== newChunk) {\n          isBuf = true;\n          encoding = 'buffer';\n          chunk = newChunk;\n        }\n      }\n\n      var len = state.objectMode ? 1 : chunk.length;\n      state.length += len;\n      var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n      if (!ret) state.needDrain = true;\n\n      if (state.writing || state.corked) {\n        var last = state.lastBufferedRequest;\n        state.lastBufferedRequest = {\n          chunk: chunk,\n          encoding: encoding,\n          isBuf: isBuf,\n          callback: cb,\n          next: null\n        };\n\n        if (last) {\n          last.next = state.lastBufferedRequest;\n        } else {\n          state.bufferedRequest = state.lastBufferedRequest;\n        }\n\n        state.bufferedRequestCount += 1;\n      } else {\n        doWrite(stream, state, false, len, chunk, encoding, cb);\n      }\n\n      return ret;\n    }\n\n    function doWrite(stream, state, writev, len, chunk, encoding, cb) {\n      state.writelen = len;\n      state.writecb = cb;\n      state.writing = true;\n      state.sync = true;\n      if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n      state.sync = false;\n    }\n\n    function onwriteError(stream, state, sync, er, cb) {\n      --state.pendingcb;\n\n      if (sync) {\n        // defer the callback if we are being called synchronously\n        // to avoid piling up things on the stack\n        pna.nextTick(cb, er); // this can emit finish, and it will always happen\n        // after error\n\n        pna.nextTick(finishMaybe, stream, state);\n        stream._writableState.errorEmitted = true;\n        stream.emit('error', er);\n      } else {\n        // the caller expect this to happen before if\n        // it is async\n        cb(er);\n        stream._writableState.errorEmitted = true;\n        stream.emit('error', er); // this can emit finish, but finish must\n        // always follow error\n\n        finishMaybe(stream, state);\n      }\n    }\n\n    function onwriteStateUpdate(state) {\n      state.writing = false;\n      state.writecb = null;\n      state.length -= state.writelen;\n      state.writelen = 0;\n    }\n\n    function onwrite(stream, er) {\n      var state = stream._writableState;\n      var sync = state.sync;\n      var cb = state.writecb;\n      onwriteStateUpdate(state);\n      if (er) onwriteError(stream, state, sync, er, cb);else {\n        // Check if we're actually ready to finish, but don't emit yet\n        var finished = needFinish(state);\n\n        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n          clearBuffer(stream, state);\n        }\n\n        if (sync) {\n          /*<replacement>*/\n          asyncWrite(afterWrite, stream, state, finished, cb);\n          /*</replacement>*/\n        } else {\n          afterWrite(stream, state, finished, cb);\n        }\n      }\n    }\n\n    function afterWrite(stream, state, finished, cb) {\n      if (!finished) onwriteDrain(stream, state);\n      state.pendingcb--;\n      cb();\n      finishMaybe(stream, state);\n    } // Must force callback to be called on nextTick, so that we don't\n    // emit 'drain' before the write() consumer gets the 'false' return\n    // value, and has a chance to attach a 'drain' listener.\n\n\n    function onwriteDrain(stream, state) {\n      if (state.length === 0 && state.needDrain) {\n        state.needDrain = false;\n        stream.emit('drain');\n      }\n    } // if there's something in the buffer waiting, then process it\n\n\n    function clearBuffer(stream, state) {\n      state.bufferProcessing = true;\n      var entry = state.bufferedRequest;\n\n      if (stream._writev && entry && entry.next) {\n        // Fast case, write everything using _writev()\n        var l = state.bufferedRequestCount;\n        var buffer = new Array(l);\n        var holder = state.corkedRequestsFree;\n        holder.entry = entry;\n        var count = 0;\n        var allBuffers = true;\n\n        while (entry) {\n          buffer[count] = entry;\n          if (!entry.isBuf) allBuffers = false;\n          entry = entry.next;\n          count += 1;\n        }\n\n        buffer.allBuffers = allBuffers;\n        doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n        // as the hot path ends with doWrite\n\n        state.pendingcb++;\n        state.lastBufferedRequest = null;\n\n        if (holder.next) {\n          state.corkedRequestsFree = holder.next;\n          holder.next = null;\n        } else {\n          state.corkedRequestsFree = new CorkedRequest(state);\n        }\n\n        state.bufferedRequestCount = 0;\n      } else {\n        // Slow case, write chunks one-by-one\n        while (entry) {\n          var chunk = entry.chunk;\n          var encoding = entry.encoding;\n          var cb = entry.callback;\n          var len = state.objectMode ? 1 : chunk.length;\n          doWrite(stream, state, false, len, chunk, encoding, cb);\n          entry = entry.next;\n          state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n          // it means that we need to wait until it does.\n          // also, that means that the chunk and cb are currently\n          // being processed, so move the buffer counter past them.\n\n          if (state.writing) {\n            break;\n          }\n        }\n\n        if (entry === null) state.lastBufferedRequest = null;\n      }\n\n      state.bufferedRequest = entry;\n      state.bufferProcessing = false;\n    }\n\n    Writable.prototype._write = function (chunk, encoding, cb) {\n      cb(new Error('_write() is not implemented'));\n    };\n\n    Writable.prototype._writev = null;\n\n    Writable.prototype.end = function (chunk, encoding, cb) {\n      var state = this._writableState;\n\n      if (typeof chunk === 'function') {\n        cb = chunk;\n        chunk = null;\n        encoding = null;\n      } else if (typeof encoding === 'function') {\n        cb = encoding;\n        encoding = null;\n      }\n\n      if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n      if (state.corked) {\n        state.corked = 1;\n        this.uncork();\n      } // ignore unnecessary end() calls.\n\n\n      if (!state.ending && !state.finished) endWritable(this, state, cb);\n    };\n\n    function needFinish(state) {\n      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n    }\n\n    function callFinal(stream, state) {\n      stream._final(function (err) {\n        state.pendingcb--;\n\n        if (err) {\n          stream.emit('error', err);\n        }\n\n        state.prefinished = true;\n        stream.emit('prefinish');\n        finishMaybe(stream, state);\n      });\n    }\n\n    function prefinish(stream, state) {\n      if (!state.prefinished && !state.finalCalled) {\n        if (typeof stream._final === 'function') {\n          state.pendingcb++;\n          state.finalCalled = true;\n          pna.nextTick(callFinal, stream, state);\n        } else {\n          state.prefinished = true;\n          stream.emit('prefinish');\n        }\n      }\n    }\n\n    function finishMaybe(stream, state) {\n      var need = needFinish(state);\n\n      if (need) {\n        prefinish(stream, state);\n\n        if (state.pendingcb === 0) {\n          state.finished = true;\n          stream.emit('finish');\n        }\n      }\n\n      return need;\n    }\n\n    function endWritable(stream, state, cb) {\n      state.ending = true;\n      finishMaybe(stream, state);\n\n      if (cb) {\n        if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n      }\n\n      state.ended = true;\n      stream.writable = false;\n    }\n\n    function onCorkedFinish(corkReq, state, err) {\n      var entry = corkReq.entry;\n      corkReq.entry = null;\n\n      while (entry) {\n        var cb = entry.callback;\n        state.pendingcb--;\n        cb(err);\n        entry = entry.next;\n      }\n\n      if (state.corkedRequestsFree) {\n        state.corkedRequestsFree.next = corkReq;\n      } else {\n        state.corkedRequestsFree = corkReq;\n      }\n    }\n\n    Object.defineProperty(Writable.prototype, 'destroyed', {\n      get: function get() {\n        if (this._writableState === undefined) {\n          return false;\n        }\n\n        return this._writableState.destroyed;\n      },\n      set: function set(value) {\n        // we ignore the value if the stream\n        // has not been initialized yet\n        if (!this._writableState) {\n          return;\n        } // backward compatibility, the user is explicitly\n        // managing destroyed\n\n\n        this._writableState.destroyed = value;\n      }\n    });\n    Writable.prototype.destroy = destroyImpl.destroy;\n    Writable.prototype._undestroy = destroyImpl.undestroy;\n\n    Writable.prototype._destroy = function (err, cb) {\n      this.end();\n      cb(err);\n    };\n    /* WEBPACK VAR INJECTION */\n\n  }).call(this, __webpack_require__(19), __webpack_require__(49).setImmediate, __webpack_require__(13));\n  /***/\n},\n/* 26 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"end-of-stream\");\n  /***/\n},\n/* 27 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n  /* WEBPACK VAR INJECTION */\n\n  (function (global, process) {\n    // Copyright Joyent, Inc. and other Node contributors.\n    //\n    // Permission is hereby granted, free of charge, to any person obtaining a\n    // copy of this software and associated documentation files (the\n    // \"Software\"), to deal in the Software without restriction, including\n    // without limitation the rights to use, copy, modify, merge, publish,\n    // distribute, sublicense, and/or sell copies of the Software, and to permit\n    // persons to whom the Software is furnished to do so, subject to the\n    // following conditions:\n    //\n    // The above copyright notice and this permission notice shall be included\n    // in all copies or substantial portions of the Software.\n    //\n    // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n    // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n    /*<replacement>*/\n    var pna = __webpack_require__(20);\n    /*</replacement>*/\n\n\n    module.exports = Readable;\n    /*<replacement>*/\n\n    var isArray = __webpack_require__(28);\n    /*</replacement>*/\n\n    /*<replacement>*/\n\n\n    var Duplex;\n    /*</replacement>*/\n\n    Readable.ReadableState = ReadableState;\n    /*<replacement>*/\n\n    var EE = __webpack_require__(17).EventEmitter;\n\n    var EElistenerCount = function EElistenerCount(emitter, type) {\n      return emitter.listeners(type).length;\n    };\n    /*</replacement>*/\n\n    /*<replacement>*/\n\n\n    var Stream = __webpack_require__(29);\n    /*</replacement>*/\n\n    /*<replacement>*/\n\n\n    var Buffer = __webpack_require__(24).Buffer;\n\n    var OurUint8Array = global.Uint8Array || function () {};\n\n    function _uint8ArrayToBuffer(chunk) {\n      return Buffer.from(chunk);\n    }\n\n    function _isUint8Array(obj) {\n      return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n    }\n    /*</replacement>*/\n\n    /*<replacement>*/\n\n\n    var util = Object.create(__webpack_require__(16));\n    util.inherits = __webpack_require__(12);\n    /*</replacement>*/\n\n    /*<replacement>*/\n\n    var debugUtil = __webpack_require__(46);\n\n    var debug = void 0;\n\n    if (debugUtil && debugUtil.debuglog) {\n      debug = debugUtil.debuglog('stream');\n    } else {\n      debug = function debug() {};\n    }\n    /*</replacement>*/\n\n\n    var BufferList = __webpack_require__(47);\n\n    var destroyImpl = __webpack_require__(31);\n\n    var StringDecoder;\n    util.inherits(Readable, Stream);\n    var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\n    function prependListener(emitter, event, fn) {\n      // Sadly this is not cacheable as some libraries bundle their own\n      // event emitter implementation with them.\n      if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n      // userland ones.  NEVER DO THIS. This is here only because this code needs\n      // to continue to work with older versions of Node.js that do not include\n      // the prependListener() method. The goal is to eventually remove this hack.\n\n      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n    }\n\n    function ReadableState(options, stream) {\n      Duplex = Duplex || __webpack_require__(11);\n      options = options || {}; // Duplex streams are both readable and writable, but share\n      // the same options object.\n      // However, some cases require setting options to different\n      // values for the readable and the writable sides of the duplex stream.\n      // These options can be provided separately as readableXXX and writableXXX.\n\n      var isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n      // make all the buffer merging and length checks go away\n\n      this.objectMode = !!options.objectMode;\n      if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n      // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n      var hwm = options.highWaterMark;\n      var readableHwm = options.readableHighWaterMark;\n      var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n      if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm; // cast to ints.\n\n      this.highWaterMark = Math.floor(this.highWaterMark); // A linked list is used to store data chunks instead of an array because the\n      // linked list can remove elements from the beginning faster than\n      // array.shift()\n\n      this.buffer = new BufferList();\n      this.length = 0;\n      this.pipes = null;\n      this.pipesCount = 0;\n      this.flowing = null;\n      this.ended = false;\n      this.endEmitted = false;\n      this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n      // immediately, or on a later tick.  We set this to true at first, because\n      // any actions that shouldn't happen until \"later\" should generally also\n      // not happen before the first read call.\n\n      this.sync = true; // whenever we return null, then we set a flag to say\n      // that we're awaiting a 'readable' event emission.\n\n      this.needReadable = false;\n      this.emittedReadable = false;\n      this.readableListening = false;\n      this.resumeScheduled = false; // has it been destroyed\n\n      this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n      // encoding is 'binary' so we have to make this configurable.\n      // Everything else in the universe uses 'utf8', though.\n\n      this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n      this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n      this.readingMore = false;\n      this.decoder = null;\n      this.encoding = null;\n\n      if (options.encoding) {\n        if (!StringDecoder) StringDecoder = __webpack_require__(32).StringDecoder;\n        this.decoder = new StringDecoder(options.encoding);\n        this.encoding = options.encoding;\n      }\n    }\n\n    function Readable(options) {\n      Duplex = Duplex || __webpack_require__(11);\n      if (!(this instanceof Readable)) return new Readable(options);\n      this._readableState = new ReadableState(options, this); // legacy\n\n      this.readable = true;\n\n      if (options) {\n        if (typeof options.read === 'function') this._read = options.read;\n        if (typeof options.destroy === 'function') this._destroy = options.destroy;\n      }\n\n      Stream.call(this);\n    }\n\n    Object.defineProperty(Readable.prototype, 'destroyed', {\n      get: function get() {\n        if (this._readableState === undefined) {\n          return false;\n        }\n\n        return this._readableState.destroyed;\n      },\n      set: function set(value) {\n        // we ignore the value if the stream\n        // has not been initialized yet\n        if (!this._readableState) {\n          return;\n        } // backward compatibility, the user is explicitly\n        // managing destroyed\n\n\n        this._readableState.destroyed = value;\n      }\n    });\n    Readable.prototype.destroy = destroyImpl.destroy;\n    Readable.prototype._undestroy = destroyImpl.undestroy;\n\n    Readable.prototype._destroy = function (err, cb) {\n      this.push(null);\n      cb(err);\n    }; // Manually shove something into the read() buffer.\n    // This returns true if the highWaterMark has not been hit yet,\n    // similar to how Writable.write() returns true if you should\n    // write() some more.\n\n\n    Readable.prototype.push = function (chunk, encoding) {\n      var state = this._readableState;\n      var skipChunkCheck;\n\n      if (!state.objectMode) {\n        if (typeof chunk === 'string') {\n          encoding = encoding || state.defaultEncoding;\n\n          if (encoding !== state.encoding) {\n            chunk = Buffer.from(chunk, encoding);\n            encoding = '';\n          }\n\n          skipChunkCheck = true;\n        }\n      } else {\n        skipChunkCheck = true;\n      }\n\n      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n    }; // Unshift should *always* be something directly out of read()\n\n\n    Readable.prototype.unshift = function (chunk) {\n      return readableAddChunk(this, chunk, null, true, false);\n    };\n\n    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n      var state = stream._readableState;\n\n      if (chunk === null) {\n        state.reading = false;\n        onEofChunk(stream, state);\n      } else {\n        var er;\n        if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n        if (er) {\n          stream.emit('error', er);\n        } else if (state.objectMode || chunk && chunk.length > 0) {\n          if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n            chunk = _uint8ArrayToBuffer(chunk);\n          }\n\n          if (addToFront) {\n            if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n          } else if (state.ended) {\n            stream.emit('error', new Error('stream.push() after EOF'));\n          } else {\n            state.reading = false;\n\n            if (state.decoder && !encoding) {\n              chunk = state.decoder.write(chunk);\n              if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n            } else {\n              addChunk(stream, state, chunk, false);\n            }\n          }\n        } else if (!addToFront) {\n          state.reading = false;\n        }\n      }\n\n      return needMoreData(state);\n    }\n\n    function addChunk(stream, state, chunk, addToFront) {\n      if (state.flowing && state.length === 0 && !state.sync) {\n        stream.emit('data', chunk);\n        stream.read(0);\n      } else {\n        // update the buffer info.\n        state.length += state.objectMode ? 1 : chunk.length;\n        if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n        if (state.needReadable) emitReadable(stream);\n      }\n\n      maybeReadMore(stream, state);\n    }\n\n    function chunkInvalid(state, chunk) {\n      var er;\n\n      if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n        er = new TypeError('Invalid non-string/buffer chunk');\n      }\n\n      return er;\n    } // if it's past the high water mark, we can push in some more.\n    // Also, if we have no data yet, we can stand some\n    // more bytes.  This is to work around cases where hwm=0,\n    // such as the repl.  Also, if the push() triggered a\n    // readable event, and the user called read(largeNumber) such that\n    // needReadable was set, then we ought to push more, so that another\n    // 'readable' event will be triggered.\n\n\n    function needMoreData(state) {\n      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n    }\n\n    Readable.prototype.isPaused = function () {\n      return this._readableState.flowing === false;\n    }; // backwards compatibility.\n\n\n    Readable.prototype.setEncoding = function (enc) {\n      if (!StringDecoder) StringDecoder = __webpack_require__(32).StringDecoder;\n      this._readableState.decoder = new StringDecoder(enc);\n      this._readableState.encoding = enc;\n      return this;\n    }; // Don't raise the hwm > 8MB\n\n\n    var MAX_HWM = 0x800000;\n\n    function computeNewHighWaterMark(n) {\n      if (n >= MAX_HWM) {\n        n = MAX_HWM;\n      } else {\n        // Get the next highest power of 2 to prevent increasing hwm excessively in\n        // tiny amounts\n        n--;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        n++;\n      }\n\n      return n;\n    } // This function is designed to be inlinable, so please take care when making\n    // changes to the function body.\n\n\n    function howMuchToRead(n, state) {\n      if (n <= 0 || state.length === 0 && state.ended) return 0;\n      if (state.objectMode) return 1;\n\n      if (n !== n) {\n        // Only flow one buffer at a time\n        if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n      } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n      if (n <= state.length) return n; // Don't have enough\n\n      if (!state.ended) {\n        state.needReadable = true;\n        return 0;\n      }\n\n      return state.length;\n    } // you can override either this method, or the async _read(n) below.\n\n\n    Readable.prototype.read = function (n) {\n      debug('read', n);\n      n = parseInt(n, 10);\n      var state = this._readableState;\n      var nOrig = n;\n      if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n      // already have a bunch of data in the buffer, then just trigger\n      // the 'readable' event and move on.\n\n      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n        debug('read: emitReadable', state.length, state.ended);\n        if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n        return null;\n      }\n\n      n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n      if (n === 0 && state.ended) {\n        if (state.length === 0) endReadable(this);\n        return null;\n      } // All the actual chunk generation logic needs to be\n      // *below* the call to _read.  The reason is that in certain\n      // synthetic stream cases, such as passthrough streams, _read\n      // may be a completely synchronous operation which may change\n      // the state of the read buffer, providing enough data when\n      // before there was *not* enough.\n      //\n      // So, the steps are:\n      // 1. Figure out what the state of things will be after we do\n      // a read from the buffer.\n      //\n      // 2. If that resulting state will trigger a _read, then call _read.\n      // Note that this may be asynchronous, or synchronous.  Yes, it is\n      // deeply ugly to write APIs this way, but that still doesn't mean\n      // that the Readable class should behave improperly, as streams are\n      // designed to be sync/async agnostic.\n      // Take note if the _read call is sync or async (ie, if the read call\n      // has returned yet), so that we know whether or not it's safe to emit\n      // 'readable' etc.\n      //\n      // 3. Actually pull the requested chunks out of the buffer and return.\n      // if we need a readable event, then we need to do some reading.\n\n\n      var doRead = state.needReadable;\n      debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n      if (state.length === 0 || state.length - n < state.highWaterMark) {\n        doRead = true;\n        debug('length less than watermark', doRead);\n      } // however, if we've ended, then there's no point, and if we're already\n      // reading, then it's unnecessary.\n\n\n      if (state.ended || state.reading) {\n        doRead = false;\n        debug('reading or ended', doRead);\n      } else if (doRead) {\n        debug('do read');\n        state.reading = true;\n        state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n        if (state.length === 0) state.needReadable = true; // call internal read method\n\n        this._read(state.highWaterMark);\n\n        state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n        // and we need to re-evaluate how much data we can return to the user.\n\n        if (!state.reading) n = howMuchToRead(nOrig, state);\n      }\n\n      var ret;\n      if (n > 0) ret = fromList(n, state);else ret = null;\n\n      if (ret === null) {\n        state.needReadable = true;\n        n = 0;\n      } else {\n        state.length -= n;\n      }\n\n      if (state.length === 0) {\n        // If we have nothing in the buffer, then we want to know\n        // as soon as we *do* get something into the buffer.\n        if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n        if (nOrig !== n && state.ended) endReadable(this);\n      }\n\n      if (ret !== null) this.emit('data', ret);\n      return ret;\n    };\n\n    function onEofChunk(stream, state) {\n      if (state.ended) return;\n\n      if (state.decoder) {\n        var chunk = state.decoder.end();\n\n        if (chunk && chunk.length) {\n          state.buffer.push(chunk);\n          state.length += state.objectMode ? 1 : chunk.length;\n        }\n      }\n\n      state.ended = true; // emit 'readable' now to make sure it gets picked up.\n\n      emitReadable(stream);\n    } // Don't emit readable right away in sync mode, because this can trigger\n    // another read() call => stack overflow.  This way, it might trigger\n    // a nextTick recursion warning, but that's not so bad.\n\n\n    function emitReadable(stream) {\n      var state = stream._readableState;\n      state.needReadable = false;\n\n      if (!state.emittedReadable) {\n        debug('emitReadable', state.flowing);\n        state.emittedReadable = true;\n        if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n      }\n    }\n\n    function emitReadable_(stream) {\n      debug('emit readable');\n      stream.emit('readable');\n      flow(stream);\n    } // at this point, the user has presumably seen the 'readable' event,\n    // and called read() to consume some data.  that may have triggered\n    // in turn another _read(n) call, in which case reading = true if\n    // it's in progress.\n    // However, if we're not ended, or reading, and the length < hwm,\n    // then go ahead and try to read some more preemptively.\n\n\n    function maybeReadMore(stream, state) {\n      if (!state.readingMore) {\n        state.readingMore = true;\n        pna.nextTick(maybeReadMore_, stream, state);\n      }\n    }\n\n    function maybeReadMore_(stream, state) {\n      var len = state.length;\n\n      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n        debug('maybeReadMore read 0');\n        stream.read(0);\n        if (len === state.length) // didn't get any data, stop spinning.\n          break;else len = state.length;\n      }\n\n      state.readingMore = false;\n    } // abstract method.  to be overridden in specific implementation classes.\n    // call cb(er, data) where data is <= n in length.\n    // for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n    // arbitrary, and perhaps not very meaningful.\n\n\n    Readable.prototype._read = function (n) {\n      this.emit('error', new Error('_read() is not implemented'));\n    };\n\n    Readable.prototype.pipe = function (dest, pipeOpts) {\n      var src = this;\n      var state = this._readableState;\n\n      switch (state.pipesCount) {\n        case 0:\n          state.pipes = dest;\n          break;\n\n        case 1:\n          state.pipes = [state.pipes, dest];\n          break;\n\n        default:\n          state.pipes.push(dest);\n          break;\n      }\n\n      state.pipesCount += 1;\n      debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n      var endFn = doEnd ? onend : unpipe;\n      if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n      dest.on('unpipe', onunpipe);\n\n      function onunpipe(readable, unpipeInfo) {\n        debug('onunpipe');\n\n        if (readable === src) {\n          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n            unpipeInfo.hasUnpiped = true;\n            cleanup();\n          }\n        }\n      }\n\n      function onend() {\n        debug('onend');\n        dest.end();\n      } // when the dest drains, it reduces the awaitDrain counter\n      // on the source.  This would be more elegant with a .once()\n      // handler in flow(), but adding and removing repeatedly is\n      // too slow.\n\n\n      var ondrain = pipeOnDrain(src);\n      dest.on('drain', ondrain);\n      var cleanedUp = false;\n\n      function cleanup() {\n        debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n        dest.removeListener('close', onclose);\n        dest.removeListener('finish', onfinish);\n        dest.removeListener('drain', ondrain);\n        dest.removeListener('error', onerror);\n        dest.removeListener('unpipe', onunpipe);\n        src.removeListener('end', onend);\n        src.removeListener('end', unpipe);\n        src.removeListener('data', ondata);\n        cleanedUp = true; // if the reader is waiting for a drain event from this\n        // specific writer, then it would cause it to never start\n        // flowing again.\n        // So, if this is awaiting a drain, then we just call it now.\n        // If we don't know, then assume that we are waiting for one.\n\n        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n      } // If the user pushes more data while we're writing to dest then we'll end up\n      // in ondata again. However, we only want to increase awaitDrain once because\n      // dest will only emit one 'drain' event for the multiple writes.\n      // => Introduce a guard on increasing awaitDrain.\n\n\n      var increasedAwaitDrain = false;\n      src.on('data', ondata);\n\n      function ondata(chunk) {\n        debug('ondata');\n        increasedAwaitDrain = false;\n        var ret = dest.write(chunk);\n\n        if (false === ret && !increasedAwaitDrain) {\n          // If the user unpiped during `dest.write()`, it is possible\n          // to get stuck in a permanently paused state if that write\n          // also returned false.\n          // => Check whether `dest` is still a piping destination.\n          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n            debug('false write response, pause', src._readableState.awaitDrain);\n            src._readableState.awaitDrain++;\n            increasedAwaitDrain = true;\n          }\n\n          src.pause();\n        }\n      } // if the dest has an error, then stop piping into it.\n      // however, don't suppress the throwing behavior for this.\n\n\n      function onerror(er) {\n        debug('onerror', er);\n        unpipe();\n        dest.removeListener('error', onerror);\n        if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n      } // Make sure our error handler is attached before userland ones.\n\n\n      prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n      function onclose() {\n        dest.removeListener('finish', onfinish);\n        unpipe();\n      }\n\n      dest.once('close', onclose);\n\n      function onfinish() {\n        debug('onfinish');\n        dest.removeListener('close', onclose);\n        unpipe();\n      }\n\n      dest.once('finish', onfinish);\n\n      function unpipe() {\n        debug('unpipe');\n        src.unpipe(dest);\n      } // tell the dest that it's being piped to\n\n\n      dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n      if (!state.flowing) {\n        debug('pipe resume');\n        src.resume();\n      }\n\n      return dest;\n    };\n\n    function pipeOnDrain(src) {\n      return function () {\n        var state = src._readableState;\n        debug('pipeOnDrain', state.awaitDrain);\n        if (state.awaitDrain) state.awaitDrain--;\n\n        if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n          state.flowing = true;\n          flow(src);\n        }\n      };\n    }\n\n    Readable.prototype.unpipe = function (dest) {\n      var state = this._readableState;\n      var unpipeInfo = {\n        hasUnpiped: false\n      }; // if we're not piping anywhere, then do nothing.\n\n      if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n      if (state.pipesCount === 1) {\n        // passed in one, but it's not the right one.\n        if (dest && dest !== state.pipes) return this;\n        if (!dest) dest = state.pipes; // got a match.\n\n        state.pipes = null;\n        state.pipesCount = 0;\n        state.flowing = false;\n        if (dest) dest.emit('unpipe', this, unpipeInfo);\n        return this;\n      } // slow case. multiple pipe destinations.\n\n\n      if (!dest) {\n        // remove all.\n        var dests = state.pipes;\n        var len = state.pipesCount;\n        state.pipes = null;\n        state.pipesCount = 0;\n        state.flowing = false;\n\n        for (var i = 0; i < len; i++) {\n          dests[i].emit('unpipe', this, unpipeInfo);\n        }\n\n        return this;\n      } // try to find the right one.\n\n\n      var index = indexOf(state.pipes, dest);\n      if (index === -1) return this;\n      state.pipes.splice(index, 1);\n      state.pipesCount -= 1;\n      if (state.pipesCount === 1) state.pipes = state.pipes[0];\n      dest.emit('unpipe', this, unpipeInfo);\n      return this;\n    }; // set up data events if they are asked for\n    // Ensure readable listeners eventually get something\n\n\n    Readable.prototype.on = function (ev, fn) {\n      var res = Stream.prototype.on.call(this, ev, fn);\n\n      if (ev === 'data') {\n        // Start flowing on next tick if stream isn't explicitly paused\n        if (this._readableState.flowing !== false) this.resume();\n      } else if (ev === 'readable') {\n        var state = this._readableState;\n\n        if (!state.endEmitted && !state.readableListening) {\n          state.readableListening = state.needReadable = true;\n          state.emittedReadable = false;\n\n          if (!state.reading) {\n            pna.nextTick(nReadingNextTick, this);\n          } else if (state.length) {\n            emitReadable(this);\n          }\n        }\n      }\n\n      return res;\n    };\n\n    Readable.prototype.addListener = Readable.prototype.on;\n\n    function nReadingNextTick(self) {\n      debug('readable nexttick read 0');\n      self.read(0);\n    } // pause() and resume() are remnants of the legacy readable stream API\n    // If the user uses them, then switch into old mode.\n\n\n    Readable.prototype.resume = function () {\n      var state = this._readableState;\n\n      if (!state.flowing) {\n        debug('resume');\n        state.flowing = true;\n        resume(this, state);\n      }\n\n      return this;\n    };\n\n    function resume(stream, state) {\n      if (!state.resumeScheduled) {\n        state.resumeScheduled = true;\n        pna.nextTick(resume_, stream, state);\n      }\n    }\n\n    function resume_(stream, state) {\n      if (!state.reading) {\n        debug('resume read 0');\n        stream.read(0);\n      }\n\n      state.resumeScheduled = false;\n      state.awaitDrain = 0;\n      stream.emit('resume');\n      flow(stream);\n      if (state.flowing && !state.reading) stream.read(0);\n    }\n\n    Readable.prototype.pause = function () {\n      debug('call pause flowing=%j', this._readableState.flowing);\n\n      if (false !== this._readableState.flowing) {\n        debug('pause');\n        this._readableState.flowing = false;\n        this.emit('pause');\n      }\n\n      return this;\n    };\n\n    function flow(stream) {\n      var state = stream._readableState;\n      debug('flow', state.flowing);\n\n      while (state.flowing && stream.read() !== null) {}\n    } // wrap an old-style stream as the async data source.\n    // This is *not* part of the readable stream interface.\n    // It is an ugly unfortunate mess of history.\n\n\n    Readable.prototype.wrap = function (stream) {\n      var _this = this;\n\n      var state = this._readableState;\n      var paused = false;\n      stream.on('end', function () {\n        debug('wrapped end');\n\n        if (state.decoder && !state.ended) {\n          var chunk = state.decoder.end();\n          if (chunk && chunk.length) _this.push(chunk);\n        }\n\n        _this.push(null);\n      });\n      stream.on('data', function (chunk) {\n        debug('wrapped data');\n        if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n        if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n        var ret = _this.push(chunk);\n\n        if (!ret) {\n          paused = true;\n          stream.pause();\n        }\n      }); // proxy all the other methods.\n      // important when wrapping filters and duplexes.\n\n      for (var i in stream) {\n        if (this[i] === undefined && typeof stream[i] === 'function') {\n          this[i] = function (method) {\n            return function () {\n              return stream[method].apply(stream, arguments);\n            };\n          }(i);\n        }\n      } // proxy certain important events.\n\n\n      for (var n = 0; n < kProxyEvents.length; n++) {\n        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n      } // when we try to consume some more bytes, simply unpause the\n      // underlying stream.\n\n\n      this._read = function (n) {\n        debug('wrapped _read', n);\n\n        if (paused) {\n          paused = false;\n          stream.resume();\n        }\n      };\n\n      return this;\n    };\n\n    Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n      // making it explicit this property is not enumerable\n      // because otherwise some prototype manipulation in\n      // userland will fail\n      enumerable: false,\n      get: function get() {\n        return this._readableState.highWaterMark;\n      }\n    }); // exposed for testing purposes only.\n\n    Readable._fromList = fromList; // Pluck off n bytes from an array of buffers.\n    // Length is the combined lengths of all the buffers in the list.\n    // This function is designed to be inlinable, so please take care when making\n    // changes to the function body.\n\n    function fromList(n, state) {\n      // nothing buffered\n      if (state.length === 0) return null;\n      var ret;\n      if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n        // read it all, truncate the list\n        if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n        state.buffer.clear();\n      } else {\n        // read part of list\n        ret = fromListPartial(n, state.buffer, state.decoder);\n      }\n      return ret;\n    } // Extracts only enough buffered data to satisfy the amount requested.\n    // This function is designed to be inlinable, so please take care when making\n    // changes to the function body.\n\n\n    function fromListPartial(n, list, hasStrings) {\n      var ret;\n\n      if (n < list.head.data.length) {\n        // slice is the same for buffers and strings\n        ret = list.head.data.slice(0, n);\n        list.head.data = list.head.data.slice(n);\n      } else if (n === list.head.data.length) {\n        // first chunk is a perfect match\n        ret = list.shift();\n      } else {\n        // result spans more than one buffer\n        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n      }\n\n      return ret;\n    } // Copies a specified amount of characters from the list of buffered data\n    // chunks.\n    // This function is designed to be inlinable, so please take care when making\n    // changes to the function body.\n\n\n    function copyFromBufferString(n, list) {\n      var p = list.head;\n      var c = 1;\n      var ret = p.data;\n      n -= ret.length;\n\n      while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === str.length) {\n            ++c;\n            if (p.next) list.head = p.next;else list.head = list.tail = null;\n          } else {\n            list.head = p;\n            p.data = str.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      list.length -= c;\n      return ret;\n    } // Copies a specified amount of bytes from the list of buffered data chunks.\n    // This function is designed to be inlinable, so please take care when making\n    // changes to the function body.\n\n\n    function copyFromBuffer(n, list) {\n      var ret = Buffer.allocUnsafe(n);\n      var p = list.head;\n      var c = 1;\n      p.data.copy(ret);\n      n -= p.data.length;\n\n      while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === buf.length) {\n            ++c;\n            if (p.next) list.head = p.next;else list.head = list.tail = null;\n          } else {\n            list.head = p;\n            p.data = buf.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      list.length -= c;\n      return ret;\n    }\n\n    function endReadable(stream) {\n      var state = stream._readableState; // If we get here before consuming all the bytes, then that is a\n      // bug in node.  Should never happen.\n\n      if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n      if (!state.endEmitted) {\n        state.ended = true;\n        pna.nextTick(endReadableNT, state, stream);\n      }\n    }\n\n    function endReadableNT(state, stream) {\n      // Check that we didn't get one last unshift.\n      if (!state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.readable = false;\n        stream.emit('end');\n      }\n    }\n\n    function indexOf(xs, x) {\n      for (var i = 0, l = xs.length; i < l; i++) {\n        if (xs[i] === x) return i;\n      }\n\n      return -1;\n    }\n    /* WEBPACK VAR INJECTION */\n\n  }).call(this, __webpack_require__(13), __webpack_require__(19));\n  /***/\n},\n/* 28 */\n\n/***/\nfunction (module, exports) {\n  var toString = {}.toString;\n\n  module.exports = Array.isArray || function (arr) {\n    return toString.call(arr) == '[object Array]';\n  };\n  /***/\n\n},\n/* 29 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  module.exports = __webpack_require__(17).EventEmitter;\n  /***/\n},\n/* 30 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n  /* WEBPACK VAR INJECTION */\n\n  (function (global) {\n    /*!\n    * The buffer module from node.js, for the browser.\n    *\n    * @author   Feross Aboukhadijeh <http://feross.org>\n    * @license  MIT\n    */\n\n    /* eslint-disable no-proto */\n    var base64 = __webpack_require__(44);\n\n    var ieee754 = __webpack_require__(45);\n\n    var isArray = __webpack_require__(28);\n\n    exports.Buffer = Buffer;\n    exports.SlowBuffer = SlowBuffer;\n    exports.INSPECT_MAX_BYTES = 50;\n    /**\n     * If `Buffer.TYPED_ARRAY_SUPPORT`:\n     *   === true    Use Uint8Array implementation (fastest)\n     *   === false   Use Object implementation (most compatible, even IE6)\n     *\n     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n     * Opera 11.6+, iOS 4.2+.\n     *\n     * Due to various browser bugs, sometimes the Object implementation will be used even\n     * when the browser supports typed arrays.\n     *\n     * Note:\n     *\n     *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n     *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n     *\n     *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n     *\n     *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n     *     incorrect length in some situations.\n    \n     * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n     * get the Object implementation, which is slower but behaves correctly.\n     */\n\n    Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();\n    /*\n     * Export kMaxLength after typed array support is determined.\n     */\n\n    exports.kMaxLength = kMaxLength();\n\n    function typedArraySupport() {\n      try {\n        var arr = new Uint8Array(1);\n        arr.__proto__ = {\n          __proto__: Uint8Array.prototype,\n          foo: function foo() {\n            return 42;\n          }\n        };\n        return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`\n      } catch (e) {\n        return false;\n      }\n    }\n\n    function kMaxLength() {\n      return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;\n    }\n\n    function createBuffer(that, length) {\n      if (kMaxLength() < length) {\n        throw new RangeError('Invalid typed array length');\n      }\n\n      if (Buffer.TYPED_ARRAY_SUPPORT) {\n        // Return an augmented `Uint8Array` instance, for best performance\n        that = new Uint8Array(length);\n        that.__proto__ = Buffer.prototype;\n      } else {\n        // Fallback: Return an object instance of the Buffer class\n        if (that === null) {\n          that = new Buffer(length);\n        }\n\n        that.length = length;\n      }\n\n      return that;\n    }\n    /**\n     * The Buffer constructor returns instances of `Uint8Array` that have their\n     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n     * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n     * returns a single octet.\n     *\n     * The `Uint8Array` prototype remains unmodified.\n     */\n\n\n    function Buffer(arg, encodingOrOffset, length) {\n      if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n        return new Buffer(arg, encodingOrOffset, length);\n      } // Common case.\n\n\n      if (typeof arg === 'number') {\n        if (typeof encodingOrOffset === 'string') {\n          throw new Error('If encoding is specified then the first argument must be a string');\n        }\n\n        return allocUnsafe(this, arg);\n      }\n\n      return from(this, arg, encodingOrOffset, length);\n    }\n\n    Buffer.poolSize = 8192; // not used by this implementation\n    // TODO: Legacy, not needed anymore. Remove in next major version.\n\n    Buffer._augment = function (arr) {\n      arr.__proto__ = Buffer.prototype;\n      return arr;\n    };\n\n    function from(that, value, encodingOrOffset, length) {\n      if (typeof value === 'number') {\n        throw new TypeError('\"value\" argument must not be a number');\n      }\n\n      if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n        return fromArrayBuffer(that, value, encodingOrOffset, length);\n      }\n\n      if (typeof value === 'string') {\n        return fromString(that, value, encodingOrOffset);\n      }\n\n      return fromObject(that, value);\n    }\n    /**\n     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n     * if value is a number.\n     * Buffer.from(str[, encoding])\n     * Buffer.from(array)\n     * Buffer.from(buffer)\n     * Buffer.from(arrayBuffer[, byteOffset[, length]])\n     **/\n\n\n    Buffer.from = function (value, encodingOrOffset, length) {\n      return from(null, value, encodingOrOffset, length);\n    };\n\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      Buffer.prototype.__proto__ = Uint8Array.prototype;\n      Buffer.__proto__ = Uint8Array;\n\n      if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {\n        // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n        Object.defineProperty(Buffer, Symbol.species, {\n          value: null,\n          configurable: true\n        });\n      }\n    }\n\n    function assertSize(size) {\n      if (typeof size !== 'number') {\n        throw new TypeError('\"size\" argument must be a number');\n      } else if (size < 0) {\n        throw new RangeError('\"size\" argument must not be negative');\n      }\n    }\n\n    function alloc(that, size, fill, encoding) {\n      assertSize(size);\n\n      if (size <= 0) {\n        return createBuffer(that, size);\n      }\n\n      if (fill !== undefined) {\n        // Only pay attention to encoding if it's a string. This\n        // prevents accidentally sending in a number that would\n        // be interpretted as a start offset.\n        return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);\n      }\n\n      return createBuffer(that, size);\n    }\n    /**\n     * Creates a new filled Buffer instance.\n     * alloc(size[, fill[, encoding]])\n     **/\n\n\n    Buffer.alloc = function (size, fill, encoding) {\n      return alloc(null, size, fill, encoding);\n    };\n\n    function allocUnsafe(that, size) {\n      assertSize(size);\n      that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n\n      if (!Buffer.TYPED_ARRAY_SUPPORT) {\n        for (var i = 0; i < size; ++i) {\n          that[i] = 0;\n        }\n      }\n\n      return that;\n    }\n    /**\n     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n     * */\n\n\n    Buffer.allocUnsafe = function (size) {\n      return allocUnsafe(null, size);\n    };\n    /**\n     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n     */\n\n\n    Buffer.allocUnsafeSlow = function (size) {\n      return allocUnsafe(null, size);\n    };\n\n    function fromString(that, string, encoding) {\n      if (typeof encoding !== 'string' || encoding === '') {\n        encoding = 'utf8';\n      }\n\n      if (!Buffer.isEncoding(encoding)) {\n        throw new TypeError('\"encoding\" must be a valid string encoding');\n      }\n\n      var length = byteLength(string, encoding) | 0;\n      that = createBuffer(that, length);\n      var actual = that.write(string, encoding);\n\n      if (actual !== length) {\n        // Writing a hex string, for example, that contains invalid characters will\n        // cause everything after the first invalid character to be ignored. (e.g.\n        // 'abxxcd' will be treated as 'ab')\n        that = that.slice(0, actual);\n      }\n\n      return that;\n    }\n\n    function fromArrayLike(that, array) {\n      var length = array.length < 0 ? 0 : checked(array.length) | 0;\n      that = createBuffer(that, length);\n\n      for (var i = 0; i < length; i += 1) {\n        that[i] = array[i] & 255;\n      }\n\n      return that;\n    }\n\n    function fromArrayBuffer(that, array, byteOffset, length) {\n      array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n\n      if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError('\\'offset\\' is out of bounds');\n      }\n\n      if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError('\\'length\\' is out of bounds');\n      }\n\n      if (byteOffset === undefined && length === undefined) {\n        array = new Uint8Array(array);\n      } else if (length === undefined) {\n        array = new Uint8Array(array, byteOffset);\n      } else {\n        array = new Uint8Array(array, byteOffset, length);\n      }\n\n      if (Buffer.TYPED_ARRAY_SUPPORT) {\n        // Return an augmented `Uint8Array` instance, for best performance\n        that = array;\n        that.__proto__ = Buffer.prototype;\n      } else {\n        // Fallback: Return an object instance of the Buffer class\n        that = fromArrayLike(that, array);\n      }\n\n      return that;\n    }\n\n    function fromObject(that, obj) {\n      if (Buffer.isBuffer(obj)) {\n        var len = checked(obj.length) | 0;\n        that = createBuffer(that, len);\n\n        if (that.length === 0) {\n          return that;\n        }\n\n        obj.copy(that, 0, 0, len);\n        return that;\n      }\n\n      if (obj) {\n        if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {\n          if (typeof obj.length !== 'number' || isnan(obj.length)) {\n            return createBuffer(that, 0);\n          }\n\n          return fromArrayLike(that, obj);\n        }\n\n        if (obj.type === 'Buffer' && isArray(obj.data)) {\n          return fromArrayLike(that, obj.data);\n        }\n      }\n\n      throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');\n    }\n\n    function checked(length) {\n      // Note: cannot use `length < kMaxLength()` here because that fails when\n      // length is NaN (which is otherwise coerced to zero.)\n      if (length >= kMaxLength()) {\n        throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');\n      }\n\n      return length | 0;\n    }\n\n    function SlowBuffer(length) {\n      if (+length != length) {\n        // eslint-disable-line eqeqeq\n        length = 0;\n      }\n\n      return Buffer.alloc(+length);\n    }\n\n    Buffer.isBuffer = function isBuffer(b) {\n      return !!(b != null && b._isBuffer);\n    };\n\n    Buffer.compare = function compare(a, b) {\n      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n        throw new TypeError('Arguments must be Buffers');\n      }\n\n      if (a === b) return 0;\n      var x = a.length;\n      var y = b.length;\n\n      for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n        if (a[i] !== b[i]) {\n          x = a[i];\n          y = b[i];\n          break;\n        }\n      }\n\n      if (x < y) return -1;\n      if (y < x) return 1;\n      return 0;\n    };\n\n    Buffer.isEncoding = function isEncoding(encoding) {\n      switch (String(encoding).toLowerCase()) {\n        case 'hex':\n        case 'utf8':\n        case 'utf-8':\n        case 'ascii':\n        case 'latin1':\n        case 'binary':\n        case 'base64':\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n          return true;\n\n        default:\n          return false;\n      }\n    };\n\n    Buffer.concat = function concat(list, length) {\n      if (!isArray(list)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n      }\n\n      if (list.length === 0) {\n        return Buffer.alloc(0);\n      }\n\n      var i;\n\n      if (length === undefined) {\n        length = 0;\n\n        for (i = 0; i < list.length; ++i) {\n          length += list[i].length;\n        }\n      }\n\n      var buffer = Buffer.allocUnsafe(length);\n      var pos = 0;\n\n      for (i = 0; i < list.length; ++i) {\n        var buf = list[i];\n\n        if (!Buffer.isBuffer(buf)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n\n        buf.copy(buffer, pos);\n        pos += buf.length;\n      }\n\n      return buffer;\n    };\n\n    function byteLength(string, encoding) {\n      if (Buffer.isBuffer(string)) {\n        return string.length;\n      }\n\n      if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n        return string.byteLength;\n      }\n\n      if (typeof string !== 'string') {\n        string = '' + string;\n      }\n\n      var len = string.length;\n      if (len === 0) return 0; // Use a for loop to avoid recursion\n\n      var loweredCase = false;\n\n      for (;;) {\n        switch (encoding) {\n          case 'ascii':\n          case 'latin1':\n          case 'binary':\n            return len;\n\n          case 'utf8':\n          case 'utf-8':\n          case undefined:\n            return utf8ToBytes(string).length;\n\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n            return len * 2;\n\n          case 'hex':\n            return len >>> 1;\n\n          case 'base64':\n            return base64ToBytes(string).length;\n\n          default:\n            if (loweredCase) return utf8ToBytes(string).length; // assume utf8\n\n            encoding = ('' + encoding).toLowerCase();\n            loweredCase = true;\n        }\n      }\n    }\n\n    Buffer.byteLength = byteLength;\n\n    function slowToString(encoding, start, end) {\n      var loweredCase = false; // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n      // property of a typed array.\n      // This behaves neither like String nor Uint8Array in that we set start/end\n      // to their upper/lower bounds if the value passed is out of range.\n      // undefined is handled specially as per ECMA-262 6th Edition,\n      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\n      if (start === undefined || start < 0) {\n        start = 0;\n      } // Return early if start > this.length. Done here to prevent potential uint32\n      // coercion fail below.\n\n\n      if (start > this.length) {\n        return '';\n      }\n\n      if (end === undefined || end > this.length) {\n        end = this.length;\n      }\n\n      if (end <= 0) {\n        return '';\n      } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n\n\n      end >>>= 0;\n      start >>>= 0;\n\n      if (end <= start) {\n        return '';\n      }\n\n      if (!encoding) encoding = 'utf8';\n\n      while (true) {\n        switch (encoding) {\n          case 'hex':\n            return hexSlice(this, start, end);\n\n          case 'utf8':\n          case 'utf-8':\n            return utf8Slice(this, start, end);\n\n          case 'ascii':\n            return asciiSlice(this, start, end);\n\n          case 'latin1':\n          case 'binary':\n            return latin1Slice(this, start, end);\n\n          case 'base64':\n            return base64Slice(this, start, end);\n\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n            return utf16leSlice(this, start, end);\n\n          default:\n            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n            encoding = (encoding + '').toLowerCase();\n            loweredCase = true;\n        }\n      }\n    } // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n    // Buffer instances.\n\n\n    Buffer.prototype._isBuffer = true;\n\n    function swap(b, n, m) {\n      var i = b[n];\n      b[n] = b[m];\n      b[m] = i;\n    }\n\n    Buffer.prototype.swap16 = function swap16() {\n      var len = this.length;\n\n      if (len % 2 !== 0) {\n        throw new RangeError('Buffer size must be a multiple of 16-bits');\n      }\n\n      for (var i = 0; i < len; i += 2) {\n        swap(this, i, i + 1);\n      }\n\n      return this;\n    };\n\n    Buffer.prototype.swap32 = function swap32() {\n      var len = this.length;\n\n      if (len % 4 !== 0) {\n        throw new RangeError('Buffer size must be a multiple of 32-bits');\n      }\n\n      for (var i = 0; i < len; i += 4) {\n        swap(this, i, i + 3);\n        swap(this, i + 1, i + 2);\n      }\n\n      return this;\n    };\n\n    Buffer.prototype.swap64 = function swap64() {\n      var len = this.length;\n\n      if (len % 8 !== 0) {\n        throw new RangeError('Buffer size must be a multiple of 64-bits');\n      }\n\n      for (var i = 0; i < len; i += 8) {\n        swap(this, i, i + 7);\n        swap(this, i + 1, i + 6);\n        swap(this, i + 2, i + 5);\n        swap(this, i + 3, i + 4);\n      }\n\n      return this;\n    };\n\n    Buffer.prototype.toString = function toString() {\n      var length = this.length | 0;\n      if (length === 0) return '';\n      if (arguments.length === 0) return utf8Slice(this, 0, length);\n      return slowToString.apply(this, arguments);\n    };\n\n    Buffer.prototype.equals = function equals(b) {\n      if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');\n      if (this === b) return true;\n      return Buffer.compare(this, b) === 0;\n    };\n\n    Buffer.prototype.inspect = function inspect() {\n      var str = '';\n      var max = exports.INSPECT_MAX_BYTES;\n\n      if (this.length > 0) {\n        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n        if (this.length > max) str += ' ... ';\n      }\n\n      return '<Buffer ' + str + '>';\n    };\n\n    Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n      if (!Buffer.isBuffer(target)) {\n        throw new TypeError('Argument must be a Buffer');\n      }\n\n      if (start === undefined) {\n        start = 0;\n      }\n\n      if (end === undefined) {\n        end = target ? target.length : 0;\n      }\n\n      if (thisStart === undefined) {\n        thisStart = 0;\n      }\n\n      if (thisEnd === undefined) {\n        thisEnd = this.length;\n      }\n\n      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n        throw new RangeError('out of range index');\n      }\n\n      if (thisStart >= thisEnd && start >= end) {\n        return 0;\n      }\n\n      if (thisStart >= thisEnd) {\n        return -1;\n      }\n\n      if (start >= end) {\n        return 1;\n      }\n\n      start >>>= 0;\n      end >>>= 0;\n      thisStart >>>= 0;\n      thisEnd >>>= 0;\n      if (this === target) return 0;\n      var x = thisEnd - thisStart;\n      var y = end - start;\n      var len = Math.min(x, y);\n      var thisCopy = this.slice(thisStart, thisEnd);\n      var targetCopy = target.slice(start, end);\n\n      for (var i = 0; i < len; ++i) {\n        if (thisCopy[i] !== targetCopy[i]) {\n          x = thisCopy[i];\n          y = targetCopy[i];\n          break;\n        }\n      }\n\n      if (x < y) return -1;\n      if (y < x) return 1;\n      return 0;\n    }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n    //\n    // Arguments:\n    // - buffer - a Buffer to search\n    // - val - a string, Buffer, or number\n    // - byteOffset - an index into `buffer`; will be clamped to an int32\n    // - encoding - an optional encoding, relevant is val is a string\n    // - dir - true for indexOf, false for lastIndexOf\n\n\n    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n      // Empty buffer means no match\n      if (buffer.length === 0) return -1; // Normalize byteOffset\n\n      if (typeof byteOffset === 'string') {\n        encoding = byteOffset;\n        byteOffset = 0;\n      } else if (byteOffset > 0x7fffffff) {\n        byteOffset = 0x7fffffff;\n      } else if (byteOffset < -0x80000000) {\n        byteOffset = -0x80000000;\n      }\n\n      byteOffset = +byteOffset; // Coerce to Number.\n\n      if (isNaN(byteOffset)) {\n        // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n        byteOffset = dir ? 0 : buffer.length - 1;\n      } // Normalize byteOffset: negative offsets start from the end of the buffer\n\n\n      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n\n      if (byteOffset >= buffer.length) {\n        if (dir) return -1;else byteOffset = buffer.length - 1;\n      } else if (byteOffset < 0) {\n        if (dir) byteOffset = 0;else return -1;\n      } // Normalize val\n\n\n      if (typeof val === 'string') {\n        val = Buffer.from(val, encoding);\n      } // Finally, search either indexOf (if dir is true) or lastIndexOf\n\n\n      if (Buffer.isBuffer(val)) {\n        // Special case: looking for empty string/buffer always fails\n        if (val.length === 0) {\n          return -1;\n        }\n\n        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n      } else if (typeof val === 'number') {\n        val = val & 0xFF; // Search for a byte value [0-255]\n\n        if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {\n          if (dir) {\n            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n          } else {\n            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n          }\n        }\n\n        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n      }\n\n      throw new TypeError('val must be string, number or Buffer');\n    }\n\n    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n      var indexSize = 1;\n      var arrLength = arr.length;\n      var valLength = val.length;\n\n      if (encoding !== undefined) {\n        encoding = String(encoding).toLowerCase();\n\n        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {\n          if (arr.length < 2 || val.length < 2) {\n            return -1;\n          }\n\n          indexSize = 2;\n          arrLength /= 2;\n          valLength /= 2;\n          byteOffset /= 2;\n        }\n      }\n\n      function read(buf, i) {\n        if (indexSize === 1) {\n          return buf[i];\n        } else {\n          return buf.readUInt16BE(i * indexSize);\n        }\n      }\n\n      var i;\n\n      if (dir) {\n        var foundIndex = -1;\n\n        for (i = byteOffset; i < arrLength; i++) {\n          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n            if (foundIndex === -1) foundIndex = i;\n            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n          } else {\n            if (foundIndex !== -1) i -= i - foundIndex;\n            foundIndex = -1;\n          }\n        }\n      } else {\n        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n\n        for (i = byteOffset; i >= 0; i--) {\n          var found = true;\n\n          for (var j = 0; j < valLength; j++) {\n            if (read(arr, i + j) !== read(val, j)) {\n              found = false;\n              break;\n            }\n          }\n\n          if (found) return i;\n        }\n      }\n\n      return -1;\n    }\n\n    Buffer.prototype.includes = function includes(val, byteOffset, encoding) {\n      return this.indexOf(val, byteOffset, encoding) !== -1;\n    };\n\n    Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n    };\n\n    Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n    };\n\n    function hexWrite(buf, string, offset, length) {\n      offset = Number(offset) || 0;\n      var remaining = buf.length - offset;\n\n      if (!length) {\n        length = remaining;\n      } else {\n        length = Number(length);\n\n        if (length > remaining) {\n          length = remaining;\n        }\n      } // must be an even number of digits\n\n\n      var strLen = string.length;\n      if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');\n\n      if (length > strLen / 2) {\n        length = strLen / 2;\n      }\n\n      for (var i = 0; i < length; ++i) {\n        var parsed = parseInt(string.substr(i * 2, 2), 16);\n        if (isNaN(parsed)) return i;\n        buf[offset + i] = parsed;\n      }\n\n      return i;\n    }\n\n    function utf8Write(buf, string, offset, length) {\n      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n    }\n\n    function asciiWrite(buf, string, offset, length) {\n      return blitBuffer(asciiToBytes(string), buf, offset, length);\n    }\n\n    function latin1Write(buf, string, offset, length) {\n      return asciiWrite(buf, string, offset, length);\n    }\n\n    function base64Write(buf, string, offset, length) {\n      return blitBuffer(base64ToBytes(string), buf, offset, length);\n    }\n\n    function ucs2Write(buf, string, offset, length) {\n      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n    }\n\n    Buffer.prototype.write = function write(string, offset, length, encoding) {\n      // Buffer#write(string)\n      if (offset === undefined) {\n        encoding = 'utf8';\n        length = this.length;\n        offset = 0; // Buffer#write(string, encoding)\n      } else if (length === undefined && typeof offset === 'string') {\n        encoding = offset;\n        length = this.length;\n        offset = 0; // Buffer#write(string, offset[, length][, encoding])\n      } else if (isFinite(offset)) {\n        offset = offset | 0;\n\n        if (isFinite(length)) {\n          length = length | 0;\n          if (encoding === undefined) encoding = 'utf8';\n        } else {\n          encoding = length;\n          length = undefined;\n        } // legacy write(string, encoding, offset, length) - remove in v0.13\n\n      } else {\n        throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n      }\n\n      var remaining = this.length - offset;\n      if (length === undefined || length > remaining) length = remaining;\n\n      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n        throw new RangeError('Attempt to write outside buffer bounds');\n      }\n\n      if (!encoding) encoding = 'utf8';\n      var loweredCase = false;\n\n      for (;;) {\n        switch (encoding) {\n          case 'hex':\n            return hexWrite(this, string, offset, length);\n\n          case 'utf8':\n          case 'utf-8':\n            return utf8Write(this, string, offset, length);\n\n          case 'ascii':\n            return asciiWrite(this, string, offset, length);\n\n          case 'latin1':\n          case 'binary':\n            return latin1Write(this, string, offset, length);\n\n          case 'base64':\n            // Warning: maxLength not taken into account in base64Write\n            return base64Write(this, string, offset, length);\n\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n            return ucs2Write(this, string, offset, length);\n\n          default:\n            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n            encoding = ('' + encoding).toLowerCase();\n            loweredCase = true;\n        }\n      }\n    };\n\n    Buffer.prototype.toJSON = function toJSON() {\n      return {\n        type: 'Buffer',\n        data: Array.prototype.slice.call(this._arr || this, 0)\n      };\n    };\n\n    function base64Slice(buf, start, end) {\n      if (start === 0 && end === buf.length) {\n        return base64.fromByteArray(buf);\n      } else {\n        return base64.fromByteArray(buf.slice(start, end));\n      }\n    }\n\n    function utf8Slice(buf, start, end) {\n      end = Math.min(buf.length, end);\n      var res = [];\n      var i = start;\n\n      while (i < end) {\n        var firstByte = buf[i];\n        var codePoint = null;\n        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n\n        if (i + bytesPerSequence <= end) {\n          var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n          switch (bytesPerSequence) {\n            case 1:\n              if (firstByte < 0x80) {\n                codePoint = firstByte;\n              }\n\n              break;\n\n            case 2:\n              secondByte = buf[i + 1];\n\n              if ((secondByte & 0xC0) === 0x80) {\n                tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n\n                if (tempCodePoint > 0x7F) {\n                  codePoint = tempCodePoint;\n                }\n              }\n\n              break;\n\n            case 3:\n              secondByte = buf[i + 1];\n              thirdByte = buf[i + 2];\n\n              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n\n                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n                  codePoint = tempCodePoint;\n                }\n              }\n\n              break;\n\n            case 4:\n              secondByte = buf[i + 1];\n              thirdByte = buf[i + 2];\n              fourthByte = buf[i + 3];\n\n              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n\n                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n                  codePoint = tempCodePoint;\n                }\n              }\n\n          }\n        }\n\n        if (codePoint === null) {\n          // we did not generate a valid codePoint so insert a\n          // replacement char (U+FFFD) and advance only 1 byte\n          codePoint = 0xFFFD;\n          bytesPerSequence = 1;\n        } else if (codePoint > 0xFFFF) {\n          // encode to utf16 (surrogate pair dance)\n          codePoint -= 0x10000;\n          res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n          codePoint = 0xDC00 | codePoint & 0x3FF;\n        }\n\n        res.push(codePoint);\n        i += bytesPerSequence;\n      }\n\n      return decodeCodePointsArray(res);\n    } // Based on http://stackoverflow.com/a/22747272/680742, the browser with\n    // the lowest limit is Chrome, with 0x10000 args.\n    // We go 1 magnitude less, for safety\n\n\n    var MAX_ARGUMENTS_LENGTH = 0x1000;\n\n    function decodeCodePointsArray(codePoints) {\n      var len = codePoints.length;\n\n      if (len <= MAX_ARGUMENTS_LENGTH) {\n        return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n      } // Decode in chunks to avoid \"call stack size exceeded\".\n\n\n      var res = '';\n      var i = 0;\n\n      while (i < len) {\n        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n      }\n\n      return res;\n    }\n\n    function asciiSlice(buf, start, end) {\n      var ret = '';\n      end = Math.min(buf.length, end);\n\n      for (var i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i] & 0x7F);\n      }\n\n      return ret;\n    }\n\n    function latin1Slice(buf, start, end) {\n      var ret = '';\n      end = Math.min(buf.length, end);\n\n      for (var i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i]);\n      }\n\n      return ret;\n    }\n\n    function hexSlice(buf, start, end) {\n      var len = buf.length;\n      if (!start || start < 0) start = 0;\n      if (!end || end < 0 || end > len) end = len;\n      var out = '';\n\n      for (var i = start; i < end; ++i) {\n        out += toHex(buf[i]);\n      }\n\n      return out;\n    }\n\n    function utf16leSlice(buf, start, end) {\n      var bytes = buf.slice(start, end);\n      var res = '';\n\n      for (var i = 0; i < bytes.length; i += 2) {\n        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n      }\n\n      return res;\n    }\n\n    Buffer.prototype.slice = function slice(start, end) {\n      var len = this.length;\n      start = ~~start;\n      end = end === undefined ? len : ~~end;\n\n      if (start < 0) {\n        start += len;\n        if (start < 0) start = 0;\n      } else if (start > len) {\n        start = len;\n      }\n\n      if (end < 0) {\n        end += len;\n        if (end < 0) end = 0;\n      } else if (end > len) {\n        end = len;\n      }\n\n      if (end < start) end = start;\n      var newBuf;\n\n      if (Buffer.TYPED_ARRAY_SUPPORT) {\n        newBuf = this.subarray(start, end);\n        newBuf.__proto__ = Buffer.prototype;\n      } else {\n        var sliceLen = end - start;\n        newBuf = new Buffer(sliceLen, undefined);\n\n        for (var i = 0; i < sliceLen; ++i) {\n          newBuf[i] = this[i + start];\n        }\n      }\n\n      return newBuf;\n    };\n    /*\n     * Need to make sure that buffer isn't trying to write out of bounds.\n     */\n\n\n    function checkOffset(offset, ext, length) {\n      if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n    }\n\n    Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n      offset = offset | 0;\n      byteLength = byteLength | 0;\n      if (!noAssert) checkOffset(offset, byteLength, this.length);\n      var val = this[offset];\n      var mul = 1;\n      var i = 0;\n\n      while (++i < byteLength && (mul *= 0x100)) {\n        val += this[offset + i] * mul;\n      }\n\n      return val;\n    };\n\n    Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n      offset = offset | 0;\n      byteLength = byteLength | 0;\n\n      if (!noAssert) {\n        checkOffset(offset, byteLength, this.length);\n      }\n\n      var val = this[offset + --byteLength];\n      var mul = 1;\n\n      while (byteLength > 0 && (mul *= 0x100)) {\n        val += this[offset + --byteLength] * mul;\n      }\n\n      return val;\n    };\n\n    Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n      if (!noAssert) checkOffset(offset, 1, this.length);\n      return this[offset];\n    };\n\n    Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n      if (!noAssert) checkOffset(offset, 2, this.length);\n      return this[offset] | this[offset + 1] << 8;\n    };\n\n    Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n      if (!noAssert) checkOffset(offset, 2, this.length);\n      return this[offset] << 8 | this[offset + 1];\n    };\n\n    Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n    };\n\n    Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n    };\n\n    Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n      offset = offset | 0;\n      byteLength = byteLength | 0;\n      if (!noAssert) checkOffset(offset, byteLength, this.length);\n      var val = this[offset];\n      var mul = 1;\n      var i = 0;\n\n      while (++i < byteLength && (mul *= 0x100)) {\n        val += this[offset + i] * mul;\n      }\n\n      mul *= 0x80;\n      if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n      return val;\n    };\n\n    Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n      offset = offset | 0;\n      byteLength = byteLength | 0;\n      if (!noAssert) checkOffset(offset, byteLength, this.length);\n      var i = byteLength;\n      var mul = 1;\n      var val = this[offset + --i];\n\n      while (i > 0 && (mul *= 0x100)) {\n        val += this[offset + --i] * mul;\n      }\n\n      mul *= 0x80;\n      if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n      return val;\n    };\n\n    Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n      if (!noAssert) checkOffset(offset, 1, this.length);\n      if (!(this[offset] & 0x80)) return this[offset];\n      return (0xff - this[offset] + 1) * -1;\n    };\n\n    Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n      if (!noAssert) checkOffset(offset, 2, this.length);\n      var val = this[offset] | this[offset + 1] << 8;\n      return val & 0x8000 ? val | 0xFFFF0000 : val;\n    };\n\n    Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n      if (!noAssert) checkOffset(offset, 2, this.length);\n      var val = this[offset + 1] | this[offset] << 8;\n      return val & 0x8000 ? val | 0xFFFF0000 : val;\n    };\n\n    Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n    };\n\n    Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n    };\n\n    Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return ieee754.read(this, offset, true, 23, 4);\n    };\n\n    Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return ieee754.read(this, offset, false, 23, 4);\n    };\n\n    Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n      if (!noAssert) checkOffset(offset, 8, this.length);\n      return ieee754.read(this, offset, true, 52, 8);\n    };\n\n    Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n      if (!noAssert) checkOffset(offset, 8, this.length);\n      return ieee754.read(this, offset, false, 52, 8);\n    };\n\n    function checkInt(buf, value, offset, ext, max, min) {\n      if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n      if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n      if (offset + ext > buf.length) throw new RangeError('Index out of range');\n    }\n\n    Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n      value = +value;\n      offset = offset | 0;\n      byteLength = byteLength | 0;\n\n      if (!noAssert) {\n        var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        checkInt(this, value, offset, byteLength, maxBytes, 0);\n      }\n\n      var mul = 1;\n      var i = 0;\n      this[offset] = value & 0xFF;\n\n      while (++i < byteLength && (mul *= 0x100)) {\n        this[offset + i] = value / mul & 0xFF;\n      }\n\n      return offset + byteLength;\n    };\n\n    Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n      value = +value;\n      offset = offset | 0;\n      byteLength = byteLength | 0;\n\n      if (!noAssert) {\n        var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        checkInt(this, value, offset, byteLength, maxBytes, 0);\n      }\n\n      var i = byteLength - 1;\n      var mul = 1;\n      this[offset + i] = value & 0xFF;\n\n      while (--i >= 0 && (mul *= 0x100)) {\n        this[offset + i] = value / mul & 0xFF;\n      }\n\n      return offset + byteLength;\n    };\n\n    Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n      value = +value;\n      offset = offset | 0;\n      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n      this[offset] = value & 0xff;\n      return offset + 1;\n    };\n\n    function objectWriteUInt16(buf, value, offset, littleEndian) {\n      if (value < 0) value = 0xffff + value + 1;\n\n      for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n        buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;\n      }\n    }\n\n    Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset | 0;\n      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\n      if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n      } else {\n        objectWriteUInt16(this, value, offset, true);\n      }\n\n      return offset + 2;\n    };\n\n    Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset | 0;\n      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\n      if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 0xff;\n      } else {\n        objectWriteUInt16(this, value, offset, false);\n      }\n\n      return offset + 2;\n    };\n\n    function objectWriteUInt32(buf, value, offset, littleEndian) {\n      if (value < 0) value = 0xffffffff + value + 1;\n\n      for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n        buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;\n      }\n    }\n\n    Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset | 0;\n      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\n      if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset + 3] = value >>> 24;\n        this[offset + 2] = value >>> 16;\n        this[offset + 1] = value >>> 8;\n        this[offset] = value & 0xff;\n      } else {\n        objectWriteUInt32(this, value, offset, true);\n      }\n\n      return offset + 4;\n    };\n\n    Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset | 0;\n      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\n      if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 0xff;\n      } else {\n        objectWriteUInt32(this, value, offset, false);\n      }\n\n      return offset + 4;\n    };\n\n    Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n      value = +value;\n      offset = offset | 0;\n\n      if (!noAssert) {\n        var limit = Math.pow(2, 8 * byteLength - 1);\n        checkInt(this, value, offset, byteLength, limit - 1, -limit);\n      }\n\n      var i = 0;\n      var mul = 1;\n      var sub = 0;\n      this[offset] = value & 0xFF;\n\n      while (++i < byteLength && (mul *= 0x100)) {\n        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n          sub = 1;\n        }\n\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n      }\n\n      return offset + byteLength;\n    };\n\n    Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n      value = +value;\n      offset = offset | 0;\n\n      if (!noAssert) {\n        var limit = Math.pow(2, 8 * byteLength - 1);\n        checkInt(this, value, offset, byteLength, limit - 1, -limit);\n      }\n\n      var i = byteLength - 1;\n      var mul = 1;\n      var sub = 0;\n      this[offset + i] = value & 0xFF;\n\n      while (--i >= 0 && (mul *= 0x100)) {\n        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n          sub = 1;\n        }\n\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n      }\n\n      return offset + byteLength;\n    };\n\n    Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n      value = +value;\n      offset = offset | 0;\n      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n      if (value < 0) value = 0xff + value + 1;\n      this[offset] = value & 0xff;\n      return offset + 1;\n    };\n\n    Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset | 0;\n      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\n      if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n      } else {\n        objectWriteUInt16(this, value, offset, true);\n      }\n\n      return offset + 2;\n    };\n\n    Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset | 0;\n      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\n      if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 0xff;\n      } else {\n        objectWriteUInt16(this, value, offset, false);\n      }\n\n      return offset + 2;\n    };\n\n    Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset | 0;\n      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n\n      if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n        this[offset + 2] = value >>> 16;\n        this[offset + 3] = value >>> 24;\n      } else {\n        objectWriteUInt32(this, value, offset, true);\n      }\n\n      return offset + 4;\n    };\n\n    Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset | 0;\n      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n      if (value < 0) value = 0xffffffff + value + 1;\n\n      if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 0xff;\n      } else {\n        objectWriteUInt32(this, value, offset, false);\n      }\n\n      return offset + 4;\n    };\n\n    function checkIEEE754(buf, value, offset, ext, max, min) {\n      if (offset + ext > buf.length) throw new RangeError('Index out of range');\n      if (offset < 0) throw new RangeError('Index out of range');\n    }\n\n    function writeFloat(buf, value, offset, littleEndian, noAssert) {\n      if (!noAssert) {\n        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);\n      }\n\n      ieee754.write(buf, value, offset, littleEndian, 23, 4);\n      return offset + 4;\n    }\n\n    Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n      return writeFloat(this, value, offset, true, noAssert);\n    };\n\n    Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n      return writeFloat(this, value, offset, false, noAssert);\n    };\n\n    function writeDouble(buf, value, offset, littleEndian, noAssert) {\n      if (!noAssert) {\n        checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);\n      }\n\n      ieee754.write(buf, value, offset, littleEndian, 52, 8);\n      return offset + 8;\n    }\n\n    Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n      return writeDouble(this, value, offset, true, noAssert);\n    };\n\n    Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n      return writeDouble(this, value, offset, false, noAssert);\n    }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\n\n    Buffer.prototype.copy = function copy(target, targetStart, start, end) {\n      if (!start) start = 0;\n      if (!end && end !== 0) end = this.length;\n      if (targetStart >= target.length) targetStart = target.length;\n      if (!targetStart) targetStart = 0;\n      if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done\n\n      if (end === start) return 0;\n      if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions\n\n      if (targetStart < 0) {\n        throw new RangeError('targetStart out of bounds');\n      }\n\n      if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');\n      if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?\n\n      if (end > this.length) end = this.length;\n\n      if (target.length - targetStart < end - start) {\n        end = target.length - targetStart + start;\n      }\n\n      var len = end - start;\n      var i;\n\n      if (this === target && start < targetStart && targetStart < end) {\n        // descending copy from end\n        for (i = len - 1; i >= 0; --i) {\n          target[i + targetStart] = this[i + start];\n        }\n      } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n        // ascending copy from start\n        for (i = 0; i < len; ++i) {\n          target[i + targetStart] = this[i + start];\n        }\n      } else {\n        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);\n      }\n\n      return len;\n    }; // Usage:\n    //    buffer.fill(number[, offset[, end]])\n    //    buffer.fill(buffer[, offset[, end]])\n    //    buffer.fill(string[, offset[, end]][, encoding])\n\n\n    Buffer.prototype.fill = function fill(val, start, end, encoding) {\n      // Handle string cases:\n      if (typeof val === 'string') {\n        if (typeof start === 'string') {\n          encoding = start;\n          start = 0;\n          end = this.length;\n        } else if (typeof end === 'string') {\n          encoding = end;\n          end = this.length;\n        }\n\n        if (val.length === 1) {\n          var code = val.charCodeAt(0);\n\n          if (code < 256) {\n            val = code;\n          }\n        }\n\n        if (encoding !== undefined && typeof encoding !== 'string') {\n          throw new TypeError('encoding must be a string');\n        }\n\n        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n          throw new TypeError('Unknown encoding: ' + encoding);\n        }\n      } else if (typeof val === 'number') {\n        val = val & 255;\n      } // Invalid ranges are not set to a default, so can range check early.\n\n\n      if (start < 0 || this.length < start || this.length < end) {\n        throw new RangeError('Out of range index');\n      }\n\n      if (end <= start) {\n        return this;\n      }\n\n      start = start >>> 0;\n      end = end === undefined ? this.length : end >>> 0;\n      if (!val) val = 0;\n      var i;\n\n      if (typeof val === 'number') {\n        for (i = start; i < end; ++i) {\n          this[i] = val;\n        }\n      } else {\n        var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());\n        var len = bytes.length;\n\n        for (i = 0; i < end - start; ++i) {\n          this[i + start] = bytes[i % len];\n        }\n      }\n\n      return this;\n    }; // HELPER FUNCTIONS\n    // ================\n\n\n    var INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n\n    function base64clean(str) {\n      // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n      str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''\n\n      if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\n      while (str.length % 4 !== 0) {\n        str = str + '=';\n      }\n\n      return str;\n    }\n\n    function stringtrim(str) {\n      if (str.trim) return str.trim();\n      return str.replace(/^\\s+|\\s+$/g, '');\n    }\n\n    function toHex(n) {\n      if (n < 16) return '0' + n.toString(16);\n      return n.toString(16);\n    }\n\n    function utf8ToBytes(string, units) {\n      units = units || Infinity;\n      var codePoint;\n      var length = string.length;\n      var leadSurrogate = null;\n      var bytes = [];\n\n      for (var i = 0; i < length; ++i) {\n        codePoint = string.charCodeAt(i); // is surrogate component\n\n        if (codePoint > 0xD7FF && codePoint < 0xE000) {\n          // last char was a lead\n          if (!leadSurrogate) {\n            // no lead yet\n            if (codePoint > 0xDBFF) {\n              // unexpected trail\n              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n              continue;\n            } else if (i + 1 === length) {\n              // unpaired lead\n              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n              continue;\n            } // valid lead\n\n\n            leadSurrogate = codePoint;\n            continue;\n          } // 2 leads in a row\n\n\n          if (codePoint < 0xDC00) {\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n            leadSurrogate = codePoint;\n            continue;\n          } // valid surrogate pair\n\n\n          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n        } else if (leadSurrogate) {\n          // valid bmp char, but last char was a lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        }\n\n        leadSurrogate = null; // encode utf8\n\n        if (codePoint < 0x80) {\n          if ((units -= 1) < 0) break;\n          bytes.push(codePoint);\n        } else if (codePoint < 0x800) {\n          if ((units -= 2) < 0) break;\n          bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x10000) {\n          if ((units -= 3) < 0) break;\n          bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x110000) {\n          if ((units -= 4) < 0) break;\n          bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else {\n          throw new Error('Invalid code point');\n        }\n      }\n\n      return bytes;\n    }\n\n    function asciiToBytes(str) {\n      var byteArray = [];\n\n      for (var i = 0; i < str.length; ++i) {\n        // Node's code seems to be doing this and not & 0x7F..\n        byteArray.push(str.charCodeAt(i) & 0xFF);\n      }\n\n      return byteArray;\n    }\n\n    function utf16leToBytes(str, units) {\n      var c, hi, lo;\n      var byteArray = [];\n\n      for (var i = 0; i < str.length; ++i) {\n        if ((units -= 2) < 0) break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n      }\n\n      return byteArray;\n    }\n\n    function base64ToBytes(str) {\n      return base64.toByteArray(base64clean(str));\n    }\n\n    function blitBuffer(src, dst, offset, length) {\n      for (var i = 0; i < length; ++i) {\n        if (i + offset >= dst.length || i >= src.length) break;\n        dst[i + offset] = src[i];\n      }\n\n      return i;\n    }\n\n    function isnan(val) {\n      return val !== val; // eslint-disable-line no-self-compare\n    }\n    /* WEBPACK VAR INJECTION */\n\n  }).call(this, __webpack_require__(13));\n  /***/\n},\n/* 31 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n  /*<replacement>*/\n\n  var pna = __webpack_require__(20);\n  /*</replacement>*/\n  // undocumented cb() API, needed for core, not for public API\n\n\n  function destroy(err, cb) {\n    var _this = this;\n\n    var readableDestroyed = this._readableState && this._readableState.destroyed;\n    var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n    if (readableDestroyed || writableDestroyed) {\n      if (cb) {\n        cb(err);\n      } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n        pna.nextTick(emitErrorNT, this, err);\n      }\n\n      return this;\n    } // we set destroyed to true before firing error callbacks in order\n    // to make it re-entrance safe in case destroy() is called within callbacks\n\n\n    if (this._readableState) {\n      this._readableState.destroyed = true;\n    } // if this is a duplex stream mark the writable part as destroyed as well\n\n\n    if (this._writableState) {\n      this._writableState.destroyed = true;\n    }\n\n    this._destroy(err || null, function (err) {\n      if (!cb && err) {\n        pna.nextTick(emitErrorNT, _this, err);\n\n        if (_this._writableState) {\n          _this._writableState.errorEmitted = true;\n        }\n      } else if (cb) {\n        cb(err);\n      }\n    });\n\n    return this;\n  }\n\n  function undestroy() {\n    if (this._readableState) {\n      this._readableState.destroyed = false;\n      this._readableState.reading = false;\n      this._readableState.ended = false;\n      this._readableState.endEmitted = false;\n    }\n\n    if (this._writableState) {\n      this._writableState.destroyed = false;\n      this._writableState.ended = false;\n      this._writableState.ending = false;\n      this._writableState.finished = false;\n      this._writableState.errorEmitted = false;\n    }\n  }\n\n  function emitErrorNT(self, err) {\n    self.emit('error', err);\n  }\n\n  module.exports = {\n    destroy: destroy,\n    undestroy: undestroy\n  };\n  /***/\n},\n/* 32 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\"; // Copyright Joyent, Inc. and other Node contributors.\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a\n  // copy of this software and associated documentation files (the\n  // \"Software\"), to deal in the Software without restriction, including\n  // without limitation the rights to use, copy, modify, merge, publish,\n  // distribute, sublicense, and/or sell copies of the Software, and to permit\n  // persons to whom the Software is furnished to do so, subject to the\n  // following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included\n  // in all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n  // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n  /*<replacement>*/\n\n  var Buffer = __webpack_require__(52).Buffer;\n  /*</replacement>*/\n\n\n  var isEncoding = Buffer.isEncoding || function (encoding) {\n    encoding = '' + encoding;\n\n    switch (encoding && encoding.toLowerCase()) {\n      case 'hex':\n      case 'utf8':\n      case 'utf-8':\n      case 'ascii':\n      case 'binary':\n      case 'base64':\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n      case 'raw':\n        return true;\n\n      default:\n        return false;\n    }\n  };\n\n  function _normalizeEncoding(enc) {\n    if (!enc) return 'utf8';\n    var retried;\n\n    while (true) {\n      switch (enc) {\n        case 'utf8':\n        case 'utf-8':\n          return 'utf8';\n\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n          return 'utf16le';\n\n        case 'latin1':\n        case 'binary':\n          return 'latin1';\n\n        case 'base64':\n        case 'ascii':\n        case 'hex':\n          return enc;\n\n        default:\n          if (retried) return; // undefined\n\n          enc = ('' + enc).toLowerCase();\n          retried = true;\n      }\n    }\n  }\n\n  ; // Do not cache `Buffer.isEncoding` when checking encoding names as some\n  // modules monkey-patch it to support additional encodings\n\n  function normalizeEncoding(enc) {\n    var nenc = _normalizeEncoding(enc);\n\n    if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n    return nenc || enc;\n  } // StringDecoder provides an interface for efficiently splitting a series of\n  // buffers into a series of JS strings without breaking apart multi-byte\n  // characters.\n\n\n  exports.StringDecoder = StringDecoder;\n\n  function StringDecoder(encoding) {\n    this.encoding = normalizeEncoding(encoding);\n    var nb;\n\n    switch (this.encoding) {\n      case 'utf16le':\n        this.text = utf16Text;\n        this.end = utf16End;\n        nb = 4;\n        break;\n\n      case 'utf8':\n        this.fillLast = utf8FillLast;\n        nb = 4;\n        break;\n\n      case 'base64':\n        this.text = base64Text;\n        this.end = base64End;\n        nb = 3;\n        break;\n\n      default:\n        this.write = simpleWrite;\n        this.end = simpleEnd;\n        return;\n    }\n\n    this.lastNeed = 0;\n    this.lastTotal = 0;\n    this.lastChar = Buffer.allocUnsafe(nb);\n  }\n\n  StringDecoder.prototype.write = function (buf) {\n    if (buf.length === 0) return '';\n    var r;\n    var i;\n\n    if (this.lastNeed) {\n      r = this.fillLast(buf);\n      if (r === undefined) return '';\n      i = this.lastNeed;\n      this.lastNeed = 0;\n    } else {\n      i = 0;\n    }\n\n    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n    return r || '';\n  };\n\n  StringDecoder.prototype.end = utf8End; // Returns only complete characters in a Buffer\n\n  StringDecoder.prototype.text = utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\n\n  StringDecoder.prototype.fillLast = function (buf) {\n    if (this.lastNeed <= buf.length) {\n      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n      return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n    }\n\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n    this.lastNeed -= buf.length;\n  }; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n  // continuation byte. If an invalid byte is detected, -2 is returned.\n\n\n  function utf8CheckByte(byte) {\n    if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n    return byte >> 6 === 0x02 ? -1 : -2;\n  } // Checks at most 3 bytes at the end of a Buffer in order to detect an\n  // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n  // needed to complete the UTF-8 character (if applicable) are returned.\n\n\n  function utf8CheckIncomplete(self, buf, i) {\n    var j = buf.length - 1;\n    if (j < i) return 0;\n    var nb = utf8CheckByte(buf[j]);\n\n    if (nb >= 0) {\n      if (nb > 0) self.lastNeed = nb - 1;\n      return nb;\n    }\n\n    if (--j < i || nb === -2) return 0;\n    nb = utf8CheckByte(buf[j]);\n\n    if (nb >= 0) {\n      if (nb > 0) self.lastNeed = nb - 2;\n      return nb;\n    }\n\n    if (--j < i || nb === -2) return 0;\n    nb = utf8CheckByte(buf[j]);\n\n    if (nb >= 0) {\n      if (nb > 0) {\n        if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n      }\n\n      return nb;\n    }\n\n    return 0;\n  } // Validates as many continuation bytes for a multi-byte UTF-8 character as\n  // needed or are available. If we see a non-continuation byte where we expect\n  // one, we \"replace\" the validated continuation bytes we've seen so far with\n  // a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n  // behavior. The continuation byte check is included three times in the case\n  // where all of the continuation bytes for a character exist in the same buffer.\n  // It is also done this way as a slight performance increase instead of using a\n  // loop.\n\n\n  function utf8CheckExtraBytes(self, buf, p) {\n    if ((buf[0] & 0xC0) !== 0x80) {\n      self.lastNeed = 0;\n      return \"\\uFFFD\";\n    }\n\n    if (self.lastNeed > 1 && buf.length > 1) {\n      if ((buf[1] & 0xC0) !== 0x80) {\n        self.lastNeed = 1;\n        return \"\\uFFFD\";\n      }\n\n      if (self.lastNeed > 2 && buf.length > 2) {\n        if ((buf[2] & 0xC0) !== 0x80) {\n          self.lastNeed = 2;\n          return \"\\uFFFD\";\n        }\n      }\n    }\n  } // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\n\n\n  function utf8FillLast(buf) {\n    var p = this.lastTotal - this.lastNeed;\n    var r = utf8CheckExtraBytes(this, buf, p);\n    if (r !== undefined) return r;\n\n    if (this.lastNeed <= buf.length) {\n      buf.copy(this.lastChar, p, 0, this.lastNeed);\n      return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n    }\n\n    buf.copy(this.lastChar, p, 0, buf.length);\n    this.lastNeed -= buf.length;\n  } // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n  // partial character, the character's bytes are buffered until the required\n  // number of bytes are available.\n\n\n  function utf8Text(buf, i) {\n    var total = utf8CheckIncomplete(this, buf, i);\n    if (!this.lastNeed) return buf.toString('utf8', i);\n    this.lastTotal = total;\n    var end = buf.length - (total - this.lastNeed);\n    buf.copy(this.lastChar, 0, end);\n    return buf.toString('utf8', i, end);\n  } // For UTF-8, a replacement character is added when ending on a partial\n  // character.\n\n\n  function utf8End(buf) {\n    var r = buf && buf.length ? this.write(buf) : '';\n    if (this.lastNeed) return r + \"\\uFFFD\";\n    return r;\n  } // UTF-16LE typically needs two bytes per character, but even if we have an even\n  // number of bytes available, we need to check if we end on a leading/high\n  // surrogate. In that case, we need to wait for the next two bytes in order to\n  // decode the last character properly.\n\n\n  function utf16Text(buf, i) {\n    if ((buf.length - i) % 2 === 0) {\n      var r = buf.toString('utf16le', i);\n\n      if (r) {\n        var c = r.charCodeAt(r.length - 1);\n\n        if (c >= 0xD800 && c <= 0xDBFF) {\n          this.lastNeed = 2;\n          this.lastTotal = 4;\n          this.lastChar[0] = buf[buf.length - 2];\n          this.lastChar[1] = buf[buf.length - 1];\n          return r.slice(0, -1);\n        }\n      }\n\n      return r;\n    }\n\n    this.lastNeed = 1;\n    this.lastTotal = 2;\n    this.lastChar[0] = buf[buf.length - 1];\n    return buf.toString('utf16le', i, buf.length - 1);\n  } // For UTF-16LE we do not explicitly append special replacement characters if we\n  // end on a partial character, we simply let v8 handle that.\n\n\n  function utf16End(buf) {\n    var r = buf && buf.length ? this.write(buf) : '';\n\n    if (this.lastNeed) {\n      var end = this.lastTotal - this.lastNeed;\n      return r + this.lastChar.toString('utf16le', 0, end);\n    }\n\n    return r;\n  }\n\n  function base64Text(buf, i) {\n    var n = (buf.length - i) % 3;\n    if (n === 0) return buf.toString('base64', i);\n    this.lastNeed = 3 - n;\n    this.lastTotal = 3;\n\n    if (n === 1) {\n      this.lastChar[0] = buf[buf.length - 1];\n    } else {\n      this.lastChar[0] = buf[buf.length - 2];\n      this.lastChar[1] = buf[buf.length - 1];\n    }\n\n    return buf.toString('base64', i, buf.length - n);\n  }\n\n  function base64End(buf) {\n    var r = buf && buf.length ? this.write(buf) : '';\n    if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n    return r;\n  } // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\n\n\n  function simpleWrite(buf) {\n    return buf.toString(this.encoding);\n  }\n\n  function simpleEnd(buf) {\n    return buf && buf.length ? this.write(buf) : '';\n  }\n  /***/\n\n},\n/* 33 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\"; // Copyright Joyent, Inc. and other Node contributors.\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a\n  // copy of this software and associated documentation files (the\n  // \"Software\"), to deal in the Software without restriction, including\n  // without limitation the rights to use, copy, modify, merge, publish,\n  // distribute, sublicense, and/or sell copies of the Software, and to permit\n  // persons to whom the Software is furnished to do so, subject to the\n  // following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included\n  // in all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n  // USE OR OTHER DEALINGS IN THE SOFTWARE.\n  // a transform stream is a readable/writable stream where you do\n  // something with the data.  Sometimes it's called a \"filter\",\n  // but that's not a great name for it, since that implies a thing where\n  // some bits pass through, and others are simply ignored.  (That would\n  // be a valid example of a transform, of course.)\n  //\n  // While the output is causally related to the input, it's not a\n  // necessarily symmetric or synchronous transformation.  For example,\n  // a zlib stream might take multiple plain-text writes(), and then\n  // emit a single compressed chunk some time in the future.\n  //\n  // Here's how this works:\n  //\n  // The Transform stream has all the aspects of the readable and writable\n  // stream classes.  When you write(chunk), that calls _write(chunk,cb)\n  // internally, and returns false if there's a lot of pending writes\n  // buffered up.  When you call read(), that calls _read(n) until\n  // there's enough pending readable data buffered up.\n  //\n  // In a transform stream, the written data is placed in a buffer.  When\n  // _read(n) is called, it transforms the queued up data, calling the\n  // buffered _write cb's as it consumes chunks.  If consuming a single\n  // written chunk would result in multiple output chunks, then the first\n  // outputted bit calls the readcb, and subsequent chunks just go into\n  // the read buffer, and will cause it to emit 'readable' if necessary.\n  //\n  // This way, back-pressure is actually determined by the reading side,\n  // since _read has to be called to start processing a new chunk.  However,\n  // a pathological inflate type of transform can cause excessive buffering\n  // here.  For example, imagine a stream where every byte of input is\n  // interpreted as an integer from 0-255, and then results in that many\n  // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n  // 1kb of data being output.  In this case, you could write a very small\n  // amount of input, and end up with a very large amount of output.  In\n  // such a pathological inflating mechanism, there'd be no way to tell\n  // the system to stop doing the transform.  A single 4MB write could\n  // cause the system to run out of memory.\n  //\n  // However, even in such a pathological case, only a single written chunk\n  // would be consumed, and then the rest would wait (un-transformed) until\n  // the results of the previous transformed chunk were consumed.\n\n  module.exports = Transform;\n\n  var Duplex = __webpack_require__(11);\n  /*<replacement>*/\n\n\n  var util = Object.create(__webpack_require__(16));\n  util.inherits = __webpack_require__(12);\n  /*</replacement>*/\n\n  util.inherits(Transform, Duplex);\n\n  function afterTransform(er, data) {\n    var ts = this._transformState;\n    ts.transforming = false;\n    var cb = ts.writecb;\n\n    if (!cb) {\n      return this.emit('error', new Error('write callback called multiple times'));\n    }\n\n    ts.writechunk = null;\n    ts.writecb = null;\n    if (data != null) // single equals check for both `null` and `undefined`\n      this.push(data);\n    cb(er);\n    var rs = this._readableState;\n    rs.reading = false;\n\n    if (rs.needReadable || rs.length < rs.highWaterMark) {\n      this._read(rs.highWaterMark);\n    }\n  }\n\n  function Transform(options) {\n    if (!(this instanceof Transform)) return new Transform(options);\n    Duplex.call(this, options);\n    this._transformState = {\n      afterTransform: afterTransform.bind(this),\n      needTransform: false,\n      transforming: false,\n      writecb: null,\n      writechunk: null,\n      writeencoding: null\n    }; // start out asking for a readable event once data is transformed.\n\n    this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n    // that Readable wants before the first _read call, so unset the\n    // sync guard flag.\n\n    this._readableState.sync = false;\n\n    if (options) {\n      if (typeof options.transform === 'function') this._transform = options.transform;\n      if (typeof options.flush === 'function') this._flush = options.flush;\n    } // When the writable side finishes, then flush out anything remaining.\n\n\n    this.on('prefinish', prefinish);\n  }\n\n  function prefinish() {\n    var _this = this;\n\n    if (typeof this._flush === 'function') {\n      this._flush(function (er, data) {\n        done(_this, er, data);\n      });\n    } else {\n      done(this, null, null);\n    }\n  }\n\n  Transform.prototype.push = function (chunk, encoding) {\n    this._transformState.needTransform = false;\n    return Duplex.prototype.push.call(this, chunk, encoding);\n  }; // This is the part where you do stuff!\n  // override this function in implementation classes.\n  // 'chunk' is an input chunk.\n  //\n  // Call `push(newChunk)` to pass along transformed output\n  // to the readable side.  You may call 'push' zero or more times.\n  //\n  // Call `cb(err)` when you are done with this chunk.  If you pass\n  // an error, then that'll put the hurt on the whole operation.  If you\n  // never call cb(), then you'll never get another chunk.\n\n\n  Transform.prototype._transform = function (chunk, encoding, cb) {\n    throw new Error('_transform() is not implemented');\n  };\n\n  Transform.prototype._write = function (chunk, encoding, cb) {\n    var ts = this._transformState;\n    ts.writecb = cb;\n    ts.writechunk = chunk;\n    ts.writeencoding = encoding;\n\n    if (!ts.transforming) {\n      var rs = this._readableState;\n      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n    }\n  }; // Doesn't matter what the args are here.\n  // _transform does all the work.\n  // That we got here means that the readable side wants more data.\n\n\n  Transform.prototype._read = function (n) {\n    var ts = this._transformState;\n\n    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n      ts.transforming = true;\n\n      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n    } else {\n      // mark that we need a transform, so that any data that comes in\n      // will get processed, now that we've asked for it.\n      ts.needTransform = true;\n    }\n  };\n\n  Transform.prototype._destroy = function (err, cb) {\n    var _this2 = this;\n\n    Duplex.prototype._destroy.call(this, err, function (err2) {\n      cb(err2);\n\n      _this2.emit('close');\n    });\n  };\n\n  function done(stream, er, data) {\n    if (er) return stream.emit('error', er);\n    if (data != null) // single equals check for both `null` and `undefined`\n      stream.push(data); // if there's nothing in the write buffer, then that means\n    // that nothing more will ever be provided\n\n    if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n    if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n    return stream.push(null);\n  }\n  /***/\n\n},\n/* 34 */\n\n/***/\nfunction (module, __webpack_exports__, __webpack_require__) {\n  \"use strict\";\n  /* harmony export (binding) */\n\n  __webpack_require__.d(__webpack_exports__, \"a\", function () {\n    return JRPCEngine;\n  });\n  /* harmony export (binding) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"c\", function () {\n    return mergeMiddleware;\n  });\n  /* harmony export (binding) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"b\", function () {\n    return createEngineStream;\n  });\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(7);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_7__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(3);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(0);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__);\n  /* harmony import */\n\n\n  var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(1);\n  /* harmony import */\n\n\n  var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_10__);\n  /* harmony import */\n\n\n  var stream__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(10);\n  /* harmony import */\n\n\n  var stream__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_11__);\n  /* harmony import */\n\n\n  var _jrpc__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(18);\n  /* harmony import */\n\n\n  var _safeEventEmitter__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(14);\n  /* harmony import */\n\n\n  var _serializableError__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(8);\n\n  function _createForOfIteratorHelper(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n    if (!it) {\n      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n\n        var F = function F() {};\n\n        return {\n          s: F,\n          n: function n() {\n            if (i >= o.length) return {\n              done: true\n            };\n            return {\n              done: false,\n              value: o[i++]\n            };\n          },\n          e: function e(_e) {\n            throw _e;\n          },\n          f: F\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var normalCompletion = true,\n        didErr = false,\n        err;\n    return {\n      s: function s() {\n        it = it.call(o);\n      },\n      n: function n() {\n        var step = it.next();\n        normalCompletion = step.done;\n        return step;\n      },\n      e: function e(_e2) {\n        didErr = true;\n        err = _e2;\n      },\n      f: function f() {\n        try {\n          if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n        } finally {\n          if (didErr) throw err;\n        }\n      }\n    };\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n\n      if (enumerableOnly) {\n        symbols = symbols.filter(function (sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        });\n      }\n\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        ownKeys(Object(source), true).forEach(function (key) {\n          _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n    }\n\n    return target;\n  }\n\n  function _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n    return function _createSuperInternal() {\n      var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8___default()(Derived),\n          result;\n\n      if (hasNativeReflectConstruct) {\n        var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8___default()(this).constructor;\n\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n\n      return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_7___default()(this, result);\n    };\n  }\n\n  function _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\n   * A JSON-RPC request and response processor.\n   * Give it a stack of middleware, pass it requests, and get back responses.\n   */\n\n\n  var JRPCEngine = /*#__PURE__*/function (_SafeEventEmitter) {\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6___default()(JRPCEngine, _SafeEventEmitter);\n\n    var _super = _createSuper(JRPCEngine);\n\n    function JRPCEngine() {\n      var _this;\n\n      _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3___default()(this, JRPCEngine);\n\n      _this = _super.call(this);\n\n      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), \"_middleware\", void 0);\n\n      _this._middleware = [];\n      return _this;\n    }\n    /**\n     * Add a middleware function to the engine's middleware stack.\n     *\n     * @param middleware - The middleware function to add.\n     */\n\n\n    _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4___default()(JRPCEngine, [{\n      key: \"push\",\n      value: function push(middleware) {\n        this._middleware.push(middleware);\n      }\n      /**\n       * Handle a JSON-RPC request, and return a response.\n       *\n       * @param request - The request to handle.\n       * @param callback - An error-first callback that will receive the response.\n       */\n\n    }, {\n      key: \"handle\",\n      value: function handle(req, cb) {\n        if (cb && typeof cb !== \"function\") {\n          throw new Error('\"callback\" must be a function if provided.');\n        }\n\n        if (Array.isArray(req)) {\n          if (cb) {\n            return this._handleBatch(req, cb);\n          }\n\n          return this._handleBatch(req);\n        }\n\n        if (cb) {\n          return this._handle(req, cb);\n        }\n\n        return this._promiseHandle(req);\n      }\n      /**\n       * Returns this engine as a middleware function that can be pushed to other\n       * engines.\n       *\n       * @returns This engine as a middleware function.\n       */\n\n    }, {\n      key: \"asMiddleware\",\n      value: function asMiddleware() {\n        var _this2 = this;\n\n        return /*#__PURE__*/function () {\n          var _ref = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_10___default.a.mark(function _callee2(req, res, next, end) {\n            var _yield$JRPCEngine$_ru, _yield$JRPCEngine$_ru2, middlewareError, isComplete, returnHandlers;\n\n            return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_10___default.a.wrap(function _callee2$(_context2) {\n              while (1) {\n                switch (_context2.prev = _context2.next) {\n                  case 0:\n                    _context2.prev = 0;\n                    _context2.next = 3;\n                    return JRPCEngine._runAllMiddleware(req, res, _this2._middleware);\n\n                  case 3:\n                    _yield$JRPCEngine$_ru = _context2.sent;\n                    _yield$JRPCEngine$_ru2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default()(_yield$JRPCEngine$_ru, 3);\n                    middlewareError = _yield$JRPCEngine$_ru2[0];\n                    isComplete = _yield$JRPCEngine$_ru2[1];\n                    returnHandlers = _yield$JRPCEngine$_ru2[2];\n\n                    if (!isComplete) {\n                      _context2.next = 12;\n                      break;\n                    }\n\n                    _context2.next = 11;\n                    return JRPCEngine._runReturnHandlers(returnHandlers);\n\n                  case 11:\n                    return _context2.abrupt(\"return\", end(middlewareError));\n\n                  case 12:\n                    return _context2.abrupt(\"return\", next( /*#__PURE__*/function () {\n                      var _ref2 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_10___default.a.mark(function _callee(handlerCallback) {\n                        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_10___default.a.wrap(function _callee$(_context) {\n                          while (1) {\n                            switch (_context.prev = _context.next) {\n                              case 0:\n                                _context.prev = 0;\n                                _context.next = 3;\n                                return JRPCEngine._runReturnHandlers(returnHandlers);\n\n                              case 3:\n                                _context.next = 8;\n                                break;\n\n                              case 5:\n                                _context.prev = 5;\n                                _context.t0 = _context[\"catch\"](0);\n                                return _context.abrupt(\"return\", handlerCallback(_context.t0));\n\n                              case 8:\n                                return _context.abrupt(\"return\", handlerCallback());\n\n                              case 9:\n                              case \"end\":\n                                return _context.stop();\n                            }\n                          }\n                        }, _callee, null, [[0, 5]]);\n                      }));\n\n                      return function (_x5) {\n                        return _ref2.apply(this, arguments);\n                      };\n                    }()));\n\n                  case 15:\n                    _context2.prev = 15;\n                    _context2.t0 = _context2[\"catch\"](0);\n                    return _context2.abrupt(\"return\", end(_context2.t0));\n\n                  case 18:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }\n            }, _callee2, null, [[0, 15]]);\n          }));\n\n          return function (_x, _x2, _x3, _x4) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n      }\n      /**\n       * Like _handle, but for batch requests.\n       */\n\n    }, {\n      key: \"_handleBatch\",\n      value: function () {\n        var _handleBatch2 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_10___default.a.mark(function _callee3(reqs, cb) {\n          var _responses;\n\n          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_10___default.a.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  _context3.prev = 0;\n                  _context3.next = 3;\n                  return Promise.all( // 1. Begin executing each request in the order received\n                  reqs.map(this._promiseHandle.bind(this)));\n\n                case 3:\n                  _responses = _context3.sent;\n\n                  if (!cb) {\n                    _context3.next = 6;\n                    break;\n                  }\n\n                  return _context3.abrupt(\"return\", cb(null, _responses));\n\n                case 6:\n                  return _context3.abrupt(\"return\", _responses);\n\n                case 9:\n                  _context3.prev = 9;\n                  _context3.t0 = _context3[\"catch\"](0);\n\n                  if (!cb) {\n                    _context3.next = 13;\n                    break;\n                  }\n\n                  return _context3.abrupt(\"return\", cb(_context3.t0));\n\n                case 13:\n                  throw _context3.t0;\n\n                case 14:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, this, [[0, 9]]);\n        }));\n\n        function _handleBatch(_x6, _x7) {\n          return _handleBatch2.apply(this, arguments);\n        }\n\n        return _handleBatch;\n      }()\n      /**\n       * A promise-wrapped _handle.\n       */\n\n    }, {\n      key: \"_promiseHandle\",\n      value: function _promiseHandle(req) {\n        var _this3 = this;\n\n        return new Promise(function (resolve) {\n          _this3._handle(req, function (_err, res) {\n            // There will always be a response, and it will always have any error\n            // that is caught and propagated.\n            resolve(res);\n          });\n        });\n      }\n      /**\n       * Ensures that the request object is valid, processes it, and passes any\n       * error and the response object to the given callback.\n       *\n       * Does not reject.\n       */\n\n    }, {\n      key: \"_handle\",\n      value: function () {\n        var _handle2 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_10___default.a.mark(function _callee4(callerReq, cb) {\n          var _error2, _error3, req, res, error;\n\n          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_10___default.a.wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  if (!(!callerReq || Array.isArray(callerReq) || _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(callerReq) !== \"object\")) {\n                    _context4.next = 3;\n                    break;\n                  }\n\n                  _error2 = new _serializableError__WEBPACK_IMPORTED_MODULE_14__[\n                  /* default */\n                  \"a\"]({\n                    code: -32603,\n                    message: \"request must be plain object\"\n                  });\n                  return _context4.abrupt(\"return\", cb(_error2, {\n                    id: undefined,\n                    jsonrpc: \"2.0\",\n                    error: _error2\n                  }));\n\n                case 3:\n                  if (!(typeof callerReq.method !== \"string\")) {\n                    _context4.next = 6;\n                    break;\n                  }\n\n                  _error3 = new _serializableError__WEBPACK_IMPORTED_MODULE_14__[\n                  /* default */\n                  \"a\"]({\n                    code: -32603,\n                    message: \"method must be string\"\n                  });\n                  return _context4.abrupt(\"return\", cb(_error3, {\n                    id: callerReq.id,\n                    jsonrpc: \"2.0\",\n                    error: _error3\n                  }));\n\n                case 6:\n                  req = _objectSpread({}, callerReq);\n                  res = {\n                    id: req.id,\n                    jsonrpc: req.jsonrpc\n                  };\n                  error = null;\n                  _context4.prev = 9;\n                  _context4.next = 12;\n                  return this._processRequest(req, res);\n\n                case 12:\n                  _context4.next = 17;\n                  break;\n\n                case 14:\n                  _context4.prev = 14;\n                  _context4.t0 = _context4[\"catch\"](9); // A request handler error, a re-thrown middleware error, or something\n                  // unexpected.\n\n                  error = _context4.t0;\n\n                case 17:\n                  if (error) {\n                    // Ensure no result is present on an errored response\n                    delete res.result;\n\n                    if (!res.error) {\n                      res.error = Object(_jrpc__WEBPACK_IMPORTED_MODULE_12__[\n                      /* serializeError */\n                      \"h\"])(error);\n                    }\n                  }\n\n                  return _context4.abrupt(\"return\", cb(error, res));\n\n                case 19:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4, this, [[9, 14]]);\n        }));\n\n        function _handle(_x8, _x9) {\n          return _handle2.apply(this, arguments);\n        }\n\n        return _handle;\n      }()\n      /**\n       * For the given request and response, runs all middleware and their return\n       * handlers, if any, and ensures that internal request processing semantics\n       * are satisfied.\n       */\n\n    }, {\n      key: \"_processRequest\",\n      value: function () {\n        var _processRequest2 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_10___default.a.mark(function _callee5(req, res) {\n          var _yield$JRPCEngine$_ru3, _yield$JRPCEngine$_ru4, error, isComplete, returnHandlers;\n\n          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_10___default.a.wrap(function _callee5$(_context5) {\n            while (1) {\n              switch (_context5.prev = _context5.next) {\n                case 0:\n                  _context5.next = 2;\n                  return JRPCEngine._runAllMiddleware(req, res, this._middleware);\n\n                case 2:\n                  _yield$JRPCEngine$_ru3 = _context5.sent;\n                  _yield$JRPCEngine$_ru4 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default()(_yield$JRPCEngine$_ru3, 3);\n                  error = _yield$JRPCEngine$_ru4[0];\n                  isComplete = _yield$JRPCEngine$_ru4[1];\n                  returnHandlers = _yield$JRPCEngine$_ru4[2]; // Throw if \"end\" was not called, or if the response has neither a result\n                  // nor an error.\n\n                  JRPCEngine._checkForCompletion(req, res, isComplete); // The return handlers should run even if an error was encountered during\n                  // middleware processing.\n\n\n                  _context5.next = 10;\n                  return JRPCEngine._runReturnHandlers(returnHandlers);\n\n                case 10:\n                  if (!error) {\n                    _context5.next = 12;\n                    break;\n                  }\n\n                  throw error;\n\n                case 12:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }\n          }, _callee5, this);\n        }));\n\n        function _processRequest(_x10, _x11) {\n          return _processRequest2.apply(this, arguments);\n        }\n\n        return _processRequest;\n      }()\n      /**\n       * Serially executes the given stack of middleware.\n       *\n       * @returns An array of any error encountered during middleware execution,\n       * a boolean indicating whether the request was completed, and an array of\n       * middleware-defined return handlers.\n       */\n\n    }], [{\n      key: \"_runAllMiddleware\",\n      value: function () {\n        var _runAllMiddleware2 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_10___default.a.mark(function _callee6(req, res, middlewareStack) {\n          var returnHandlers, error, isComplete, _iterator, _step, middleware, _yield$JRPCEngine$_ru5, _yield$JRPCEngine$_ru6;\n\n          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_10___default.a.wrap(function _callee6$(_context6) {\n            while (1) {\n              switch (_context6.prev = _context6.next) {\n                case 0:\n                  returnHandlers = [];\n                  error = null;\n                  isComplete = false; // Go down stack of middleware, call and collect optional returnHandlers\n\n                  _iterator = _createForOfIteratorHelper(middlewareStack);\n                  _context6.prev = 4;\n\n                  _iterator.s();\n\n                case 6:\n                  if ((_step = _iterator.n()).done) {\n                    _context6.next = 18;\n                    break;\n                  }\n\n                  middleware = _step.value;\n                  _context6.next = 10;\n                  return JRPCEngine._runMiddleware(req, res, middleware, returnHandlers);\n\n                case 10:\n                  _yield$JRPCEngine$_ru5 = _context6.sent;\n                  _yield$JRPCEngine$_ru6 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default()(_yield$JRPCEngine$_ru5, 2);\n                  error = _yield$JRPCEngine$_ru6[0];\n                  isComplete = _yield$JRPCEngine$_ru6[1];\n\n                  if (!isComplete) {\n                    _context6.next = 16;\n                    break;\n                  }\n\n                  return _context6.abrupt(\"break\", 18);\n\n                case 16:\n                  _context6.next = 6;\n                  break;\n\n                case 18:\n                  _context6.next = 23;\n                  break;\n\n                case 20:\n                  _context6.prev = 20;\n                  _context6.t0 = _context6[\"catch\"](4);\n\n                  _iterator.e(_context6.t0);\n\n                case 23:\n                  _context6.prev = 23;\n\n                  _iterator.f();\n\n                  return _context6.finish(23);\n\n                case 26:\n                  return _context6.abrupt(\"return\", [error, isComplete, returnHandlers.reverse()]);\n\n                case 27:\n                case \"end\":\n                  return _context6.stop();\n              }\n            }\n          }, _callee6, null, [[4, 20, 23, 26]]);\n        }));\n\n        function _runAllMiddleware(_x12, _x13, _x14) {\n          return _runAllMiddleware2.apply(this, arguments);\n        }\n\n        return _runAllMiddleware;\n      }()\n      /**\n       * Runs an individual middleware.\n       *\n       * @returns An array of any error encountered during middleware exection,\n       * and a boolean indicating whether the request should end.\n       */\n\n    }, {\n      key: \"_runMiddleware\",\n      value: function _runMiddleware(req, res, middleware, returnHandlers) {\n        return new Promise(function (resolve) {\n          var end = function end(err) {\n            var error = err || res.error;\n\n            if (error) {\n              res.error = Object(_jrpc__WEBPACK_IMPORTED_MODULE_12__[\n              /* serializeError */\n              \"h\"])(error);\n            } // True indicates that the request should end\n\n\n            resolve([error, true]);\n          };\n\n          var next = function next(returnHandler) {\n            if (res.error) {\n              end(res.error);\n            } else {\n              if (returnHandler) {\n                if (typeof returnHandler !== \"function\") {\n                  end(new _serializableError__WEBPACK_IMPORTED_MODULE_14__[\n                  /* default */\n                  \"a\"]({\n                    code: -32603,\n                    message: \"JRPCEngine: 'next' return handlers must be functions\"\n                  }));\n                }\n\n                returnHandlers.push(returnHandler);\n              } // False indicates that the request should not end\n\n\n              resolve([null, false]);\n            }\n          };\n\n          try {\n            middleware(req, res, next, end);\n          } catch (error) {\n            end(error);\n          }\n        });\n      }\n      /**\n       * Serially executes array of return handlers. The request and response are\n       * assumed to be in their scope.\n       */\n\n    }, {\n      key: \"_runReturnHandlers\",\n      value: function () {\n        var _runReturnHandlers2 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_10___default.a.mark(function _callee7(handlers) {\n          var _iterator2, _step2, _loop;\n\n          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_10___default.a.wrap(function _callee7$(_context8) {\n            while (1) {\n              switch (_context8.prev = _context8.next) {\n                case 0:\n                  _iterator2 = _createForOfIteratorHelper(handlers);\n                  _context8.prev = 1;\n                  _loop = /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_10___default.a.mark(function _loop() {\n                    var handler;\n                    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_10___default.a.wrap(function _loop$(_context7) {\n                      while (1) {\n                        switch (_context7.prev = _context7.next) {\n                          case 0:\n                            handler = _step2.value;\n                            _context7.next = 3;\n                            return new Promise(function (resolve, reject) {\n                              handler(function (err) {\n                                return err ? reject(err) : resolve();\n                              });\n                            });\n\n                          case 3:\n                          case \"end\":\n                            return _context7.stop();\n                        }\n                      }\n                    }, _loop);\n                  });\n\n                  _iterator2.s();\n\n                case 4:\n                  if ((_step2 = _iterator2.n()).done) {\n                    _context8.next = 8;\n                    break;\n                  }\n\n                  return _context8.delegateYield(_loop(), \"t0\", 6);\n\n                case 6:\n                  _context8.next = 4;\n                  break;\n\n                case 8:\n                  _context8.next = 13;\n                  break;\n\n                case 10:\n                  _context8.prev = 10;\n                  _context8.t1 = _context8[\"catch\"](1);\n\n                  _iterator2.e(_context8.t1);\n\n                case 13:\n                  _context8.prev = 13;\n\n                  _iterator2.f();\n\n                  return _context8.finish(13);\n\n                case 16:\n                case \"end\":\n                  return _context8.stop();\n              }\n            }\n          }, _callee7, null, [[1, 10, 13, 16]]);\n        }));\n\n        function _runReturnHandlers(_x15) {\n          return _runReturnHandlers2.apply(this, arguments);\n        }\n\n        return _runReturnHandlers;\n      }()\n      /**\n       * Throws an error if the response has neither a result nor an error, or if\n       * the \"isComplete\" flag is falsy.\n       */\n\n    }, {\n      key: \"_checkForCompletion\",\n      value: function _checkForCompletion(req, res, isComplete) {\n        if (!(\"result\" in res) && !(\"error\" in res)) {\n          throw new _serializableError__WEBPACK_IMPORTED_MODULE_14__[\n          /* default */\n          \"a\"]({\n            code: -32603,\n            message: \"Response has no error or result for request\"\n          });\n        }\n\n        if (!isComplete) {\n          throw new _serializableError__WEBPACK_IMPORTED_MODULE_14__[\n          /* default */\n          \"a\"]({\n            code: -32603,\n            message: \"Nothing ended request\"\n          });\n        }\n      }\n    }]);\n\n    return JRPCEngine;\n  }(_safeEventEmitter__WEBPACK_IMPORTED_MODULE_13__[\n  /* default */\n  \"a\"]);\n\n  function mergeMiddleware(middlewareStack) {\n    var engine = new JRPCEngine();\n    middlewareStack.forEach(function (middleware) {\n      return engine.push(middleware);\n    });\n    return engine.asMiddleware();\n  }\n\n  function createEngineStream(opts) {\n    if (!opts || !opts.engine) {\n      throw new Error(\"Missing engine parameter!\");\n    }\n\n    var engine = opts.engine; // eslint-disable-next-line prefer-const\n\n    var stream;\n\n    function read() {\n      return undefined;\n    }\n\n    function write(req, _encoding, cb) {\n      engine.handle(req, function (_err, res) {\n        stream.push(res);\n      });\n      cb();\n    }\n\n    stream = new stream__WEBPACK_IMPORTED_MODULE_11__[\"Duplex\"]({\n      objectMode: true,\n      read: read,\n      write: write\n    }); // forward notifications\n\n    if (engine.on) {\n      engine.on(\"notification\", function (message) {\n        stream.push(message);\n      });\n    }\n\n    return stream;\n  }\n  /***/\n\n},\n/* 35 */\n\n/***/\nfunction (module, __webpack_exports__, __webpack_require__) {\n  \"use strict\";\n  /* harmony export (binding) */\n\n  __webpack_require__.d(__webpack_exports__, \"a\", function () {\n    return IGNORE_SUBSTREAM;\n  });\n  /* harmony export (binding) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"b\", function () {\n    return ObjectMultiplex;\n  });\n  /* harmony export (binding) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"c\", function () {\n    return setupMultiplex;\n  });\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(0);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__);\n  /* harmony import */\n\n\n  var end_of_stream__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(26);\n  /* harmony import */\n\n\n  var end_of_stream__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(end_of_stream__WEBPACK_IMPORTED_MODULE_7__);\n  /* harmony import */\n\n\n  var once__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(41);\n  /* harmony import */\n\n\n  var once__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(once__WEBPACK_IMPORTED_MODULE_8__);\n  /* harmony import */\n\n\n  var pump__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(42);\n  /* harmony import */\n\n\n  var pump__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(pump__WEBPACK_IMPORTED_MODULE_9__);\n  /* harmony import */\n\n\n  var stream__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(10);\n  /* harmony import */\n\n\n  var stream__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_10__);\n  /* harmony import */\n\n\n  var _substream__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(21);\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n\n      if (enumerableOnly) {\n        symbols = symbols.filter(function (sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        });\n      }\n\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        ownKeys(Object(source), true).forEach(function (key) {\n          _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n    }\n\n    return target;\n  }\n\n  function _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n    return function _createSuperInternal() {\n      var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(Derived),\n          result;\n\n      if (hasNativeReflectConstruct) {\n        var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(this).constructor;\n\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n\n      return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default()(this, result);\n    };\n  }\n\n  function _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  var IGNORE_SUBSTREAM = Symbol(\"IGNORE_SUBSTREAM\");\n\n  var ObjectMultiplex = /*#__PURE__*/function (_Duplex) {\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default()(ObjectMultiplex, _Duplex);\n\n    var _super = _createSuper(ObjectMultiplex);\n\n    function ObjectMultiplex() {\n      var _this;\n\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, ObjectMultiplex);\n\n      _this = _super.call(this, _objectSpread(_objectSpread({}, opts), {}, {\n        objectMode: true\n      }));\n\n      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2___default()(_this), \"_substreams\", void 0);\n\n      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2___default()(_this), \"getStream\", void 0);\n\n      _this._substreams = {};\n      return _this;\n    }\n\n    _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(ObjectMultiplex, [{\n      key: \"createStream\",\n      value: function createStream(name) {\n        // validate name\n        if (!name) {\n          throw new Error(\"ObjectMultiplex - name must not be empty\");\n        }\n\n        if (this._substreams[name]) {\n          throw new Error(\"ObjectMultiplex - Substream for name \\\"\".concat(name, \"\\\" already exists\"));\n        } // create substream\n\n\n        var substream = new _substream__WEBPACK_IMPORTED_MODULE_11__[\n        /* default */\n        \"a\"]({\n          parent: this,\n          name: name\n        });\n        this._substreams[name] = substream; // listen for parent stream to end\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n        anyStreamEnd(this, function (_error) {\n          return substream.destroy(_error || undefined);\n        });\n        return substream;\n      } // ignore streams (dont display orphaned data warning)\n\n    }, {\n      key: \"ignoreStream\",\n      value: function ignoreStream(name) {\n        // validate name\n        if (!name) {\n          throw new Error(\"ObjectMultiplex - name must not be empty\");\n        }\n\n        if (this._substreams[name]) {\n          throw new Error(\"ObjectMultiplex - Substream for name \\\"\".concat(name, \"\\\" already exists\"));\n        } // set\n\n\n        this._substreams[name] = IGNORE_SUBSTREAM;\n      } // eslint-disable-next-line class-methods-use-this\n\n    }, {\n      key: \"_read\",\n      value: function _read() {\n        return undefined;\n      }\n    }, {\n      key: \"_write\",\n      value: function _write(chunk, _encoding, callback) {\n        var name = chunk.name,\n            data = chunk.data;\n\n        if (!name) {\n          window.console.warn(\"ObjectMultiplex - malformed chunk without name \\\"\".concat(chunk, \"\\\"\"));\n          return callback();\n        } // get corresponding substream\n\n\n        var substream = this._substreams[name];\n\n        if (!substream) {\n          window.console.warn(\"ObjectMultiplex - orphaned data for stream \\\"\".concat(name, \"\\\"\"));\n          return callback();\n        } // push data into substream\n\n\n        if (substream !== IGNORE_SUBSTREAM) {\n          substream.push(data);\n        }\n\n        return callback();\n      }\n    }]);\n\n    return ObjectMultiplex;\n  }(stream__WEBPACK_IMPORTED_MODULE_10__[\"Duplex\"]); // util\n\n\n  function anyStreamEnd(stream, _cb) {\n    var cb = once__WEBPACK_IMPORTED_MODULE_8___default()(_cb);\n    end_of_stream__WEBPACK_IMPORTED_MODULE_7___default()(stream, {\n      readable: false\n    }, cb);\n    end_of_stream__WEBPACK_IMPORTED_MODULE_7___default()(stream, {\n      writable: false\n    }, cb);\n  }\n\n  function setupMultiplex(stream) {\n    var mux = new ObjectMultiplex();\n\n    mux.getStream = function streamHelper(name) {\n      if (this._substreams[name]) {\n        return this._substreams[name];\n      }\n\n      return this.createStream(name);\n    };\n\n    pump__WEBPACK_IMPORTED_MODULE_9___default()(stream, mux, stream, function (err) {\n      if (err) window.console.error(err);\n    });\n    return mux;\n  }\n  /***/\n\n},\n/* 36 */\n\n/***/\nfunction (module, __webpack_exports__, __webpack_require__) {\n  \"use strict\";\n  /* harmony export (binding) */\n\n  __webpack_require__.d(__webpack_exports__, \"a\", function () {\n    return PostMessageStream;\n  });\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(3);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(0);\n  /* harmony import */\n\n\n  var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__);\n  /* harmony import */\n\n\n  var stream__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(10);\n  /* harmony import */\n\n\n  var stream__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_8__);\n\n  function _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n    return function _createSuperInternal() {\n      var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(Derived),\n          result;\n\n      if (hasNativeReflectConstruct) {\n        var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(this).constructor;\n\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n\n      return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5___default()(this, result);\n    };\n  }\n\n  function _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function noop() {\n    return undefined;\n  }\n\n  var SYN = \"SYN\";\n  var ACK = \"ACK\";\n  var BRK = \"BRK\";\n\n  var PostMessageStream = /*#__PURE__*/function (_Duplex) {\n    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4___default()(PostMessageStream, _Duplex);\n\n    var _super = _createSuper(PostMessageStream);\n\n    function PostMessageStream(_ref) {\n      var _this;\n\n      var name = _ref.name,\n          target = _ref.target,\n          targetWindow = _ref.targetWindow;\n\n      _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, PostMessageStream);\n\n      _this = _super.call(this, {\n        objectMode: true\n      });\n\n      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3___default()(_this), \"_init\", void 0);\n\n      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3___default()(_this), \"_haveSyn\", void 0);\n\n      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3___default()(_this), \"_name\", void 0);\n\n      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3___default()(_this), \"_target\", void 0);\n\n      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3___default()(_this), \"_targetWindow\", void 0);\n\n      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3___default()(_this), \"_origin\", void 0);\n\n      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3___default()(_this), \"_onMessage\", void 0);\n\n      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3___default()(_this), \"_synIntervalId\", void 0);\n\n      _this._init = false;\n      _this._haveSyn = false;\n      _this._name = name;\n      _this._target = target; // target origin\n\n      _this._targetWindow = targetWindow || window;\n      _this._origin = targetWindow ? \"*\" : window.location.origin;\n      _this._onMessage = _this.onMessage.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3___default()(_this));\n      _this._synIntervalId = null;\n      window.addEventListener(\"message\", _this._onMessage, false);\n\n      _this._handShake();\n\n      return _this;\n    }\n\n    _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(PostMessageStream, [{\n      key: \"_break\",\n      value: function _break() {\n        this.cork();\n\n        this._write(BRK, null, noop);\n\n        this._haveSyn = false;\n        this._init = false;\n      }\n    }, {\n      key: \"_handShake\",\n      value: function _handShake() {\n        this._write(SYN, null, noop);\n\n        this.cork();\n      }\n    }, {\n      key: \"_onData\",\n      value: function _onData(data) {\n        if (!this._init) {\n          // listen for handshake\n          if (data === SYN) {\n            this._haveSyn = true;\n\n            this._write(ACK, null, noop);\n          } else if (data === ACK) {\n            this._init = true;\n\n            if (!this._haveSyn) {\n              this._write(ACK, null, noop);\n            }\n\n            this.uncork();\n          }\n        } else if (data === BRK) {\n          this._break();\n        } else {\n          // forward message\n          try {\n            this.push(data);\n          } catch (err) {\n            this.emit(\"error\", err);\n          }\n        }\n      }\n    }, {\n      key: \"_postMessage\",\n      value: function _postMessage(data) {\n        var originConstraint = this._origin;\n\n        if (_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(data) === \"object\") {\n          var dataObj = data;\n\n          if (_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(dataObj.data) === \"object\") {\n            var dataObjData = dataObj.data;\n\n            if (Array.isArray(dataObjData.params) && dataObjData.params.length > 0) {\n              var dataObjDataParam = dataObjData.params[0];\n\n              if (dataObjDataParam._origin) {\n                originConstraint = dataObjDataParam._origin;\n              } // add a constraint for the response\n\n\n              dataObjDataParam._origin = window.location.origin;\n            }\n          }\n        }\n\n        this._targetWindow.postMessage({\n          target: this._target,\n          data: data\n        }, originConstraint);\n      }\n    }, {\n      key: \"onMessage\",\n      value: function onMessage(event) {\n        var message = event.data; // validate message\n\n        if (this._origin !== \"*\" && event.origin !== this._origin || event.source !== this._targetWindow || _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(message) !== \"object\" || message.target !== this._name || !message.data) {\n          return;\n        }\n\n        this._onData(message.data);\n      } // eslint-disable-next-line class-methods-use-this\n\n    }, {\n      key: \"_read\",\n      value: function _read() {\n        return undefined;\n      }\n    }, {\n      key: \"_write\",\n      value: function _write(data, _, cb) {\n        this._postMessage(data);\n\n        cb();\n      }\n    }]);\n\n    return PostMessageStream;\n  }(stream__WEBPACK_IMPORTED_MODULE_8__[\"Duplex\"]);\n  /***/\n\n},\n/* 37 */\n\n/***/\nfunction (module, exports) {\n  /***/\n},\n/* 38 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@toruslabs/openlogin-utils\");\n  /***/\n},\n/* 39 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime/helpers/wrapNativeSuper\");\n  /***/\n},\n/* 40 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"fast-safe-stringify\");\n  /***/\n},\n/* 41 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"once\");\n  /***/\n},\n/* 42 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"pump\");\n  /***/\n},\n/* 43 */\n\n/***/\nfunction (module, __webpack_exports__, __webpack_require__) {\n  \"use strict\";\n\n  __webpack_require__.r(__webpack_exports__);\n  /* harmony import */\n\n\n  var _src_jrpc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18);\n  /* harmony reexport (safe) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"serializeError\", function () {\n    return _src_jrpc__WEBPACK_IMPORTED_MODULE_0__[\"h\"];\n  });\n  /* harmony reexport (safe) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"getRpcPromiseCallback\", function () {\n    return _src_jrpc__WEBPACK_IMPORTED_MODULE_0__[\"g\"];\n  });\n  /* harmony reexport (safe) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"createErrorMiddleware\", function () {\n    return _src_jrpc__WEBPACK_IMPORTED_MODULE_0__[\"b\"];\n  });\n  /* harmony reexport (safe) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"createStreamMiddleware\", function () {\n    return _src_jrpc__WEBPACK_IMPORTED_MODULE_0__[\"f\"];\n  });\n  /* harmony reexport (safe) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"createScaffoldMiddleware\", function () {\n    return _src_jrpc__WEBPACK_IMPORTED_MODULE_0__[\"e\"];\n  });\n  /* harmony reexport (safe) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"createIdRemapMiddleware\", function () {\n    return _src_jrpc__WEBPACK_IMPORTED_MODULE_0__[\"c\"];\n  });\n  /* harmony reexport (safe) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"createLoggerMiddleware\", function () {\n    return _src_jrpc__WEBPACK_IMPORTED_MODULE_0__[\"d\"];\n  });\n  /* harmony reexport (safe) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"createAsyncMiddleware\", function () {\n    return _src_jrpc__WEBPACK_IMPORTED_MODULE_0__[\"a\"];\n  });\n  /* harmony import */\n\n\n  var _src_jrpcEngine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(34);\n  /* harmony reexport (safe) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"JRPCEngine\", function () {\n    return _src_jrpcEngine__WEBPACK_IMPORTED_MODULE_1__[\"a\"];\n  });\n  /* harmony reexport (safe) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"mergeMiddleware\", function () {\n    return _src_jrpcEngine__WEBPACK_IMPORTED_MODULE_1__[\"c\"];\n  });\n  /* harmony reexport (safe) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"createEngineStream\", function () {\n    return _src_jrpcEngine__WEBPACK_IMPORTED_MODULE_1__[\"b\"];\n  });\n  /* harmony import */\n\n\n  var _src_mux__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35);\n  /* harmony reexport (safe) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"IGNORE_SUBSTREAM\", function () {\n    return _src_mux__WEBPACK_IMPORTED_MODULE_2__[\"a\"];\n  });\n  /* harmony reexport (safe) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"ObjectMultiplex\", function () {\n    return _src_mux__WEBPACK_IMPORTED_MODULE_2__[\"b\"];\n  });\n  /* harmony reexport (safe) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"setupMultiplex\", function () {\n    return _src_mux__WEBPACK_IMPORTED_MODULE_2__[\"c\"];\n  });\n  /* harmony import */\n\n\n  var _src_postMessageStream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(36);\n  /* harmony reexport (safe) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"PostMessageStream\", function () {\n    return _src_postMessageStream__WEBPACK_IMPORTED_MODULE_3__[\"a\"];\n  });\n  /* harmony import */\n\n\n  var _src_safeEventEmitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(14);\n  /* harmony reexport (safe) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"SafeEventEmitter\", function () {\n    return _src_safeEventEmitter__WEBPACK_IMPORTED_MODULE_4__[\"a\"];\n  });\n  /* harmony import */\n\n\n  var _src_serializableError__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8);\n  /* harmony reexport (safe) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"SerializableError\", function () {\n    return _src_serializableError__WEBPACK_IMPORTED_MODULE_5__[\"a\"];\n  });\n  /* harmony import */\n\n\n  var _src_substream__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(21);\n  /* harmony reexport (safe) */\n\n\n  __webpack_require__.d(__webpack_exports__, \"Substream\", function () {\n    return _src_substream__WEBPACK_IMPORTED_MODULE_6__[\"a\"];\n  });\n  /* harmony import */\n\n\n  var _src_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(37);\n  /* harmony import */\n\n\n  var _src_utils__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_src_utils__WEBPACK_IMPORTED_MODULE_7__);\n  /* harmony reexport (unknown) */\n\n\n  for (var __WEBPACK_IMPORT_KEY__ in _src_utils__WEBPACK_IMPORTED_MODULE_7__) {\n    if ([\"default\", \"PostMessageStream\", \"SafeEventEmitter\", \"SerializableError\", \"Substream\", \"serializeError\", \"getRpcPromiseCallback\", \"createErrorMiddleware\", \"createStreamMiddleware\", \"createScaffoldMiddleware\", \"createIdRemapMiddleware\", \"createLoggerMiddleware\", \"createAsyncMiddleware\", \"JRPCEngine\", \"mergeMiddleware\", \"createEngineStream\", \"IGNORE_SUBSTREAM\", \"ObjectMultiplex\", \"setupMultiplex\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function (key) {\n      __webpack_require__.d(__webpack_exports__, key, function () {\n        return _src_utils__WEBPACK_IMPORTED_MODULE_7__[key];\n      });\n    })(__WEBPACK_IMPORT_KEY__);\n  }\n  /***/\n\n},\n/* 44 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  exports.byteLength = byteLength;\n  exports.toByteArray = toByteArray;\n  exports.fromByteArray = fromByteArray;\n  var lookup = [];\n  var revLookup = [];\n  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n  for (var i = 0, len = code.length; i < len; ++i) {\n    lookup[i] = code[i];\n    revLookup[code.charCodeAt(i)] = i;\n  } // Support decoding URL-safe base64 strings, as Node.js does.\n  // See: https://en.wikipedia.org/wiki/Base64#URL_applications\n\n\n  revLookup['-'.charCodeAt(0)] = 62;\n  revLookup['_'.charCodeAt(0)] = 63;\n\n  function getLens(b64) {\n    var len = b64.length;\n\n    if (len % 4 > 0) {\n      throw new Error('Invalid string. Length must be a multiple of 4');\n    } // Trim off extra bytes after placeholder bytes are found\n    // See: https://github.com/beatgammit/base64-js/issues/42\n\n\n    var validLen = b64.indexOf('=');\n    if (validLen === -1) validLen = len;\n    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n    return [validLen, placeHoldersLen];\n  } // base64 is 4/3 + up to two characters of the original data\n\n\n  function byteLength(b64) {\n    var lens = getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n  }\n\n  function _byteLength(b64, validLen, placeHoldersLen) {\n    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n  }\n\n  function toByteArray(b64) {\n    var tmp;\n    var lens = getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n    var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars\n\n    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n    var i;\n\n    for (i = 0; i < len; i += 4) {\n      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n      arr[curByte++] = tmp >> 16 & 0xFF;\n      arr[curByte++] = tmp >> 8 & 0xFF;\n      arr[curByte++] = tmp & 0xFF;\n    }\n\n    if (placeHoldersLen === 2) {\n      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n      arr[curByte++] = tmp & 0xFF;\n    }\n\n    if (placeHoldersLen === 1) {\n      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n      arr[curByte++] = tmp >> 8 & 0xFF;\n      arr[curByte++] = tmp & 0xFF;\n    }\n\n    return arr;\n  }\n\n  function tripletToBase64(num) {\n    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n  }\n\n  function encodeChunk(uint8, start, end) {\n    var tmp;\n    var output = [];\n\n    for (var i = start; i < end; i += 3) {\n      tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);\n      output.push(tripletToBase64(tmp));\n    }\n\n    return output.join('');\n  }\n\n  function fromByteArray(uint8) {\n    var tmp;\n    var len = uint8.length;\n    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n\n    var parts = [];\n    var maxChunkLength = 16383; // must be multiple of 3\n    // go through the array every three bytes, we'll deal with trailing stuff later\n\n    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n      parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n    } // pad the end with zeros, but make sure to not forget the extra bytes\n\n\n    if (extraBytes === 1) {\n      tmp = uint8[len - 1];\n      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');\n    } else if (extraBytes === 2) {\n      tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');\n    }\n\n    return parts.join('');\n  }\n  /***/\n\n},\n/* 45 */\n\n/***/\nfunction (module, exports) {\n  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\n  exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n    var e, m;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var nBits = -7;\n    var i = isLE ? nBytes - 1 : 0;\n    var d = isLE ? -1 : 1;\n    var s = buffer[offset + i];\n    i += d;\n    e = s & (1 << -nBits) - 1;\n    s >>= -nBits;\n    nBits += eLen;\n\n    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n    m = e & (1 << -nBits) - 1;\n    e >>= -nBits;\n    nBits += mLen;\n\n    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n    if (e === 0) {\n      e = 1 - eBias;\n    } else if (e === eMax) {\n      return m ? NaN : (s ? -1 : 1) * Infinity;\n    } else {\n      m = m + Math.pow(2, mLen);\n      e = e - eBias;\n    }\n\n    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n  };\n\n  exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n    var e, m, c;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n    var i = isLE ? 0 : nBytes - 1;\n    var d = isLE ? 1 : -1;\n    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n    value = Math.abs(value);\n\n    if (isNaN(value) || value === Infinity) {\n      m = isNaN(value) ? 1 : 0;\n      e = eMax;\n    } else {\n      e = Math.floor(Math.log(value) / Math.LN2);\n\n      if (value * (c = Math.pow(2, -e)) < 1) {\n        e--;\n        c *= 2;\n      }\n\n      if (e + eBias >= 1) {\n        value += rt / c;\n      } else {\n        value += rt * Math.pow(2, 1 - eBias);\n      }\n\n      if (value * c >= 2) {\n        e++;\n        c /= 2;\n      }\n\n      if (e + eBias >= eMax) {\n        m = 0;\n        e = eMax;\n      } else if (e + eBias >= 1) {\n        m = (value * c - 1) * Math.pow(2, mLen);\n        e = e + eBias;\n      } else {\n        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n        e = 0;\n      }\n    }\n\n    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n    e = e << mLen | m;\n    eLen += mLen;\n\n    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n    buffer[offset + i - d] |= s * 128;\n  };\n  /***/\n\n},\n/* 46 */\n\n/***/\nfunction (module, exports) {\n  /* (ignored) */\n\n  /***/\n},\n/* 47 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  var Buffer = __webpack_require__(24).Buffer;\n\n  var util = __webpack_require__(48);\n\n  function copyBuffer(src, target, offset) {\n    src.copy(target, offset);\n  }\n\n  module.exports = function () {\n    function BufferList() {\n      _classCallCheck(this, BufferList);\n\n      this.head = null;\n      this.tail = null;\n      this.length = 0;\n    }\n\n    BufferList.prototype.push = function push(v) {\n      var entry = {\n        data: v,\n        next: null\n      };\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n      this.tail = entry;\n      ++this.length;\n    };\n\n    BufferList.prototype.unshift = function unshift(v) {\n      var entry = {\n        data: v,\n        next: this.head\n      };\n      if (this.length === 0) this.tail = entry;\n      this.head = entry;\n      ++this.length;\n    };\n\n    BufferList.prototype.shift = function shift() {\n      if (this.length === 0) return;\n      var ret = this.head.data;\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n      --this.length;\n      return ret;\n    };\n\n    BufferList.prototype.clear = function clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    };\n\n    BufferList.prototype.join = function join(s) {\n      if (this.length === 0) return '';\n      var p = this.head;\n      var ret = '' + p.data;\n\n      while (p = p.next) {\n        ret += s + p.data;\n      }\n\n      return ret;\n    };\n\n    BufferList.prototype.concat = function concat(n) {\n      if (this.length === 0) return Buffer.alloc(0);\n      if (this.length === 1) return this.head.data;\n      var ret = Buffer.allocUnsafe(n >>> 0);\n      var p = this.head;\n      var i = 0;\n\n      while (p) {\n        copyBuffer(p.data, ret, i);\n        i += p.data.length;\n        p = p.next;\n      }\n\n      return ret;\n    };\n\n    return BufferList;\n  }();\n\n  if (util && util.inspect && util.inspect.custom) {\n    module.exports.prototype[util.inspect.custom] = function () {\n      var obj = util.inspect({\n        length: this.length\n      });\n      return this.constructor.name + ' ' + obj;\n    };\n  }\n  /***/\n\n},\n/* 48 */\n\n/***/\nfunction (module, exports) {\n  /* (ignored) */\n\n  /***/\n},\n/* 49 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  /* WEBPACK VAR INJECTION */\n  (function (global) {\n    var scope = typeof global !== \"undefined\" && global || typeof self !== \"undefined\" && self || window;\n    var apply = Function.prototype.apply; // DOM APIs, for completeness\n\n    exports.setTimeout = function () {\n      return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n    };\n\n    exports.setInterval = function () {\n      return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n    };\n\n    exports.clearTimeout = exports.clearInterval = function (timeout) {\n      if (timeout) {\n        timeout.close();\n      }\n    };\n\n    function Timeout(id, clearFn) {\n      this._id = id;\n      this._clearFn = clearFn;\n    }\n\n    Timeout.prototype.unref = Timeout.prototype.ref = function () {};\n\n    Timeout.prototype.close = function () {\n      this._clearFn.call(scope, this._id);\n    }; // Does not start the time, just sets up the members needed.\n\n\n    exports.enroll = function (item, msecs) {\n      clearTimeout(item._idleTimeoutId);\n      item._idleTimeout = msecs;\n    };\n\n    exports.unenroll = function (item) {\n      clearTimeout(item._idleTimeoutId);\n      item._idleTimeout = -1;\n    };\n\n    exports._unrefActive = exports.active = function (item) {\n      clearTimeout(item._idleTimeoutId);\n      var msecs = item._idleTimeout;\n\n      if (msecs >= 0) {\n        item._idleTimeoutId = setTimeout(function onTimeout() {\n          if (item._onTimeout) item._onTimeout();\n        }, msecs);\n      }\n    }; // setimmediate attaches itself to the global object\n\n\n    __webpack_require__(50); // On some exotic environments, it's not clear which object `setimmediate` was\n    // able to install onto.  Search each possibility in the same order as the\n    // `setimmediate` library.\n\n\n    exports.setImmediate = typeof self !== \"undefined\" && self.setImmediate || typeof global !== \"undefined\" && global.setImmediate || this && this.setImmediate;\n    exports.clearImmediate = typeof self !== \"undefined\" && self.clearImmediate || typeof global !== \"undefined\" && global.clearImmediate || this && this.clearImmediate;\n    /* WEBPACK VAR INJECTION */\n  }).call(this, __webpack_require__(13));\n  /***/\n},\n/* 50 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  /* WEBPACK VAR INJECTION */\n  (function (global, process) {\n    (function (global, undefined) {\n      \"use strict\";\n\n      if (global.setImmediate) {\n        return;\n      }\n\n      var nextHandle = 1; // Spec says greater than zero\n\n      var tasksByHandle = {};\n      var currentlyRunningATask = false;\n      var doc = global.document;\n      var registerImmediate;\n\n      function setImmediate(callback) {\n        // Callback can either be a function or a string\n        if (typeof callback !== \"function\") {\n          callback = new Function(\"\" + callback);\n        } // Copy function arguments\n\n\n        var args = new Array(arguments.length - 1);\n\n        for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n        } // Store and register the task\n\n\n        var task = {\n          callback: callback,\n          args: args\n        };\n        tasksByHandle[nextHandle] = task;\n        registerImmediate(nextHandle);\n        return nextHandle++;\n      }\n\n      function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n      }\n\n      function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n\n        switch (args.length) {\n          case 0:\n            callback();\n            break;\n\n          case 1:\n            callback(args[0]);\n            break;\n\n          case 2:\n            callback(args[0], args[1]);\n            break;\n\n          case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n\n          default:\n            callback.apply(undefined, args);\n            break;\n        }\n      }\n\n      function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n          // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n          // \"too much recursion\" error.\n          setTimeout(runIfPresent, 0, handle);\n        } else {\n          var task = tasksByHandle[handle];\n\n          if (task) {\n            currentlyRunningATask = true;\n\n            try {\n              run(task);\n            } finally {\n              clearImmediate(handle);\n              currentlyRunningATask = false;\n            }\n          }\n        }\n      }\n\n      function installNextTickImplementation() {\n        registerImmediate = function registerImmediate(handle) {\n          process.nextTick(function () {\n            runIfPresent(handle);\n          });\n        };\n      }\n\n      function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n          var postMessageIsAsynchronous = true;\n          var oldOnMessage = global.onmessage;\n\n          global.onmessage = function () {\n            postMessageIsAsynchronous = false;\n          };\n\n          global.postMessage(\"\", \"*\");\n          global.onmessage = oldOnMessage;\n          return postMessageIsAsynchronous;\n        }\n      }\n\n      function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n\n        var onGlobalMessage = function onGlobalMessage(event) {\n          if (event.source === global && typeof event.data === \"string\" && event.data.indexOf(messagePrefix) === 0) {\n            runIfPresent(+event.data.slice(messagePrefix.length));\n          }\n        };\n\n        if (global.addEventListener) {\n          global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n          global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function registerImmediate(handle) {\n          global.postMessage(messagePrefix + handle, \"*\");\n        };\n      }\n\n      function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n\n        channel.port1.onmessage = function (event) {\n          var handle = event.data;\n          runIfPresent(handle);\n        };\n\n        registerImmediate = function registerImmediate(handle) {\n          channel.port2.postMessage(handle);\n        };\n      }\n\n      function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n\n        registerImmediate = function registerImmediate(handle) {\n          // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n          // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n          var script = doc.createElement(\"script\");\n\n          script.onreadystatechange = function () {\n            runIfPresent(handle);\n            script.onreadystatechange = null;\n            html.removeChild(script);\n            script = null;\n          };\n\n          html.appendChild(script);\n        };\n      }\n\n      function installSetTimeoutImplementation() {\n        registerImmediate = function registerImmediate(handle) {\n          setTimeout(runIfPresent, 0, handle);\n        };\n      } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n\n\n      var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n      attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.\n\n      if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n      } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n      } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n      } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n      } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n      }\n\n      attachTo.setImmediate = setImmediate;\n      attachTo.clearImmediate = clearImmediate;\n    })(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self);\n    /* WEBPACK VAR INJECTION */\n\n  }).call(this, __webpack_require__(13), __webpack_require__(19));\n  /***/\n},\n/* 51 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  /* WEBPACK VAR INJECTION */\n  (function (global) {\n    /**\n     * Module exports.\n     */\n    module.exports = deprecate;\n    /**\n     * Mark that a method should not be used.\n     * Returns a modified function which warns once by default.\n     *\n     * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n     *\n     * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n     * will throw an Error when invoked.\n     *\n     * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n     * will invoke `console.trace()` instead of `console.error()`.\n     *\n     * @param {Function} fn - the function to deprecate\n     * @param {String} msg - the string to print to the console when `fn` is invoked\n     * @returns {Function} a new \"deprecated\" version of `fn`\n     * @api public\n     */\n\n    function deprecate(fn, msg) {\n      if (config('noDeprecation')) {\n        return fn;\n      }\n\n      var warned = false;\n\n      function deprecated() {\n        if (!warned) {\n          if (config('throwDeprecation')) {\n            throw new Error(msg);\n          } else if (config('traceDeprecation')) {\n            console.trace(msg);\n          } else {\n            console.warn(msg);\n          }\n\n          warned = true;\n        }\n\n        return fn.apply(this, arguments);\n      }\n\n      return deprecated;\n    }\n    /**\n     * Checks `localStorage` for boolean values for the given `name`.\n     *\n     * @param {String} name\n     * @returns {Boolean}\n     * @api private\n     */\n\n\n    function config(name) {\n      // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n      try {\n        if (!global.localStorage) return false;\n      } catch (_) {\n        return false;\n      }\n\n      var val = global.localStorage[name];\n      if (null == val) return false;\n      return String(val).toLowerCase() === 'true';\n    }\n    /* WEBPACK VAR INJECTION */\n\n  }).call(this, __webpack_require__(13));\n  /***/\n},\n/* 52 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n\n  /* eslint-disable node/no-deprecated-api */\n  var buffer = __webpack_require__(30);\n\n  var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers\n\n  function copyProps(src, dst) {\n    for (var key in src) {\n      dst[key] = src[key];\n    }\n  }\n\n  if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n    module.exports = buffer;\n  } else {\n    // Copy properties from require('buffer')\n    copyProps(buffer, exports);\n    exports.Buffer = SafeBuffer;\n  }\n\n  function SafeBuffer(arg, encodingOrOffset, length) {\n    return Buffer(arg, encodingOrOffset, length);\n  }\n\n  SafeBuffer.prototype = Object.create(Buffer.prototype); // Copy static methods from Buffer\n\n  copyProps(Buffer, SafeBuffer);\n\n  SafeBuffer.from = function (arg, encodingOrOffset, length) {\n    if (typeof arg === 'number') {\n      throw new TypeError('Argument must not be a number');\n    }\n\n    return Buffer(arg, encodingOrOffset, length);\n  };\n\n  SafeBuffer.alloc = function (size, fill, encoding) {\n    if (typeof size !== 'number') {\n      throw new TypeError('Argument must be a number');\n    }\n\n    var buf = Buffer(size);\n\n    if (fill !== undefined) {\n      if (typeof encoding === 'string') {\n        buf.fill(fill, encoding);\n      } else {\n        buf.fill(fill);\n      }\n    } else {\n      buf.fill(0);\n    }\n\n    return buf;\n  };\n\n  SafeBuffer.allocUnsafe = function (size) {\n    if (typeof size !== 'number') {\n      throw new TypeError('Argument must be a number');\n    }\n\n    return Buffer(size);\n  };\n\n  SafeBuffer.allocUnsafeSlow = function (size) {\n    if (typeof size !== 'number') {\n      throw new TypeError('Argument must be a number');\n    }\n\n    return buffer.SlowBuffer(size);\n  };\n  /***/\n\n},\n/* 53 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\"; // Copyright Joyent, Inc. and other Node contributors.\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a\n  // copy of this software and associated documentation files (the\n  // \"Software\"), to deal in the Software without restriction, including\n  // without limitation the rights to use, copy, modify, merge, publish,\n  // distribute, sublicense, and/or sell copies of the Software, and to permit\n  // persons to whom the Software is furnished to do so, subject to the\n  // following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included\n  // in all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n  // USE OR OTHER DEALINGS IN THE SOFTWARE.\n  // a passthrough stream.\n  // basically just the most minimal sort of Transform stream.\n  // Every written chunk gets output as-is.\n\n  module.exports = PassThrough;\n\n  var Transform = __webpack_require__(33);\n  /*<replacement>*/\n\n\n  var util = Object.create(__webpack_require__(16));\n  util.inherits = __webpack_require__(12);\n  /*</replacement>*/\n\n  util.inherits(PassThrough, Transform);\n\n  function PassThrough(options) {\n    if (!(this instanceof PassThrough)) return new PassThrough(options);\n    Transform.call(this, options);\n  }\n\n  PassThrough.prototype._transform = function (chunk, encoding, cb) {\n    cb(null, chunk);\n  };\n  /***/\n\n},\n/* 54 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  module.exports = __webpack_require__(25);\n  /***/\n},\n/* 55 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  module.exports = __webpack_require__(11);\n  /***/\n},\n/* 56 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  module.exports = __webpack_require__(23).Transform;\n  /***/\n},\n/* 57 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  module.exports = __webpack_require__(23).PassThrough;\n  /***/\n}\n/******/\n]);","map":null,"metadata":{},"sourceType":"script"}