{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:/Users/kroni/Desktop/RIFF RAFFLE SITE PNSC/Riff-Raffle-Solana-NFT final/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:/Users/kroni/Desktop/RIFF RAFFLE SITE PNSC/Riff-Raffle-Solana-NFT final/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _toConsumableArray = require(\"C:/Users/kroni/Desktop/RIFF RAFFLE SITE PNSC/Riff-Raffle-Solana-NFT final/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _objectSpread = require(\"C:/Users/kroni/Desktop/RIFF RAFFLE SITE PNSC/Riff-Raffle-Solana-NFT final/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"C:/Users/kroni/Desktop/RIFF RAFFLE SITE PNSC/Riff-Raffle-Solana-NFT final/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/kroni/Desktop/RIFF RAFFLE SITE PNSC/Riff-Raffle-Solana-NFT final/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MarketProxyBuilder = exports.MarketProxyInstruction = exports.MarketProxy = void 0;\n\nvar anchor_1 = require(\"@project-serum/anchor\");\n\nvar market_1 = require(\"../market\");\n\nvar instructions_1 = require(\"../instructions\"); // MarketProxy provides an API for constructing transactions to an on-chain\n// DEX proxy, which relays all instructions to the orderbook. Minimally, this\n// requires two modifications for DEX instructions.\n//\n// 1. Transasctions are sent to the proxy program--not the DEX.\n// 2. The DEX program ID must be inserted as the first account in instructions\n//    using the proxy relay, so that the proxy can use the account for CPI.\n//    The program is responsible for removing this account before relaying to\n//    the dex.\n//\n// Additionally, a middleware abstraction is provided so that one can configure\n// both the client and the smart contract with the ability to send and processs\n// arbitrary accounts and instruction data *in addition* to what the Serum DEX\n// expects.\n//\n// Similar to the layers of an onion, each middleware wraps a transaction\n// request with additional accounts and instruction data before sending it to\n// the program. Upon receiving the request, the program--with its own set of\n// middleware-- unwraps and processes each layer. The process ends with all\n// layers being unwrapped and the proxy relaying the transaction to the DEX.\n//\n// As a result, the order of the middleware matters and the client should\n// process middleware in the *reverse* order of the proxy smart contract.\n\n\nvar MarketProxy = /*#__PURE__*/function () {\n  // Ctor.\n  function MarketProxy(market, instruction) {\n    _classCallCheck(this, MarketProxy);\n\n    this._market = market;\n    this._instruction = instruction;\n  } // DEX market being proxied.\n\n\n  _createClass(MarketProxy, [{\n    key: \"market\",\n    get: function get() {\n      return this._market;\n    } // Instruction namespace.\n\n  }, {\n    key: \"instruction\",\n    get: function get() {\n      return this._instruction;\n    } // Serum DEX program ID.\n\n  }, {\n    key: \"dexProgramId\",\n    get: function get() {\n      return this._market.programId;\n    } // Proxy program ID.\n\n  }, {\n    key: \"proxyProgramId\",\n    get: function get() {\n      return this._instruction.proxyProgramId;\n    }\n  }]);\n\n  return MarketProxy;\n}();\n\nexports.MarketProxy = MarketProxy; // Instruction builder for the market proxy.\n\nvar MarketProxyInstruction = /*#__PURE__*/function () {\n  function MarketProxyInstruction(proxyProgramId, dexProgramId, market, middlewares) {\n    _classCallCheck(this, MarketProxyInstruction);\n\n    this._proxyProgramId = proxyProgramId;\n    this._dexProgramId = dexProgramId;\n    this._market = market;\n    this._middlewares = middlewares;\n  } // Program ID of the permissioning proxy program.\n\n\n  _createClass(MarketProxyInstruction, [{\n    key: \"proxyProgramId\",\n    get: function get() {\n      return this._proxyProgramId;\n    }\n  }, {\n    key: \"newOrderV3\",\n    value: function newOrderV3(params) {\n      var tradeIx = this._market.makeNewOrderV3Instruction(_objectSpread(_objectSpread({}, params), {}, {\n        programId: this._proxyProgramId\n      }));\n\n      this._middlewares.forEach(function (mw) {\n        return mw.newOrderV3(tradeIx);\n      });\n\n      return this.proxy(tradeIx);\n    }\n  }, {\n    key: \"initOpenOrders\",\n    value: function initOpenOrders(owner, market, openOrders, marketAuthority) {\n      var ix = instructions_1.DexInstructions.initOpenOrders({\n        market: market,\n        openOrders: openOrders,\n        owner: owner,\n        programId: this._proxyProgramId,\n        marketAuthority: marketAuthority\n      });\n\n      this._middlewares.forEach(function (mw) {\n        return mw.initOpenOrders(ix);\n      });\n\n      return this.proxy(ix);\n    }\n  }, {\n    key: \"cancelOrder\",\n    value: function cancelOrder(owner, order) {\n      var ix = this._market.makeCancelOrderInstruction( // @ts-ignore\n      null, // Not used by the function.\n      owner, order);\n\n      this._middlewares.forEach(function (mw) {\n        return mw.cancelOrderV2(ix);\n      });\n\n      return this.proxy(ix);\n    }\n  }, {\n    key: \"cancelOrderByClientId\",\n    value: function cancelOrderByClientId(owner, openOrders, clientId) {\n      var ix = instructions_1.DexInstructions.cancelOrderByClientIdV2({\n        market: this._market.address,\n        openOrders: openOrders,\n        owner: owner,\n        bids: this._market.decoded.bids,\n        asks: this._market.decoded.asks,\n        eventQueue: this._market.decoded.eventQueue,\n        clientId: clientId,\n        programId: this._proxyProgramId\n      });\n\n      this._middlewares.forEach(function (mw) {\n        return mw.cancelOrderByClientIdV2(ix);\n      });\n\n      return this.proxy(ix);\n    }\n  }, {\n    key: \"settleFunds\",\n    value: function settleFunds(openOrders, owner, baseWallet, quoteWallet, referrerQuoteWallet) {\n      var ix = instructions_1.DexInstructions.settleFunds({\n        market: this._market.address,\n        openOrders: openOrders,\n        owner: owner,\n        baseVault: this._market.decoded.baseVault,\n        quoteVault: this._market.decoded.quoteVault,\n        baseWallet: baseWallet,\n        quoteWallet: quoteWallet,\n        vaultSigner: anchor_1.utils.publicKey.createProgramAddressSync([this._market.address.toBuffer(), this._market.decoded.vaultSignerNonce.toArrayLike(Buffer, 'le', 8)], this._dexProgramId),\n        programId: this._proxyProgramId,\n        referrerQuoteWallet: referrerQuoteWallet\n      });\n\n      this._middlewares.forEach(function (mw) {\n        return mw.settleFunds(ix);\n      });\n\n      return this.proxy(ix);\n    }\n  }, {\n    key: \"closeOpenOrders\",\n    value: function closeOpenOrders(openOrders, owner, solWallet) {\n      var ix = instructions_1.DexInstructions.closeOpenOrders({\n        market: this._market.address,\n        openOrders: openOrders,\n        owner: owner,\n        solWallet: solWallet,\n        programId: this._proxyProgramId\n      });\n\n      this._middlewares.forEach(function (mw) {\n        return mw.closeOpenOrders(ix);\n      });\n\n      return this.proxy(ix);\n    }\n  }, {\n    key: \"prune\",\n    value: function prune(openOrders, openOrdersOwner, limit) {\n      if (!limit) {\n        limit = 65535;\n      }\n\n      var ix = instructions_1.DexInstructions.prune({\n        market: this._market.address,\n        bids: this._market.decoded.bids,\n        asks: this._market.decoded.asks,\n        eventQueue: this._market.decoded.eventQueue,\n        pruneAuthority: this._market.decoded.pruneAuthority,\n        openOrders: openOrders,\n        openOrdersOwner: openOrdersOwner,\n        programId: this._proxyProgramId,\n        limit: limit\n      });\n\n      this._middlewares.forEach(function (mw) {\n        return mw.prune(ix);\n      });\n\n      return this.proxy(ix);\n    } // Adds the serum dex account to the instruction so that proxies can\n    // relay (CPI requires the executable account).\n\n  }, {\n    key: \"proxy\",\n    value: function proxy(ix) {\n      ix.keys = [{\n        pubkey: this._dexProgramId,\n        isWritable: false,\n        isSigner: false\n      }].concat(_toConsumableArray(ix.keys));\n      return ix;\n    }\n  }]);\n\n  return MarketProxyInstruction;\n}();\n\nexports.MarketProxyInstruction = MarketProxyInstruction;\n\nvar MarketProxyBuilder = /*#__PURE__*/function () {\n  function MarketProxyBuilder() {\n    _classCallCheck(this, MarketProxyBuilder);\n\n    this._middlewares = [];\n  }\n\n  _createClass(MarketProxyBuilder, [{\n    key: \"middleware\",\n    value: function middleware(mw) {\n      this._middlewares.push(mw);\n\n      return this;\n    }\n  }, {\n    key: \"load\",\n    value: function () {\n      var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {\n        var connection, market, _ref$options, options, dexProgramId, proxyProgramId, marketClient, instruction;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                connection = _ref.connection, market = _ref.market, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options, dexProgramId = _ref.dexProgramId, proxyProgramId = _ref.proxyProgramId;\n                _context.next = 3;\n                return market_1.Market.load(connection, market, options, dexProgramId, market_1.MARKET_STATE_LAYOUT_V3);\n\n              case 3:\n                marketClient = _context.sent;\n                instruction = new MarketProxyInstruction(proxyProgramId, dexProgramId, marketClient, this._middlewares);\n                return _context.abrupt(\"return\", new MarketProxy(marketClient, instruction));\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function load(_x) {\n        return _load.apply(this, arguments);\n      }\n\n      return load;\n    }()\n  }]);\n\n  return MarketProxyBuilder;\n}();\n\nexports.MarketProxyBuilder = MarketProxyBuilder;","map":null,"metadata":{},"sourceType":"script"}