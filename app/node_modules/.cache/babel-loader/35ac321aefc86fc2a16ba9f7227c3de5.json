{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\kroni\\\\Desktop\\\\RIFF RAFFLE SITE PNSC\\\\Riff-Raffle-Solana-NFT\\\\app\\\\src\\\\providers\\\\RafflesStoreProvider.tsx\",\n    _s = $RefreshSig$();\n\nimport React, { createContext, useCallback, useEffect, useState } from 'react';\nimport { PublicKey } from '@solana/web3.js';\nimport { useProgramApis } from '../hooks/useProgramApis';\nimport { fetchPrizes, fetchProceedsAccount, getRaffleProgramAccounts, toEntrantsProcessed } from '../lib/store';\nimport { cloneDeep } from 'lodash';\nimport { areEqualObjects } from '../lib/utils';\nimport { useConnection } from '@solana/wallet-adapter-react';\nimport { RAFFLES_WHITELIST } from '../config/raffleWhitelist';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// @ts-ignore\nexport const RafflesStoreContext = /*#__PURE__*/createContext();\n\nconst RafflesStoreProvider = ({\n  children = null\n}) => {\n  _s();\n\n  const {\n    connection\n  } = useConnection();\n  const {\n    draffleClient\n  } = useProgramApis();\n  const [fetching, setFetching] = useState(true); // prevents messy first render, but probably not optimal\n\n  const [raffles, setRaffles] = useState(new Map());\n\n  const getAssociatedRaffleData = async (raffleRaw, raffleMetaData, draffleClient, connection, entrantsDataRaw) => {\n    const proceedsAccount = await fetchProceedsAccount(raffleRaw.publicKey, draffleClient, connection);\n    let entrants = new Map();\n\n    if (!entrantsDataRaw) {\n      try {\n        entrantsDataRaw = await draffleClient.account.entrants.fetch(raffleRaw.account.entrants);\n      } catch {\n        // TODO: Merge ended raffle data stored off-chain here\n        console.log(`Raffle ${raffleRaw.publicKey} entrants account is closed`);\n        entrantsDataRaw = {\n          entrants: [],\n          max: 0,\n          total: 0\n        };\n      }\n    }\n\n    entrants = toEntrantsProcessed(entrantsDataRaw);\n    const prizes = await fetchPrizes(raffleRaw.publicKey, draffleClient, raffleRaw.account.totalPrizes);\n    const endTimestamp = new Date(raffleRaw.account.endTimestamp.toNumber() * 1000);\n    return {\n      publicKey: raffleRaw.publicKey,\n      metadata: raffleMetaData,\n      endTimestamp,\n      entrantsCap: entrantsDataRaw.max,\n      entrants,\n      entrantsRaw: entrantsDataRaw.entrants,\n      totalTickets: entrantsDataRaw.total,\n      entrantsAccountAddress: raffleRaw.account.entrants,\n      randomness: raffleRaw.account.randomness,\n      prizes,\n      proceeds: {\n        address: proceedsAccount.address,\n        ticketPrice: raffleRaw.account.ticketPrice,\n        mint: proceedsAccount.mintInfo\n      },\n      isEnded: endTimestamp < new Date()\n    };\n  };\n\n  const fetchAllRaffles = useCallback(async (showAll = false) => {\n    // LOOK HERE\n    setFetching(true);\n    let raffleDataRawProgramAccounts = [];\n    let entrantsDataRawProgramAccounts = [];\n\n    try {\n      [raffleDataRawProgramAccounts, entrantsDataRawProgramAccounts] = await getRaffleProgramAccounts(draffleClient);\n    } catch (e) {\n      console.log(e);\n    }\n\n    raffleDataRawProgramAccounts = raffleDataRawProgramAccounts.filter(({\n      publicKey\n    }) => {\n      console.log({\n        showAll\n      });\n      console.log(RAFFLES_WHITELIST.has(publicKey.toBase58()));\n      return showAll || RAFFLES_WHITELIST.has(publicKey.toBase58());\n    });\n    console.log({\n      raffleDataRawProgramAccounts\n    });\n    const newRaffles = (await Promise.all(raffleDataRawProgramAccounts.map(async raffleRaw => {\n      var _entrantsDataRawProgr;\n\n      return getAssociatedRaffleData(raffleRaw, RAFFLES_WHITELIST.get(raffleRaw.publicKey.toString()) || {\n        name: 'Unnamed Raffle',\n        // LOOOK HERE\n        alternatePurchaseMints: []\n      }, draffleClient, connection, (_entrantsDataRawProgr = entrantsDataRawProgramAccounts.find(({\n        publicKey\n      }) => publicKey.equals(raffleRaw.account.entrants))) === null || _entrantsDataRawProgr === void 0 ? void 0 : _entrantsDataRawProgr.account);\n    }))).reduce((acc, raffle) => {\n      acc.set(raffle.publicKey.toString(), raffle);\n      return acc;\n    }, new Map());\n    setRaffles(newRaffles);\n    setFetching(false);\n  }, [connection, draffleClient]);\n  const updateRaffleById = useCallback(async raffleId => {\n    if (!raffles.has(raffleId.toString()) || !RAFFLES_WHITELIST.has(raffleId)) return;\n    setFetching(true);\n    const updatedRaffleRaw = await draffleClient.account.raffle.fetch(new PublicKey(raffleId));\n    const updatedRaffle = await getAssociatedRaffleData({\n      publicKey: new PublicKey(raffleId),\n      account: updatedRaffleRaw\n    }, RAFFLES_WHITELIST.get(raffleId), draffleClient, connection);\n\n    if (!areEqualObjects(raffles.get(raffleId.toString()), updatedRaffle)) {\n      setRaffles(currentRaffles => {\n        let newRaffles = cloneDeep(currentRaffles);\n        newRaffles = newRaffles.set(raffleId, updatedRaffle);\n        return newRaffles;\n      });\n    }\n\n    setFetching(false);\n  }, [connection, draffleClient, raffles, setRaffles]);\n  useEffect(() => {\n    fetchAllRaffles();\n  }, [fetchAllRaffles]);\n  return /*#__PURE__*/_jsxDEV(RafflesStoreContext.Provider, {\n    value: {\n      raffles,\n      fetchAllRaffles,\n      updateRaffleById,\n      fetching\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 191,\n    columnNumber: 5\n  }, this);\n};\n\n_s(RafflesStoreProvider, \"JzfiKckw+BnZnoWvWnz/L9oaMTQ=\", false, function () {\n  return [useConnection, useProgramApis];\n});\n\n_c = RafflesStoreProvider;\nexport default RafflesStoreProvider;\n\nvar _c;\n\n$RefreshReg$(_c, \"RafflesStoreProvider\");","map":{"version":3,"sources":["C:/Users/kroni/Desktop/RIFF RAFFLE SITE PNSC/Riff-Raffle-Solana-NFT/app/src/providers/RafflesStoreProvider.tsx"],"names":["React","createContext","useCallback","useEffect","useState","PublicKey","useProgramApis","fetchPrizes","fetchProceedsAccount","getRaffleProgramAccounts","toEntrantsProcessed","cloneDeep","areEqualObjects","useConnection","RAFFLES_WHITELIST","RafflesStoreContext","RafflesStoreProvider","children","connection","draffleClient","fetching","setFetching","raffles","setRaffles","Map","getAssociatedRaffleData","raffleRaw","raffleMetaData","entrantsDataRaw","proceedsAccount","publicKey","entrants","account","fetch","console","log","max","total","prizes","totalPrizes","endTimestamp","Date","toNumber","metadata","entrantsCap","entrantsRaw","totalTickets","entrantsAccountAddress","randomness","proceeds","address","ticketPrice","mint","mintInfo","isEnded","fetchAllRaffles","showAll","raffleDataRawProgramAccounts","entrantsDataRawProgramAccounts","e","filter","has","toBase58","newRaffles","Promise","all","map","get","toString","name","alternatePurchaseMints","find","equals","reduce","acc","raffle","set","updateRaffleById","raffleId","updatedRaffleRaw","updatedRaffle","currentRaffles"],"mappings":"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","sourcesContent":["import React, {\r\n  createContext,\r\n  FC,\r\n  useCallback,\r\n  useEffect,\r\n  useState,\r\n} from 'react';\r\nimport { ProgramAccount } from '@project-serum/anchor';\r\nimport { Connection, PublicKey } from '@solana/web3.js';\r\n\r\nimport {\r\n  DraffleProgram,\r\n  EntrantsDataRaw,\r\n  RaffleDataRaw,\r\n} from './ProgramApisProvider';\r\nimport { useProgramApis } from '../hooks/useProgramApis';\r\nimport { Entrant, Raffle, RaffleMetaData } from '../lib/types';\r\nimport {\r\n  fetchPrizes,\r\n  fetchProceedsAccount,\r\n  getRaffleProgramAccounts,\r\n  toEntrantsProcessed,\r\n} from '../lib/store';\r\nimport { cloneDeep } from 'lodash';\r\nimport { areEqualObjects } from '../lib/utils';\r\nimport { useConnection } from '@solana/wallet-adapter-react';\r\nimport { RAFFLES_WHITELIST } from '../config/raffleWhitelist';\r\n\r\nexport interface RafflesStore {\r\n  raffles: Map<string, Raffle>;\r\n  fetchAllRaffles: (showAll?: boolean) => void;\r\n  updateRaffleById: (raffleId: string) => void;\r\n  fetching: boolean;\r\n}\r\n\r\n// @ts-ignore\r\nexport const RafflesStoreContext = createContext<RafflesStore>();\r\n\r\nconst RafflesStoreProvider: FC = ({ children = null as any }) => {\r\n  const { connection } = useConnection();\r\n  const { draffleClient } = useProgramApis();\r\n\r\n  const [fetching, setFetching] = useState<boolean>(true); // prevents messy first render, but probably not optimal\r\n  const [raffles, setRaffles] = useState<Map<string, Raffle>>(\r\n    new Map<string, Raffle>()\r\n  );\r\n\r\n  const getAssociatedRaffleData = async (\r\n    raffleRaw: ProgramAccount<RaffleDataRaw>,\r\n    raffleMetaData: RaffleMetaData,\r\n    draffleClient: DraffleProgram,\r\n    connection: Connection,\r\n    entrantsDataRaw?: EntrantsDataRaw\r\n  ): Promise<Raffle> => {\r\n    const proceedsAccount = await fetchProceedsAccount(\r\n      raffleRaw.publicKey,\r\n      draffleClient,\r\n      connection\r\n    );\r\n    let entrants = new Map<string, Entrant>();\r\n    if (!entrantsDataRaw) {\r\n      try {\r\n        entrantsDataRaw = await draffleClient.account.entrants.fetch(\r\n          raffleRaw.account.entrants\r\n        );\r\n      } catch {\r\n        // TODO: Merge ended raffle data stored off-chain here\r\n        console.log(`Raffle ${raffleRaw.publicKey} entrants account is closed`);\r\n\r\n        entrantsDataRaw = {\r\n          entrants: [],\r\n          max: 0,\r\n          total: 0,\r\n        };\r\n      }\r\n    }\r\n\r\n    entrants = toEntrantsProcessed(entrantsDataRaw);\r\n\r\n    const prizes = await fetchPrizes(\r\n      raffleRaw.publicKey,\r\n      draffleClient,\r\n      raffleRaw.account.totalPrizes\r\n    );\r\n\r\n    const endTimestamp = new Date(\r\n      raffleRaw.account.endTimestamp.toNumber() * 1000\r\n    );\r\n\r\n    return {\r\n      publicKey: raffleRaw.publicKey,\r\n      metadata: raffleMetaData,\r\n      endTimestamp,\r\n      entrantsCap: entrantsDataRaw.max,\r\n      entrants,\r\n      entrantsRaw: entrantsDataRaw.entrants,\r\n      totalTickets: entrantsDataRaw.total,\r\n      entrantsAccountAddress: raffleRaw.account.entrants,\r\n      randomness: raffleRaw.account.randomness as number[],\r\n      prizes,\r\n      proceeds: {\r\n        address: proceedsAccount.address,\r\n        ticketPrice: raffleRaw.account.ticketPrice,\r\n        mint: proceedsAccount.mintInfo,\r\n      },\r\n      isEnded: endTimestamp < new Date(),\r\n    };\r\n  };\r\n\r\n  const fetchAllRaffles = useCallback(\r\n    async (showAll: boolean = false) => {\r\n      // LOOK HERE\r\n      setFetching(true);\r\n      let raffleDataRawProgramAccounts: ProgramAccount<RaffleDataRaw>[] = [];\r\n      let entrantsDataRawProgramAccounts: ProgramAccount<EntrantsDataRaw>[] =\r\n        [];\r\n      try {\r\n        [raffleDataRawProgramAccounts, entrantsDataRawProgramAccounts] =\r\n          await getRaffleProgramAccounts(draffleClient);\r\n      } catch (e) {\r\n        console.log(e);\r\n      }\r\n\r\n      raffleDataRawProgramAccounts = raffleDataRawProgramAccounts.filter(\r\n        ({ publicKey }) => {\r\n          console.log({ showAll });\r\n          console.log(RAFFLES_WHITELIST.has(publicKey.toBase58()));\r\n          return showAll || RAFFLES_WHITELIST.has(publicKey.toBase58());\r\n        }\r\n      );\r\n      console.log({ raffleDataRawProgramAccounts });\r\n\r\n      const newRaffles = (\r\n        await Promise.all(\r\n          raffleDataRawProgramAccounts.map(async (raffleRaw) =>\r\n            getAssociatedRaffleData(\r\n              raffleRaw,\r\n              RAFFLES_WHITELIST.get(raffleRaw.publicKey.toString()) || {\r\n                name: 'Unnamed Raffle', // LOOOK HERE\r\n                alternatePurchaseMints: [],\r\n              },\r\n              draffleClient,\r\n              connection,\r\n              entrantsDataRawProgramAccounts.find(({ publicKey }) =>\r\n                publicKey.equals(raffleRaw.account.entrants)\r\n              )?.account\r\n            )\r\n          )\r\n        )\r\n      ).reduce<Map<string, Raffle>>((acc, raffle) => {\r\n        acc.set(raffle.publicKey.toString(), raffle);\r\n        return acc;\r\n      }, new Map<string, Raffle>());\r\n      setRaffles(newRaffles);\r\n      setFetching(false);\r\n    },\r\n    [connection, draffleClient]\r\n  );\r\n\r\n  const updateRaffleById = useCallback(\r\n    async (raffleId: string) => {\r\n      if (!raffles.has(raffleId.toString()) || !RAFFLES_WHITELIST.has(raffleId))\r\n        return;\r\n      setFetching(true);\r\n      const updatedRaffleRaw = await draffleClient.account.raffle.fetch(\r\n        new PublicKey(raffleId)\r\n      );\r\n      const updatedRaffle = await getAssociatedRaffleData(\r\n        { publicKey: new PublicKey(raffleId), account: updatedRaffleRaw },\r\n        RAFFLES_WHITELIST.get(raffleId)!,\r\n        draffleClient,\r\n        connection\r\n      );\r\n      if (!areEqualObjects(raffles.get(raffleId.toString()), updatedRaffle)) {\r\n        setRaffles((currentRaffles) => {\r\n          let newRaffles = cloneDeep(currentRaffles);\r\n          newRaffles = newRaffles.set(raffleId, updatedRaffle);\r\n          return newRaffles;\r\n        });\r\n      }\r\n      setFetching(false);\r\n    },\r\n    [connection, draffleClient, raffles, setRaffles]\r\n  );\r\n\r\n  useEffect(() => {\r\n    fetchAllRaffles();\r\n  }, [fetchAllRaffles]);\r\n\r\n  return (\r\n    <RafflesStoreContext.Provider\r\n      value={{\r\n        raffles,\r\n        fetchAllRaffles,\r\n        updateRaffleById,\r\n        fetching,\r\n      }}\r\n    >\r\n      {children}\r\n    </RafflesStoreContext.Provider>\r\n  );\r\n};\r\n\r\nexport default RafflesStoreProvider;\r\n"]},"metadata":{},"sourceType":"module"}