{"ast":null,"code":"import _toConsumableArray from \"C:/Riff-Raffle-Solana-NFT build 1-1/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"C:/Riff-Raffle-Solana-NFT build 1-1/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"C:/Riff-Raffle-Solana-NFT build 1-1/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Riff-Raffle-Solana-NFT build 1-1/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport * as assert from \"assert\";\nvar LOG_START_INDEX = \"Program log: \".length;\nexport var EventParser = /*#__PURE__*/function () {\n  function EventParser(coder, programId) {\n    _classCallCheck(this, EventParser);\n\n    this.coder = coder;\n    this.programId = programId;\n  } // Each log given, represents an array of messages emitted by\n  // a single transaction, which can execute many different programs across\n  // CPI boundaries. However, the subscription is only interested in the\n  // events emitted by *this* program. In achieving this, we keep track of the\n  // program execution context by parsing each log and looking for a CPI\n  // `invoke` call. If one exists, we know a new program is executing. So we\n  // push the programId onto a stack and switch the program context. This\n  // allows us to track, for a given log, which program was executing during\n  // its emission, thereby allowing us to know if a given log event was\n  // emitted by *this* program. If it was, then we parse the raw string and\n  // emit the event if the string matches the event being subscribed to.\n\n\n  _createClass(EventParser, [{\n    key: \"parseLogs\",\n    value: function parseLogs(logs, callback) {\n      var logScanner = new LogScanner(logs);\n      var execution = new ExecutionContext(logScanner.next());\n      var log = logScanner.next();\n\n      while (log !== null) {\n        var _this$handleLog = this.handleLog(execution, log),\n            _this$handleLog2 = _slicedToArray(_this$handleLog, 3),\n            event = _this$handleLog2[0],\n            newProgram = _this$handleLog2[1],\n            didPop = _this$handleLog2[2];\n\n        if (event) {\n          callback(event);\n        }\n\n        if (newProgram) {\n          execution.push(newProgram);\n        }\n\n        if (didPop) {\n          execution.pop();\n        }\n\n        log = logScanner.next();\n      }\n    } // Main log handler. Returns a three element array of the event, the\n    // next program that was invoked for CPI, and a boolean indicating if\n    // a program has completed execution (and thus should be popped off the\n    // execution stack).\n\n  }, {\n    key: \"handleLog\",\n    value: function handleLog(execution, log) {\n      // Executing program is this program.\n      if (execution.program() === this.programId.toString()) {\n        return this.handleProgramLog(log);\n      } // Executing program is not this program.\n      else {\n          return [null].concat(_toConsumableArray(this.handleSystemLog(log)));\n        }\n    } // Handles logs from *this* program.\n\n  }, {\n    key: \"handleProgramLog\",\n    value: function handleProgramLog(log) {\n      // This is a `msg!` log.\n      if (log.startsWith(\"Program log:\")) {\n        var logStr = log.slice(LOG_START_INDEX);\n        var event = this.coder.events.decode(logStr);\n        return [event, null, false];\n      } // System log.\n      else {\n          return [null].concat(_toConsumableArray(this.handleSystemLog(log)));\n        }\n    } // Handles logs when the current program being executing is *not* this.\n\n  }, {\n    key: \"handleSystemLog\",\n    value: function handleSystemLog(log) {\n      // System component.\n      var logStart = log.split(\":\")[0]; // Did the program finish executing?\n\n      if (logStart.match(/^Program (.*) success/g) !== null) {\n        return [null, true]; // Recursive call.\n      } else if (logStart.startsWith(\"Program \".concat(this.programId.toString(), \" invoke\"))) {\n        return [this.programId.toString(), false];\n      } // CPI call.\n      else if (logStart.includes(\"invoke\")) {\n          return [\"cpi\", false]; // Any string will do.\n        } else {\n          return [null, false];\n        }\n    }\n  }]);\n\n  return EventParser;\n}(); // Stack frame execution context, allowing one to track what program is\n// executing for a given log.\n\nvar ExecutionContext = /*#__PURE__*/function () {\n  function ExecutionContext(log) {\n    _classCallCheck(this, ExecutionContext);\n\n    // Assumes the first log in every transaction is an `invoke` log from the\n    // runtime.\n    var program = /^Program (.*) invoke.*$/g.exec(log)[1];\n    this.stack = [program];\n  }\n\n  _createClass(ExecutionContext, [{\n    key: \"program\",\n    value: function program() {\n      assert.ok(this.stack.length > 0);\n      return this.stack[this.stack.length - 1];\n    }\n  }, {\n    key: \"push\",\n    value: function push(newProgram) {\n      this.stack.push(newProgram);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      assert.ok(this.stack.length > 0);\n      this.stack.pop();\n    }\n  }]);\n\n  return ExecutionContext;\n}();\n\nvar LogScanner = /*#__PURE__*/function () {\n  function LogScanner(logs) {\n    _classCallCheck(this, LogScanner);\n\n    this.logs = logs;\n  }\n\n  _createClass(LogScanner, [{\n    key: \"next\",\n    value: function next() {\n      if (this.logs.length === 0) {\n        return null;\n      }\n\n      var l = this.logs[0];\n      this.logs = this.logs.slice(1);\n      return l;\n    }\n  }]);\n\n  return LogScanner;\n}();","map":null,"metadata":{},"sourceType":"module"}