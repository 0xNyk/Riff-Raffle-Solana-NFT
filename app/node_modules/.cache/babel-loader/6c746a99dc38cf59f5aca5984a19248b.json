{"ast":null,"code":"import { AccountsCoder } from '@project-serum/anchor';\nimport { parseTokenAccount } from '@project-serum/common';\nimport { u64 } from '@solana/spl-token';\nimport { PublicKey } from '@solana/web3.js';\nimport { tokenInfoMap, UNKNOWN_TOKEN_INFO } from '../../config/tokenRegistry';\nimport { getDisplayAmount } from '../accounts';\nimport { getMetadata, getNFTMetadata } from '../metadata';\nimport { PrizeType } from '../types';\nexport const fetchProceedsAccount = async (raffleAccountAddress, draffleClient, connection) => {\n  const [address] = await PublicKey.findProgramAddress([raffleAccountAddress.toBytes(), Buffer.from('proceeds')], draffleClient.programId);\n  const account = await connection.getAccountInfo(address);\n  if (!account) throw Error('Failed to fetch proceeds account');\n  const data = parseTokenAccount(account.data);\n  const tokenInfo = tokenInfoMap.get(data.mint.toString());\n  if (!tokenInfo) throw Error(`Info not found for proceeds account mint ${data.mint.toString()}`);\n  const mintInfo = {\n    name: tokenInfo.name,\n    publicKey: data.mint,\n    logoUrl: tokenInfo.logoURI,\n    symbol: tokenInfo.symbol,\n    decimals: tokenInfo.decimals\n  };\n  return {\n    address,\n    mintInfo\n  };\n};\n\nconst getPrizeAddressForPrizeIndex = async (raffleAccountAddress, prizeIndex, programId) => {\n  const [prizeAddress] = await PublicKey.findProgramAddress([raffleAccountAddress.toBuffer(), Buffer.from('prize'), new u64(prizeIndex).toArrayLike(Buffer, 'le', 4)], programId);\n  return prizeAddress;\n}; // Batch fetch prize token accounts then batch fetch metadata accounts given mint\n\n\nexport const fetchPrizes = async (raffleAccountAddress, draffleClient, totalPrizes) => {\n  let prizes = [];\n  const prizeAddresses = await Promise.all([...Array(totalPrizes).keys()].map(prizeIndex => getPrizeAddressForPrizeIndex(raffleAccountAddress, prizeIndex, draffleClient.programId)));\n  const prizeAccounts = await draffleClient.provider.connection.getMultipleAccountsInfo(prizeAddresses);\n  const prizeTokenAccounts = prizeAccounts.map(prizeAccount => {\n    if (!prizeAccount) {\n      throw new Error('Invalid prize account');\n    }\n\n    return parseTokenAccount(prizeAccount.data);\n  });\n  const metadataAddresses = await Promise.all(prizeTokenAccounts.map(prizeTokenAccount => getMetadata(prizeTokenAccount.mint)));\n  const metadataAccountsInfos = await draffleClient.provider.connection.getMultipleAccountsInfo(metadataAddresses);\n\n  for (const [index, prizeTokenAccount] of prizeTokenAccounts.entries()) {\n    prizes.push(await processPrize(prizeAddresses[index], prizeTokenAccount, metadataAccountsInfos[index]));\n  }\n\n  return prizes;\n};\n\nconst processPrize = async (prizeAddress, prizeTokenAccount, metadataAccountInfo) => {\n  let mintInfo;\n  const tokenInfo = tokenInfoMap.get(prizeTokenAccount.mint.toString());\n\n  if (tokenInfo) {\n    var _extensions;\n\n    const name = `${getDisplayAmount(prizeTokenAccount.amount, tokenInfo)} ${tokenInfo.symbol}`;\n    const imageURI = tokenInfo === null || tokenInfo === void 0 ? void 0 : (_extensions = tokenInfo.extensions) === null || _extensions === void 0 ? void 0 : _extensions.imageURI;\n    mintInfo = {\n      name,\n      publicKey: prizeTokenAccount.mint,\n      logoUrl: tokenInfo.logoURI,\n      symbol: tokenInfo.symbol,\n      decimals: tokenInfo.decimals\n    };\n    return {\n      address: prizeAddress,\n      mint: mintInfo,\n      amount: prizeTokenAccount.amount,\n      type: PrizeType.FT,\n      meta: {\n        imageUri: imageURI || tokenInfo.logoURI\n      }\n    };\n  } else {\n    // It isn't a recognized fungible token so it might be a NFT\n    const meta = metadataAccountInfo ? await getNFTMetadata(metadataAccountInfo) : undefined; // TODO: Need to distinguish between NFT types to fill correct attributes\n\n    const tokenInfo = UNKNOWN_TOKEN_INFO;\n    mintInfo = {\n      name: (meta === null || meta === void 0 ? void 0 : meta.name) || tokenInfo.name,\n      publicKey: prizeTokenAccount.mint,\n      logoUrl: (meta === null || meta === void 0 ? void 0 : meta.image) || tokenInfo.logoURI,\n      symbol: tokenInfo.symbol,\n      decimals: tokenInfo.decimals\n    };\n    return {\n      address: prizeAddress,\n      mint: mintInfo,\n      amount: prizeTokenAccount.amount,\n      type: PrizeType.NFTPicture,\n      meta: {\n        name: (meta === null || meta === void 0 ? void 0 : meta.name) || tokenInfo.name,\n        imageUri: (meta === null || meta === void 0 ? void 0 : meta.image) || tokenInfo.name\n      }\n    };\n  }\n};\n\nexport const toEntrantsProcessed = entrantsDataRaw => {\n  const entrantsProcessed = entrantsDataRaw.entrants.slice(0, entrantsDataRaw.total).reduce((acc, entrant, index) => {\n    if (acc.has(entrant.toString())) {\n      acc.get(entrant.toString()).tickets.push(index);\n    } else {\n      acc.set(entrant.toString(), {\n        publicKey: entrant,\n        tickets: [index]\n      });\n    }\n\n    return acc;\n  }, new Map());\n  return entrantsProcessed;\n};\nexport const getRaffleProgramAccounts = async (draffleClient) => {\n  const result = await draffleClient.provider.connection.getProgramAccounts(draffleClient.programId);\n  const raffleDiscriminator = AccountsCoder.accountDiscriminator('Raffle');\n  const entrantsDiscriminator = AccountsCoder.accountDiscriminator('Entrants');\n  const raffleDataRawProgramAccounts = [];\n  const entrantsDataRawProgramAccounts = [];\n  result.forEach(({\n    pubkey,\n    account\n  }) => {\n    const discriminator = account.data.slice(0, 8);\n\n    if (raffleDiscriminator.compare(discriminator) === 0) {\n      raffleDataRawProgramAccounts.push({\n        publicKey: pubkey,\n        account: draffleClient.coder.accounts.decode('Raffle', account.data)\n      });\n    } else if (entrantsDiscriminator.compare(discriminator) === 0) {\n      entrantsDataRawProgramAccounts.push({\n        publicKey: pubkey,\n        account: draffleClient.coder.accounts.decode('Entrants', account.data)\n      });\n    } else {\n      console.log(`Could not decode ${pubkey.toBase58()}`);\n    }\n  });\n  return [raffleDataRawProgramAccounts, entrantsDataRawProgramAccounts];\n};","map":{"version":3,"sources":["C:/Riff-Raffle-Solana-NFT build 1-1/app/src/lib/store/index.ts"],"names":["AccountsCoder","parseTokenAccount","u64","PublicKey","tokenInfoMap","UNKNOWN_TOKEN_INFO","getDisplayAmount","getMetadata","getNFTMetadata","PrizeType","fetchProceedsAccount","raffleAccountAddress","draffleClient","connection","address","findProgramAddress","toBytes","Buffer","from","programId","account","getAccountInfo","Error","data","tokenInfo","get","mint","toString","mintInfo","name","publicKey","logoUrl","logoURI","symbol","decimals","getPrizeAddressForPrizeIndex","prizeIndex","prizeAddress","toBuffer","toArrayLike","fetchPrizes","totalPrizes","prizes","prizeAddresses","Promise","all","Array","keys","map","prizeAccounts","provider","getMultipleAccountsInfo","prizeTokenAccounts","prizeAccount","metadataAddresses","prizeTokenAccount","metadataAccountsInfos","index","entries","push","processPrize","metadataAccountInfo","amount","imageURI","extensions","type","FT","meta","imageUri","undefined","image","NFTPicture","toEntrantsProcessed","entrantsDataRaw","entrantsProcessed","entrants","slice","total","reduce","acc","entrant","has","tickets","set","Map","getRaffleProgramAccounts","result","getProgramAccounts","raffleDiscriminator","accountDiscriminator","entrantsDiscriminator","raffleDataRawProgramAccounts","entrantsDataRawProgramAccounts","forEach","pubkey","discriminator","compare","coder","accounts","decode","console","log","toBase58"],"mappings":"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","sourcesContent":["import { AccountsCoder, ProgramAccount } from '@project-serum/anchor';\r\nimport { connection, parseTokenAccount } from '@project-serum/common';\r\nimport { u64, AccountInfo as TokenAccountInfo } from '@solana/spl-token';\r\nimport { AccountInfo, Connection, PublicKey } from '@solana/web3.js';\r\n\r\nimport { tokenInfoMap, UNKNOWN_TOKEN_INFO } from '../../config/tokenRegistry';\r\nimport {\r\n  DraffleProgram,\r\n  EntrantsDataRaw,\r\n  RaffleDataRaw,\r\n} from '../../providers/ProgramApisProvider';\r\nimport { getDisplayAmount } from '../accounts';\r\nimport { getMetadata, getNFTMetadata } from '../metadata';\r\nimport { Entrant, EntrantsMap, Mint, Prize, PrizeType } from '../types';\r\n\r\nexport const fetchProceedsAccount = async (\r\n  raffleAccountAddress: PublicKey,\r\n  draffleClient: DraffleProgram,\r\n  connection: Connection\r\n): Promise<{ address: PublicKey; mintInfo: Mint }> => {\r\n  const [address] = await PublicKey.findProgramAddress(\r\n    [raffleAccountAddress.toBytes(), Buffer.from('proceeds')],\r\n    draffleClient.programId\r\n  );\r\n\r\n  const account = await connection.getAccountInfo(address);\r\n  if (!account) throw Error('Failed to fetch proceeds account');\r\n  const data = parseTokenAccount(account.data);\r\n  const tokenInfo = tokenInfoMap.get(data.mint.toString());\r\n  if (!tokenInfo)\r\n    throw Error(\r\n      `Info not found for proceeds account mint ${data.mint.toString()}`\r\n    );\r\n  const mintInfo = {\r\n    name: tokenInfo.name,\r\n    publicKey: data.mint,\r\n    logoUrl: tokenInfo.logoURI,\r\n    symbol: tokenInfo.symbol,\r\n    decimals: tokenInfo.decimals,\r\n  };\r\n  return { address, mintInfo };\r\n};\r\n\r\nconst getPrizeAddressForPrizeIndex = async (\r\n  raffleAccountAddress: PublicKey,\r\n  prizeIndex: number,\r\n  programId: PublicKey\r\n): Promise<PublicKey> => {\r\n  const [prizeAddress] = await PublicKey.findProgramAddress(\r\n    [\r\n      raffleAccountAddress.toBuffer(),\r\n      Buffer.from('prize'),\r\n      new u64(prizeIndex).toArrayLike(Buffer, 'le', 4),\r\n    ],\r\n    programId\r\n  );\r\n  return prizeAddress;\r\n};\r\n\r\n// Batch fetch prize token accounts then batch fetch metadata accounts given mint\r\nexport const fetchPrizes = async (\r\n  raffleAccountAddress: PublicKey,\r\n  draffleClient: DraffleProgram,\r\n  totalPrizes: number,\r\n): Promise<Prize[]> => {\r\n  let prizes: Prize[] = [];\r\n\r\n  const prizeAddresses = await Promise.all(\r\n    [...Array(totalPrizes).keys()].map((prizeIndex) =>\r\n      getPrizeAddressForPrizeIndex(\r\n        raffleAccountAddress,\r\n        prizeIndex,\r\n        draffleClient.programId\r\n      )\r\n    )\r\n  );\r\n  const prizeAccounts =\r\n    await draffleClient.provider.connection.getMultipleAccountsInfo(\r\n      prizeAddresses\r\n    );\r\n  \r\n  const prizeTokenAccounts = prizeAccounts.map((prizeAccount) => {\r\n    if (!prizeAccount) {\r\n      throw new Error('Invalid prize account');\r\n    }\r\n    return parseTokenAccount(prizeAccount.data);\r\n  });\r\n\r\n  const metadataAddresses = await Promise.all(\r\n    prizeTokenAccounts.map((prizeTokenAccount) => getMetadata(prizeTokenAccount.mint))\r\n  );\r\n\r\n  const metadataAccountsInfos = await draffleClient.provider.connection.getMultipleAccountsInfo(\r\n    metadataAddresses\r\n  );\r\n\r\n  for (const [index, prizeTokenAccount] of prizeTokenAccounts.entries()) {\r\n    prizes.push(\r\n      await processPrize(\r\n        prizeAddresses[index],\r\n        prizeTokenAccount,\r\n        metadataAccountsInfos[index],\r\n      )\r\n    );\r\n  }\r\n  return prizes;\r\n};\r\n\r\nconst processPrize = async (\r\n  prizeAddress: PublicKey,\r\n  prizeTokenAccount: TokenAccountInfo,\r\n  metadataAccountInfo: AccountInfo<Buffer> | null\r\n): Promise<Prize> => {\r\n  let mintInfo;\r\n  const tokenInfo = tokenInfoMap.get(prizeTokenAccount.mint.toString());\r\n  if (tokenInfo) {\r\n    const name = `${getDisplayAmount(prizeTokenAccount.amount, tokenInfo)} ${tokenInfo.symbol}`;\r\n    const imageURI = (tokenInfo as any)?.extensions?.imageURI\r\n    mintInfo = {\r\n      name,\r\n      publicKey: prizeTokenAccount.mint,\r\n      logoUrl: tokenInfo.logoURI,\r\n      symbol: tokenInfo.symbol,\r\n      decimals: tokenInfo.decimals,\r\n    };\r\n    return {\r\n      address: prizeAddress,\r\n      mint: mintInfo,\r\n      amount: prizeTokenAccount.amount,\r\n      type: PrizeType.FT,\r\n      meta: {\r\n        imageUri: imageURI || tokenInfo.logoURI,\r\n      },\r\n    };\r\n  } else {\r\n    // It isn't a recognized fungible token so it might be a NFT\r\n    const meta = metadataAccountInfo\r\n      ? await getNFTMetadata(metadataAccountInfo)\r\n      : undefined;\r\n\r\n    // TODO: Need to distinguish between NFT types to fill correct attributes\r\n    const tokenInfo = UNKNOWN_TOKEN_INFO;\r\n    mintInfo = {\r\n      name: meta?.name || tokenInfo.name,\r\n      publicKey: prizeTokenAccount.mint,\r\n      logoUrl: meta?.image || tokenInfo.logoURI,\r\n      symbol: tokenInfo.symbol,\r\n      decimals: tokenInfo.decimals,\r\n    };\r\n    return {\r\n      address: prizeAddress,\r\n      mint: mintInfo,\r\n      amount: prizeTokenAccount.amount,\r\n      type: PrizeType.NFTPicture,\r\n      meta: {\r\n        name: meta?.name || tokenInfo.name,\r\n        imageUri: meta?.image || tokenInfo.name,\r\n      },\r\n    };\r\n  }\r\n};\r\n\r\nexport const toEntrantsProcessed = (entrantsDataRaw: EntrantsDataRaw) => {\r\n  const entrantsProcessed = entrantsDataRaw.entrants\r\n    .slice(0, entrantsDataRaw.total)\r\n    .reduce<EntrantsMap>((acc, entrant, index) => {\r\n      if (acc.has(entrant.toString())) {\r\n        acc.get(entrant.toString())!.tickets.push(index);\r\n      } else {\r\n        acc.set(entrant.toString(), {\r\n          publicKey: entrant,\r\n          tickets: [index],\r\n        });\r\n      }\r\n      return acc;\r\n    }, new Map<string, Entrant>());\r\n\r\n  return entrantsProcessed;\r\n}\r\n\r\nexport const getRaffleProgramAccounts = async (\r\n  draffleClient: DraffleProgram\r\n  ): Promise<[a: ProgramAccount<RaffleDataRaw>[], b: ProgramAccount<EntrantsDataRaw>[]]> => {\r\n\r\n  const result = await draffleClient.provider.connection.getProgramAccounts(\r\n    draffleClient.programId\r\n  );\r\n  const raffleDiscriminator = AccountsCoder.accountDiscriminator('Raffle');\r\n  const entrantsDiscriminator = AccountsCoder.accountDiscriminator('Entrants');\r\n\r\n  const raffleDataRawProgramAccounts: ProgramAccount<RaffleDataRaw>[] = [];\r\n  const entrantsDataRawProgramAccounts: ProgramAccount<EntrantsDataRaw>[] = [];\r\n\r\n  result.forEach(({ pubkey, account }) => {\r\n    const discriminator = account.data.slice(0, 8);\r\n\r\n    if (raffleDiscriminator.compare(discriminator) === 0) {\r\n      raffleDataRawProgramAccounts.push({\r\n        publicKey: pubkey,\r\n        account: draffleClient.coder.accounts.decode<RaffleDataRaw>(\r\n          'Raffle',\r\n          account.data\r\n        )\r\n      });\r\n    } else if (entrantsDiscriminator.compare(discriminator) === 0) {\r\n      entrantsDataRawProgramAccounts.push({\r\n        publicKey: pubkey,\r\n        account: draffleClient.coder.accounts.decode<EntrantsDataRaw>(\r\n          'Entrants',\r\n          account.data\r\n        )\r\n      });\r\n    } else {\r\n      console.log(`Could not decode ${pubkey.toBase58()}`);\r\n    }\r\n  });\r\n  return [raffleDataRawProgramAccounts, entrantsDataRawProgramAccounts];\r\n}"]},"metadata":{},"sourceType":"module"}