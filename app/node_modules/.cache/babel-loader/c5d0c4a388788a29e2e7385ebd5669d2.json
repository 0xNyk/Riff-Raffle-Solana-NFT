{"ast":null,"code":"import _toConsumableArray from \"C:/Users/kroni/Desktop/RIFF RAFFLE SITE PNSC/Riff-Raffle-Solana-NFT/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { snakeCase } from \"snake-case\";\nimport { sha256 } from \"js-sha256\";\nimport { IdlError } from \"../error\";\nexport function accountSize(idl, idlAccount) {\n  if (idlAccount.type.kind === \"enum\") {\n    var variantSizes = idlAccount.type.variants.map(function (variant) {\n      if (variant.fields === undefined) {\n        return 0;\n      }\n\n      return variant.fields // @ts-ignore\n      .map(function (f) {\n        // @ts-ignore\n        if (f.name === undefined) {\n          throw new Error(\"Tuple enum variants not yet implemented.\");\n        } // @ts-ignore\n\n\n        return typeSize(idl, f.type);\n      }).reduce(function (a, b) {\n        return a + b;\n      });\n    });\n    return Math.max.apply(Math, _toConsumableArray(variantSizes)) + 1;\n  }\n\n  if (idlAccount.type.fields === undefined) {\n    return 0;\n  }\n\n  return idlAccount.type.fields.map(function (f) {\n    return typeSize(idl, f.type);\n  }).reduce(function (a, b) {\n    return a + b;\n  });\n} // Returns the size of the type in bytes. For variable length types, just return\n// 1. Users should override this value in such cases.\n\nfunction typeSize(idl, ty) {\n  switch (ty) {\n    case \"bool\":\n      return 1;\n\n    case \"u8\":\n      return 1;\n\n    case \"i8\":\n      return 1;\n\n    case \"i16\":\n      return 2;\n\n    case \"u16\":\n      return 2;\n\n    case \"u32\":\n      return 4;\n\n    case \"i32\":\n      return 4;\n\n    case \"u64\":\n      return 8;\n\n    case \"i64\":\n      return 8;\n\n    case \"u128\":\n      return 16;\n\n    case \"i128\":\n      return 16;\n\n    case \"bytes\":\n      return 1;\n\n    case \"string\":\n      return 1;\n\n    case \"publicKey\":\n      return 32;\n\n    default:\n      // @ts-ignore\n      if (ty.vec !== undefined) {\n        return 1;\n      } // @ts-ignore\n\n\n      if (ty.option !== undefined) {\n        // @ts-ignore\n        return 1 + typeSize(idl, ty.option);\n      } // @ts-ignore\n\n\n      if (ty.defined !== undefined) {\n        // @ts-ignore\n        var filtered = idl.types.filter(function (t) {\n          return t.name === ty.defined;\n        });\n\n        if (filtered.length !== 1) {\n          throw new IdlError(\"Type not found: \".concat(JSON.stringify(ty)));\n        }\n\n        var typeDef = filtered[0];\n        return accountSize(idl, typeDef);\n      } // @ts-ignore\n\n\n      if (ty.array !== undefined) {\n        // @ts-ignore\n        var arrayTy = ty.array[0]; // @ts-ignore\n\n        var arraySize = ty.array[1]; // @ts-ignore\n\n        return typeSize(idl, arrayTy) * arraySize;\n      }\n\n      throw new Error(\"Invalid type \".concat(JSON.stringify(ty)));\n  }\n} // Not technically sighash, since we don't include the arguments, as Rust\n// doesn't allow function overloading.\n\n\nexport function sighash(nameSpace, ixName) {\n  var name = snakeCase(ixName);\n  var preimage = \"\".concat(nameSpace, \":\").concat(name);\n  return Buffer.from(sha256.digest(preimage)).slice(0, 8);\n}","map":null,"metadata":{},"sourceType":"module"}